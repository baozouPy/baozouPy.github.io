<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<script src="/js/src/photoswipe.min.js?v=6.0.0"></script>
<script src="/js/src/photoswipe-ui-default.min.js?v=6.0.0"></script>


<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/c6c3b5e3.js","daovoice")
  daovoice('init', {
      app_id: "c6c3b5e3"
    });
  daovoice('update');
  </script>






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  



  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">




  <link rel="icon" type="image/png" sizes="16x16" href="/favicon16.ico?v=6.0.0">






  <meta name="keywords" content="Python, 深度学习, 机器学习, machine learning, deeplearning">





  <link rel="alternate" href="/atom.xml" title="暴走的技术博客" type="application/atom+xml">






<meta name="description" content="你如果不忙着求生， 你就在忙着求死">
<meta name="keywords" content="Machine Learning&#x2F;Deep Learning&#x2F;Python&#x2F;">
<meta property="og:type" content="website">
<meta property="og:title" content="暴走的技术博客">
<meta property="og:url" content="https://www.baozouai.com/index.html">
<meta property="og:site_name" content="暴走的技术博客">
<meta property="og:description" content="你如果不忙着求生， 你就在忙着求死">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="暴走的技术博客">
<meta name="twitter:description" content="你如果不忙着求生， 你就在忙着求死">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.baozouai.com/">





  <title>暴走的技术博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a46909e912a122ce69d3b5e9a8dc661";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>
<!--动态标题-->
<script type="text/javascript" src="/js/src/dytitle.js"></script>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  


  
  
  
    
  



  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/baozouai" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴走的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">The people who are crazy enough to change the world are the ones who do！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photos">
          <a href="/photos" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera-retro"></i> <br>
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br>
            
            书单
          </a>
        </li>
      
        
        <li class="menu-item menu-item-movies">
          <a href="/movies" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-film"></i> <br>
            
            电影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>
    
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第五章  串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第五章  串/" itemprop="url">大话数据结构 第五章  串</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T12:47:00Z">
                2019-03-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:20:42Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第五章  串/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第五章  串/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第五章  串/" class="leancloud_visitors" data-flag-title="大话数据结构 第五章  串">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  579
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="5-1-串的定义"><a href="#5-1-串的定义" class="headerlink" title="5.1 串的定义"></a>5.1 串的定义</h1><p><strong>串（string）是由零个或多个字符组成的有限序列，又名叫字符串</strong></p>
<p>一般记为<script type="math/tex">s="a_1a_2\cdots a_n"(n\geq0)</script>，<script type="math/tex">s</script>是串的名称，用双引号（有些书中也用单引号）括起来的字符序列是串的值，<script type="math/tex">a_i(1\leq i\leq n)</script>可以是字母、数字或其他字符，<script type="math/tex">i</script>是该字符在串中的位置。串中的字符数目<script type="math/tex">n</script>称为串的长度，“有限”是指长度<script type="math/tex">n</script>是一个有限的数值。零个字符的串称为<strong>空串（nullstring）</strong>，它的长度为零，可以直接用两双引号“”””表示，也可以用希腊字母<script type="math/tex">\Phi</script>来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系</p>
<p><strong>空格串</strong>，是只包含空格的串。空格串是有内容有长度的，而且可以不止一个空格。</p>
<p>串中任意个数的连续字符组成的子序列称为该串的<strong>子串</strong>，相应地，包含子串的串称为<strong>主串</strong>。子串在主串中的位置就是子串的第一个字符在主串中的序号</p>
<h1 id="5-2-串的比较"><a href="#5-2-串的比较" class="headerlink" title="5.2 串的比较"></a>5.2 串的比较</h1><p>串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号</p>
<p>计算机中的常用字符是使用标准的<strong>ASCII</strong>编码，由<script type="math/tex">7</script>位二进制数表示一个字符，总共可以表示<script type="math/tex">128</script>个字符,后来扩展ASCII码由<script type="math/tex">8</script>位二进制数表示一个字符，总共可以表示<script type="math/tex">256</script>个字符</p>
<p><strong>Unicode</strong>编码，由<script type="math/tex">16</script>位的二进制数表示一个字符，这样总共就可以表示<script type="math/tex">2^{16}</script>个字符，约是<script type="math/tex">6.5</script>万多个字符，为了和ASCII码兼容，Unicode的前<script type="math/tex">256</script>个字符与ASCII码完全相同</p>
<p>在<script type="math/tex">C</script>语言中比较两个串是否相等，必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等。即给定两个串：<script type="math/tex">s="a_1a_2\cdots a_n",t="b_1b_2\cdots b_m"</script>，当且仅当<script type="math/tex">n=m</script>，且<script type="math/tex">a_1=b_1,a_2=b_2</script>,<script type="math/tex">\cdots,a_n=b_m</script>时，认为<script type="math/tex">s=t</script></p>
<p>两个串不相等时，判定大小：</p>
<p>给定两个串：<script type="math/tex">s="a_1a_2\cdots a_n",t="b_1b_2\cdots b_m"</script>，当满足以下条件之一时，<script type="math/tex">s<t</script></p>
<ol>
<li><script type="math/tex">n<m</script>，且<script type="math/tex">a_i=b_i(i=1,2,\cdots,n)</script>。例如当<script type="math/tex">s="hap",t="happy"</script>，就有<script type="math/tex">s<t</script>。因为<script type="math/tex">t</script>比<script type="math/tex">s</script>多出了两个字母。</li>
<li>存在某个<script type="math/tex">k\leq min(m,n)</script>，使得<script type="math/tex">a_i=b_i(i=1,2,\cdots,k-1)</script>，<script type="math/tex">a_k<b_k</script>,例如当<script type="math/tex">s="happen",t="happy"</script>，因为两串的前<script type="math/tex">4</script>个字母均相同，而两串第<script type="math/tex">5</script>个字母（<script type="math/tex">k</script>值），字母<script type="math/tex">e</script>的ASCII码是<script type="math/tex">101</script>，而字母<script type="math/tex">y</script>的ASCII码是<script type="math/tex">121</script>，显然<script type="math/tex">e<y</script>，所以<script type="math/tex">s<t</script></li>
</ol>
<h1 id="5-3-串的抽象数据类型"><a href="#5-3-串的抽象数据类型" class="headerlink" title="5.3 串的抽象数据类型"></a>5.3 串的抽象数据类型</h1><p>线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ADT 串（<span class="built_in">string</span>）</span><br><span class="line">Data</span><br><span class="line">串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line"></span><br><span class="line">StrAssign(T, *chars);<span class="comment">//生成一个其值等于字符串常量chars的串T。</span></span><br><span class="line"></span><br><span class="line">StrCopy(T, S);<span class="comment">//串S存在，由串S复制得串T。</span></span><br><span class="line"></span><br><span class="line">ClearString(S);<span class="comment">//串S存在，将串清空</span></span><br><span class="line">StringEmpty(S);<span class="comment">//若S为空，返回true，否则返回flase。</span></span><br><span class="line"></span><br><span class="line">StrLength(S);<span class="comment">//返回串S的元素个数，即串的长度。</span></span><br><span class="line"></span><br><span class="line">StrCompare(S, T);<span class="comment">//若S&gt;T，返回值&gt;0；若S=T，返回0；若S&lt;T，返回值&lt;0。</span></span><br><span class="line"></span><br><span class="line">Concat(T, S1, S2);<span class="comment">//用T返回有S1和S2联接而成的新串。</span></span><br><span class="line"></span><br><span class="line">SubString(Sub, S, pos, len);<span class="comment">//串S存在，1&lt;=pos&lt;=StrLength(S)，且0&lt;=len&lt;=Length(S)-pos+1；</span></span><br><span class="line"><span class="comment">//用串S的第pos个字符起长度为len的子串。</span></span><br><span class="line">Index(S, T, pos);<span class="comment">//串S和T存在，T是非空串，1&lt;=pos&lt;=StrLength(S)。若主串S中存在和串T值相同的子串，</span></span><br><span class="line"><span class="comment">//则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。</span></span><br><span class="line"></span><br><span class="line">Replace(S, T, V);<span class="comment">//串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。</span></span><br><span class="line"></span><br><span class="line">StrInsert(S, pos, T);<span class="comment">//串S和T存在，1&lt;=pos&lt;=StrLength(S)+1。在串S的第pos个字符之前插入串T。</span></span><br><span class="line"></span><br><span class="line">StrDelete(S, pos, len);<span class="comment">//串S存在，1&lt;=pos&lt;=StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。</span></span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>操作Index的实现算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(String S, String T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, i;</span><br><span class="line">String sub;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 得到主串S的长度 */</span></span><br><span class="line">n = StrLength(S);</span><br><span class="line"><span class="comment">/* 得到子串T的长度 */</span></span><br><span class="line">m = StrLength(T);</span><br><span class="line">i = pos;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n - m + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 取主串第i个位置 */</span></span><br><span class="line"><span class="comment">/* 长度与T相等子串给sub */</span></span><br><span class="line">SubString(sub, S, i, m);</span><br><span class="line"><span class="comment">/* 如果两串不相等 */</span></span><br><span class="line"><span class="keyword">if</span> (StrCompare(sub, T) != <span class="number">0</span>)</span><br><span class="line">++i;</span><br><span class="line"><span class="comment">/* 如果两串相等 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 则返回i值 */</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 若无子串与T相等，返回0 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用到了<strong>StrLength、SubString、StrCompare</strong>等基本操作来实现</p>
<h1 id="5-4-串的存储结构"><a href="#5-4-串的存储结构" class="headerlink" title="5.4 串的存储结构"></a>5.4 串的存储结构</h1><h2 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h2><p><strong>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列。</strong>按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义</p>
<p>一般可以将实际的串长度值保存在数组的<script type="math/tex">0</script>下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言规定在串值后面加一个不计入串长度的结束标记字符，比如“\0”来表示串值的终结</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/93import.png" alt>串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做<strong>“堆”</strong>。这个堆可由<script type="math/tex">C</script>语言的动态分配函数<strong>malloc()</strong>和<strong>free()</strong>来管理</p>
<h2 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h2><p>由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用<strong>“#”</strong>或其他非串值字符补全</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/94import.png" alt></p>
<p>串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好</p>
<h1 id="5-5-朴素的模式匹配算法"><a href="#5-5-朴素的模式匹配算法" class="headerlink" title="5.5 朴素的模式匹配算法"></a>5.5 朴素的模式匹配算法</h1><p><strong>子串的定位操作通常称做串的模式匹配</strong></p>
<p>从主串S=”goodgoogle”中，找到T=”google”这个子串的位置：</p>
<ol>
<li>主串<script type="math/tex">S</script>第一位开始，<script type="math/tex">S</script>与<script type="math/tex">T</script>前三个字母都匹配成功，但<script type="math/tex">S</script>第四个字母是<script type="math/tex">d</script>而<script type="math/tex">T</script>的是<script type="math/tex">g</script>。第一位匹配失败。其中竖直连线表示相等，闪电状弯折连线表示不等<img src="https://baozou.gitbooks.io/-data-structure/content/assets/95import.png" alt></li>
<li>主串<script type="math/tex">S</script>第二位开始，主串<script type="math/tex">S</script>首字母是<script type="math/tex">o</script>，要匹配的<script type="math/tex">T</script>首字母是<script type="math/tex">g</script>，匹配失败<img src="https://baozou.gitbooks.io/-data-structure/content/assets/96import.png" alt></li>
<li>主串<script type="math/tex">S</script>第三位开始，主串<script type="math/tex">S</script>首字母是<script type="math/tex">o</script>，要匹配的<script type="math/tex">T</script>首字母是<script type="math/tex">g</script>，匹配失败<img src="https://baozou.gitbooks.io/-data-structure/content/assets/97import.png" alt></li>
<li>主串<script type="math/tex">S</script>第四位开始，主串<script type="math/tex">S</script>首字母是<script type="math/tex">d</script>，要匹配的<script type="math/tex">T</script>首字母是<script type="math/tex">g</script>，匹配失败<img src="https://baozou.gitbooks.io/-data-structure/content/assets/98import.png" alt></li>
<li>主串<script type="math/tex">S</script>第五位开始，<script type="math/tex">S</script>与<script type="math/tex">T</script>，<script type="math/tex">6</script>个字母全匹配，匹配成功<img src="https://baozou.gitbooks.io/-data-structure/content/assets/99import.png" alt></li>
</ol>
<p>就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做<script type="math/tex">T</script>的长度的小循环，直到匹配成功或全部遍历完成为止</p>
<p>考虑不用串的其他操作，而是只用基本的数组来实现同样的算法<strong>Index</strong>。假设主串<script type="math/tex">S</script>和要匹配的子串<script type="math/tex">T</script>的长度存在<script type="math/tex">S[0]</script>与<script type="math/tex">T[0]</script>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span></span><br><span class="line"><span class="comment">/* T非空，1≤pos≤StrLength(S)。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(String S, String T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* i用于主串S中当前位置下标，若pos不为1, 则从pos位置开始匹配 */</span></span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 若i小于S长度且j小于T的长度时循环 */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) <span class="comment">/* S[0],T[0]储存着当前串的长度 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 两字母相等则继续 */</span></span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* i退回到上次匹配首位的下一位 */</span></span><br><span class="line">i = i - j + <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* j退回到子串T的首位 */</span></span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j = T[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好的情况是一开始就区配成功，比如<strong>“googlegood”</strong>中去找<strong>“google”</strong>，时间复杂度为<script type="math/tex">O(1)</script>。</p>
<p>稍差一些，如果像刚才例子中第二、三、四位一样，每次都是首字母就不匹配，那么对T串的循环就不必进行了，比如<strong>“abcdef-google”</strong>中去找<strong>“google”</strong>。那么时间复杂度为<script type="math/tex">O(n+m)</script>，<script type="math/tex">n</script>为主串长度，<script type="math/tex">m</script>为要匹配的子串长度。根据等概率原则，平均是<script type="math/tex">\frac{n+m}{2}</script>次查找，时间复杂度为<script type="math/tex">O(n+m)</script>。</p>
<p>最坏的情况是每次不成功的匹配都发生在串<script type="math/tex">T</script>的最后一个字符。如主串<script type="math/tex">S="00000000000000000000000000000000000000000000000001"</script>，而要匹配的子串为<script type="math/tex">T="0000000001"</script>，前者是有<script type="math/tex">49</script>个<script type="math/tex">"0"</script>和<script type="math/tex">1</script>个<script type="math/tex">"1"</script>的主串，后者是<script type="math/tex">9</script>个<script type="math/tex">"0"</script>和<script type="math/tex">1</script>个<script type="math/tex">"1"</script>的子串。在匹配时，每次都得将<script type="math/tex">T</script>中字符循环到最后一位才发现不匹配的。这样等于<script type="math/tex">T</script>串需要在<script type="math/tex">S</script>串的前<script type="math/tex">40</script>个位置都需要判断<script type="math/tex">10</script>次，并得出不匹配的结论</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/100import.png" alt></p>
<p>直到最后第<script type="math/tex">41</script>个位置，因为全部匹配相等，所以不需要再继续进行下去</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/101import.png" alt></p>
<p>如果最终没有可匹配的子串，比如是<script type="math/tex">T="0000000002"</script>，到了第<script type="math/tex">41</script>位置判断不匹配后同样不需要继续比对下去。因此最坏情况的时间复杂度为<script type="math/tex">O((n-m+1)*m)</script></p>
<h1 id="5-6-KMP模式匹配算法"><a href="#5-6-KMP模式匹配算法" class="headerlink" title="5.6 KMP模式匹配算法"></a>5.6 KMP模式匹配算法</h1><h2 id="KMP模式匹配算法原理"><a href="#KMP模式匹配算法原理" class="headerlink" title="KMP模式匹配算法原理"></a>KMP模式匹配算法原理</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/102import.png" alt></p>
<blockquote>
<p>②③④⑤没有必要，只保留①⑥即可</p>
</blockquote>
<p>对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/103import.png" alt></p>
<p>$j$值的多少取决于当前字符之前的串的前后缀的相似度。把<script type="math/tex">T</script>串各个位置的<script type="math/tex">j</script>值的<strong>变化</strong>定义为一个数组<script type="math/tex">next</script>，<script type="math/tex">next</script>的长度就是<script type="math/tex">T</script>串的长度。于是可以得到下面的函数定义：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/104import.png" alt></p>
<h2 id="next数组值推导"><a href="#next数组值推导" class="headerlink" title="next数组值推导"></a>next数组值推导</h2><p>1．<script type="math/tex">T="abcdex"</script></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><script type="math/tex">j</script></th>
<th style="text-align:center"><script type="math/tex">123456</script></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串<script type="math/tex">T</script></td>
<td style="text-align:center"><script type="math/tex">abcdex</script></td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">next[j]</script></td>
<td style="text-align:center"><script type="math/tex">011111</script></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>）当<script type="math/tex">j=1</script>时，<script type="math/tex">next[1]=0</script>；</li>
<li>）当<script type="math/tex">j=2</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>就只有字符“<script type="math/tex">a</script>”，属于其他情况<script type="math/tex">next[2]=1</script>；</li>
<li>）当<script type="math/tex">j=3</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>串是“<script type="math/tex">ab</script>”，显然“<script type="math/tex">a</script>”与“<script type="math/tex">b</script>”不相等，属其他情况，<script type="math/tex">next[3]=1</script>；</li>
<li>）以后同理，所以最终此<script type="math/tex">T</script>串的<script type="math/tex">next[j]</script>为<script type="math/tex">011111</script>。</li>
</ol>
<p>2．<script type="math/tex">T="abcabx"</script></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><script type="math/tex">j</script></th>
<th style="text-align:center"><script type="math/tex">123456</script></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串<script type="math/tex">T</script></td>
<td style="text-align:center"><script type="math/tex">abcabx</script></td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">next[j]</script></td>
<td style="text-align:center"><script type="math/tex">011123</script></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>）当<script type="math/tex">j=1</script>时，<script type="math/tex">next[1]=0</script>；</li>
<li>）当<script type="math/tex">j=2</script>时，同上例说明，<script type="math/tex">next[2]=1</script>；</li>
<li>）当<script type="math/tex">j=3</script>时，同上，<script type="math/tex">next[3]=1</script></li>
<li>）当<script type="math/tex">j=4</script>时，同上，<script type="math/tex">next[4]=1</script></li>
<li>）当<script type="math/tex">j=5</script>时，此时<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">abca</script>”，前缀字符“<script type="math/tex">a</script>”与后缀字符“<script type="math/tex">a</script>”相等，因此可推算出<script type="math/tex">k</script>值为<script type="math/tex">2</script>（由<script type="math/tex">'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'</script>，得到<script type="math/tex">p1=p4</script>）因此<script type="math/tex">next[5]=2</script>；</li>
<li>）当<script type="math/tex">j=6</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是<script type="math/tex">"abcab"</script>，由于前缀字符“<script type="math/tex">ab</script>”与后缀“<script type="math/tex">ab</script>”相等，所以<script type="math/tex">next[6]=3</script>。根据经验得到如果前后缀一个字符相等，<script type="math/tex">k</script>值是<script type="math/tex">2</script>，两个字符<script type="math/tex">k</script>值是<script type="math/tex">3</script>，<script type="math/tex">n</script>个相等<script type="math/tex">k</script>值就是<script type="math/tex">n+1</script></li>
</ol>
<p>3．<script type="math/tex">T="ababaaaba"</script></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><script type="math/tex">j</script></th>
<th style="text-align:center"><script type="math/tex">123456789</script></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串<script type="math/tex">T</script></td>
<td style="text-align:center"><script type="math/tex">ababaaaba</script></td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">next[j]</script></td>
<td style="text-align:center"><script type="math/tex">011234223</script></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>）当<script type="math/tex">j=1</script>时，<script type="math/tex">next[1]=0</script>；</li>
<li>）当<script type="math/tex">j=2</script>时，同上<script type="math/tex">next[2]=1</script>；</li>
<li>）当<script type="math/tex">j=3</script>时，同上<script type="math/tex">next[3]=1</script>；</li>
<li>）当<script type="math/tex">j=4</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">aba</script>”，前缀字符“<script type="math/tex">a</script>”与后缀字符“<script type="math/tex">a</script>”相等，<script type="math/tex">next[4]=2</script>；</li>
<li>）当<script type="math/tex">j=5</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">abab</script>”，由于前缀字符“<script type="math/tex">ab</script>”与后缀“<script type="math/tex">ab</script>”相等，所以<script type="math/tex">next[5]=3</script>；</li>
<li>）当<script type="math/tex">j=6</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">ababa</script>”，由于前缀字符“<script type="math/tex">aba</script>”与后缀“<script type="math/tex">aba</script>”相等，所以<script type="math/tex">next[6]=4</script>；</li>
<li>）当<script type="math/tex">j=7</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">ababaa</script>”，由于前缀字符“<script type="math/tex">ab</script>”与后缀“<script type="math/tex">aa</script>”并不相等，只有“<script type="math/tex">a</script>”相等，所以<script type="math/tex">next[7]=2</script>；</li>
<li>）当<script type="math/tex">j=8</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">ababaaa</script>”，只有“<script type="math/tex">a</script>”相等，所以<script type="math/tex">next[8]=2</script>；</li>
<li>）当<script type="math/tex">j=9</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">ababaaab</script>”，由于前缀字符“<script type="math/tex">ab</script>”与后缀“<script type="math/tex">ab</script>”相等，所以<script type="math/tex">next[9]=3</script>。</li>
</ol>
<p>4．<script type="math/tex">T="aaaaaaaab"</script></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><script type="math/tex">j</script></th>
<th style="text-align:center"><script type="math/tex">123456789</script></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串<script type="math/tex">T</script></td>
<td style="text-align:center"><script type="math/tex">aaaaaaaab</script></td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">next[j]</script></td>
<td style="text-align:center"><script type="math/tex">012345678</script></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>）当<script type="math/tex">j=1</script>时，<script type="math/tex">next[1]=0</script>；</li>
<li>）当<script type="math/tex">j=2</script>时，同上<script type="math/tex">next[2]=1</script>；</li>
<li>）当<script type="math/tex">j=3</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">aa</script>”，前缀字符“<script type="math/tex">a</script>”与后缀字符“<script type="math/tex">a</script>”相等，<script type="math/tex">next[3]=2</script>；</li>
<li>）当<script type="math/tex">j=4</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">aaa</script>”，由于前缀字符“<script type="math/tex">aa</script>”与后缀“<script type="math/tex">aa</script>”相等，所以<script type="math/tex">next[4]=3</script>；</li>
<li>）……</li>
<li>）当<script type="math/tex">j=9</script>时，<script type="math/tex">j</script>由<script type="math/tex">1</script>到<script type="math/tex">j-1</script>的串是“<script type="math/tex">aaaaaaaa</script>”，由于前缀字符“<script type="math/tex">aaaaaaa</script>”与后缀“<script type="math/tex">aaaaaaa</script>”相等，所以<script type="math/tex">next[9]=8</script></li>
</ol>
<h2 id="KMP模式匹配算法实现"><a href="#KMP模式匹配算法实现" class="headerlink" title="KMP模式匹配算法实现"></a>KMP模式匹配算法实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过计算返回子串T的next数组。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(String T, <span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;T[<span class="number">0</span>]) <span class="comment">/* 此处T[0]表示串T的长度 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span> || T[i]== T[j]) <span class="comment">/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */</span></span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j= next[j]; <span class="comment">/* 若字符不相同，则j值回溯 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码的目的就是为了计算出当前要匹配的串T的next数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span></span><br><span class="line"><span class="comment">/* T非空，1≤pos≤StrLength(S)。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(String S, String T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos; <span class="comment">/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="keyword">int</span> next[<span class="number">255</span>]; <span class="comment">/* 定义一next数组 */</span></span><br><span class="line">get_next(T, next); <span class="comment">/* 对串T作分析，得到next数组 */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) <span class="comment">/* 若i小于S的长度并且j小于T的长度时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">0</span> || S[i] == T[j]) <span class="comment">/* 两字母相等则继续，与朴素算法增加了j=0判断 */</span></span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line">j = next[j];<span class="comment">/* j退回合适的位置，i值不变 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于get_next函数来说，若T的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得index_KMP算法效率得到了提高，while循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n＋m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，是要好一些。</p>
<p>KMP算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显</p>
<h2 id="KMP模式匹配算法改进"><a href="#KMP模式匹配算法改进" class="headerlink" title="KMP模式匹配算法改进"></a>KMP模式匹配算法改进</h2><p>如果主串S=”aaaabcde”，子串T=”aaaaax”，其next数组值分别为012345，在开始时，当i=5、j=5时，“b”与“a”不相等，如图①，因此j=next[5]=4，如图中的②，此时“b”与第4位置的“a”依然不等，j=next[4]=3，如图中的③，后依次是④⑤，直到j=next[1]=0时，根据算法，此时++i、++j，得到i=6、j=1，如图中的⑥</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/105import.png" alt></p>
<p>当中的②③④⑤步骤，其实是多余的判断。由于T串的第二、三、四、五位置的字符都与首位的“a”相等，可以用首位next[1]的值去取代与它相等的字符后续next[j]的值</p>
<p>对求next函数进行了改良。假设取代的数组为nextval，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 求模式串T的next函数修正值并存入数组nextval */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(String T, <span class="keyword">int</span> *nextval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line">nextval[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;T[<span class="number">0</span>]) <span class="comment">/* 此处T[0]表示串T的长度 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span> || T[i]== T[j]) <span class="comment">/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */</span></span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line"><span class="keyword">if</span> (T[i]!=T[j]) <span class="comment">/* 若当前字符与前缀字符不同 */</span></span><br><span class="line">nextval[i] = j; <span class="comment">/* 则当前的j为nextval在i位置的值 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nextval[i] = nextval[j]; <span class="comment">/* 如果与前缀字符相同，则将前缀字符的 */</span></span><br><span class="line"><span class="comment">/* nextval值赋值给nextval在i位置的值 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j= nextval[j]; <span class="comment">/* 若字符不相同，则j值回溯 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际匹配算法，只需要将“get_next(T,next);”改为“get_nextval(T,next);”即可</p>
<h2 id="nextval数组值推导"><a href="#nextval数组值推导" class="headerlink" title="nextval数组值推导"></a>nextval数组值推导</h2><p>1．T=”ababaaaba”</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">j</th>
<th style="text-align:center">123456789</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串T</td>
<td style="text-align:center">ababaaaba</td>
</tr>
<tr>
<td style="text-align:center">next[j]</td>
<td style="text-align:center">011234223</td>
</tr>
<tr>
<td style="text-align:center">nextval[j]</td>
<td style="text-align:center">010104210</td>
</tr>
</tbody>
</table>
</div>
<p>先算出next数组的值分别为011234223，然后再分别判断。</p>
<ol>
<li>）当j=1时，nextval[1]=0；</li>
<li>）当j=2时，因第二位字符“b”的next值是1，而第一位就是“a”，它们不相等，所以nextval[2]=next[2]=1，维持原值。</li>
<li>）当j=3时，因为第三位字符“a”的next值为1，所以与第一位的“a”比较得知它们相等，所以nextval[3]=nextval[1]=0<img src="https://baozou.gitbooks.io/-data-structure/content/assets/106import.png" alt></li>
<li>）当j=4时，第四位的字符“b”next值为2，所以与第二位的“b”相比较得到结果是相等，因此nextval[4]=nextval[2]=1<img src="https://baozou.gitbooks.io/-data-structure/content/assets/107import.png" alt></li>
<li>）当j=5时，next值为3，第五个字符“a”与第三个字符“a”相等，因此nextval[5]=nextval[3]=0；</li>
<li>）当j=6时，next值为4，第六个字符“a”与第四个字符“b”不相等，因此nextval[6]=4；</li>
<li>）当j=7时，next值为2，第七个字符“a”与第二个字符“b”不相等，因此nextval[7]=2；</li>
<li>）当j=8时，next值为2，第八个字符“b”与第二个字符“b”相等，因此nextval[8]=nextval[2]=1</li>
<li>）当j=9时，next值为3，第九个字符“a”与第三个字符“a”相等，因此nextval[9]=nextval[3]=0</li>
</ol>
<p>2．T=”aaaaaaaab”</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">j</th>
<th style="text-align:center">123456789</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串T</td>
<td style="text-align:center">aaaaaaaab</td>
</tr>
<tr>
<td style="text-align:center">next[j]</td>
<td style="text-align:center">012345678</td>
</tr>
<tr>
<td style="text-align:center">nextval[j]</td>
<td style="text-align:center">000000008</td>
</tr>
</tbody>
</table>
</div>
<p>先算出next数组的值分别为012345678，然后再分别判断。</p>
<ol>
<li>）当j=1时，nextval[1]=0；</li>
<li>）当j=2时，next值为1，第二个字符与第一个字符相等，所以nextval[2]=nextval[1]=0；</li>
<li>）同样的道理，其后都为0……；</li>
<li>）当j=9时，next值为8，第九个字符“b”与第八个字符“a”不相等，所以nextval[9]=8。</li>
</ol>
<p>改进过的KMP算法，在计算出next值的同时，如果a位字符与它next值指向的b位字符相等，则该a位的nextval就指向b位的nextval值，如果不等，则该a位的nextval值就是它自己a位的next的值</p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第九章-排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第九章-排序/" itemprop="url">大话数据结构 第九章 排序</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:48:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:54:54Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第九章-排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第九章-排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第九章-排序/" class="leancloud_visitors" data-flag-title="大话数据结构 第九章 排序">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  288
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="9-1-排序的基本概念与分类"><a href="#9-1-排序的基本概念与分类" class="headerlink" title="9.1 排序的基本概念与分类"></a>9.1 排序的基本概念与分类</h1><p><strong>假设含有n个记录的序列为</strong><script type="math/tex">\{r_1,r_2,\cdots,r_n\}</script><strong>，其相应的关键字分别为</strong><script type="math/tex">\{k_1,k_2,\cdots,k_n\}</script><strong>，需确定1,2,……,n的一种排列</strong><script type="math/tex">p_1,p_2,\cdots,p_n</script><strong>，使其相应的关键字满足</strong><script type="math/tex">k_{p_1}\le k_{p_2}\le \cdots \le k_{p_n}</script><strong>（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列</strong><script type="math/tex">\{r_{p_1},r_{p_2},\cdots,r_{p_n}\}</script><strong>，这样的操作称为排序</strong></p>
<p>在排序问题中，通常将数据元素称为<strong>记录</strong>。输入的是一个记录集合，输出的也是一个记录集合，可以将排序看成是线性表的一种操作</p>
<p>排序的依据是关键字之间的大小关系，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列</p>
<p>关键字<script type="math/tex">k_i</script>可以是记录<script type="math/tex">r</script>的主关键字，也可以是次关键字，甚至是若干数据项的组合。</p>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>假设<script type="math/tex">k_i=k_j(1 \le i\le n,1\le j\le n,i\ne j)</script>，且在排序前的序列中<script type="math/tex">r_i</script>领先于<script type="math/tex">r_j</script>（即<script type="math/tex">i<j</script>）。如果排序后<script type="math/tex">r_i</script>仍领先于<script type="math/tex">r_j</script>，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中<script type="math/tex">r_j</script>领先<script type="math/tex">r_i</script>，则称所用的排序方法是不稳定的</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/246import.png" alt></p>
<h2 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h2><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序</p>
<p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</p>
<p>对于内排序，排序算法的性能主要是受3个方面影响：</p>
<p>1．时间性能</p>
<p>内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，移动可以通过改变记录的存储方式来予以避免。高效率的内排序算法是具有尽可能少的关键字比较次数和尽可能少的记录移动次数</p>
<p>2．辅助空间</p>
<p>辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间</p>
<p>3．算法的复杂性</p>
<p>是算法本身的复杂度，而不是指算法的时间复杂度。算法过于复杂会影响排序的性能</p>
<h2 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h2><p>排序用的顺序表结：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></span><br><span class="line"><span class="keyword">int</span> r[MAXSIZE + <span class="number">1</span>];</span><br><span class="line"><span class="comment">/* 用于记录顺序表的长度 */</span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>
<p>数组两元素的交换函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = L-&gt;r[i];</span><br><span class="line">L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-2-冒泡排序"><a href="#9-2-冒泡排序" class="headerlink" title="9.2 冒泡排序"></a>9.2 冒泡排序</h1><h2 id="最简单排序实现"><a href="#最简单排序实现" class="headerlink" title="最简单排序实现"></a>最简单排序实现</h2><p>冒泡排序（Bubble Sort）一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作交换排序(冒泡排序初级版) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort0</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 交换L-&gt;r[i]与L-&gt;r[j]的值 */</span></span><br><span class="line">swap(L, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不算标准的冒泡排序算法，不满足“两两比较相邻记录”的冒泡排序思想，思路是让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。假设待排序的关键字序列是{9,1,5,8,3,7,4,6,2}</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/257import.png" alt></p>
<p>算法的效率非常低</p>
<h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><p>正宗的冒泡算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注意j是从后往前循环 */</span></span><br><span class="line"><span class="keyword">for</span> (j = L-&gt;length - <span class="number">1</span>; j &gt;= i;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 若前者大于后者(注意这里与上一算法差异) */</span></span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当i=1,除了将关键字1放到第一的位置，还将关键字2从第九位置提到了第三的位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/270import.png" alt></p>
<p>当i=2时，变量j由8反向循环到2，逐个比较，在将关键字2交换到第二位置的同时，也将关键字4和3有所提升</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/271import.png" alt></p>
<h2 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h2><p>如果待排序的序列是{2,1,3,4,5,6,7,8,9}</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/272import.png" alt></p>
<p>当i=2时，已经对9与8，8与7，……，3与2作了比较，没有任何数据交换，说明此序列已经有序，不需要再继续后面的循环判断工作</p>
<p>增加一个标记变量flag来实现这一算法的改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作改进冒泡算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="comment">/* flag用来作为标记 */</span></span><br><span class="line">Status flag = TRUE;</span><br><span class="line"><span class="comment">/* 若flag为true说明有过数据交换，否则停止循环 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length &amp;&amp; flag; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 初始为false */</span></span><br><span class="line">flag = FALSE;</span><br><span class="line"><span class="keyword">for</span> (j = L-&gt;length - <span class="number">1</span>; j &gt;= i; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></span><br><span class="line">swap(L, j, j + <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 如果有数据交换，则flag为true */</span></span><br><span class="line">flag = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序复杂度分析"><a href="#冒泡排序复杂度分析" class="headerlink" title="冒泡排序复杂度分析"></a>冒泡排序复杂度分析</h2><p>最好的情况：要排序的表本身就是有序的，最后改进的代码是n-1次的比较，没有数据交换，时间复杂度为<script type="math/tex">O(n)</script></p>
<p>最坏的情况：待排序表是逆序的情况，此时需要比较</p>
<script type="math/tex; mode=display">
\sum_{i=2}^n( i-1)=1+2+3+...+(n-1)=\frac{n(n-1)}{2}</script><p>次，并作等数量级的记录移动。总时间复杂度为<script type="math/tex">O(n^2)</script></p>
<h1 id="9-3-简单选择排序"><a href="#9-3-简单选择排序" class="headerlink" title="9.3 简单选择排序"></a>9.3 简单选择排序</h1><h2 id="简单选择排序算法"><a href="#简单选择排序算法" class="headerlink" title="简单选择排序算法"></a>简单选择排序算法</h2><p>简单选择排序法（Simple Selection Sort）是通过<script type="math/tex">n-i</script>次关键字间的比较，从<script type="math/tex">n-i+1</script>个记录中选出关键字最小的记录，并和第<script type="math/tex">i</script>（1≤i≤n）个记录交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作简单选择排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, min;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将当前下标定义为最小值下标 */</span></span><br><span class="line">min = i;</span><br><span class="line"><span class="comment">/* 循环之后的数据 */</span></span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果有小于当前最小值的关键字 */</span></span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[min] &gt; L-&gt;r[j])</span><br><span class="line"><span class="comment">/* 将此关键字的下标赋值给min */</span></span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 若min不等于i，说明找到最小值，交换 */</span></span><br><span class="line"><span class="keyword">if</span> (i != min)</span><br><span class="line"><span class="comment">/* 交换L-&gt;r[i]与L-&gt;r[min]的值 */</span></span><br><span class="line">swap(L, i, min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当i=1时，最终交换了L.r[2]与L.r[1]的值。这里比较了8次，却只交换数据操作一次</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/273import.png" alt></p>
<p>当i=2,经过比较后，min=9，交换L.r[min]与L.r[i]的值</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/274import.png" alt></p>
<p>当i=3时，经过比较后，min=5，交换L.r[min]与L.r[i]的值</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/275import.png" alt></p>
<p>最多经过8次交换，就可完成排序工作</p>
<h2 id="简单选择排序复杂度分析"><a href="#简单选择排序复杂度分析" class="headerlink" title="简单选择排序复杂度分析"></a>简单选择排序复杂度分析</h2><p>简单选择排序最大的特点就是交换移动数据次数相当少，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较<script type="math/tex">\sum_{i=1}^{ n-1}(n-i)=(n-1)+(n-2)+\cdots+1=\frac{n(n-1)}{2}</script>次。对于交换次数，最好的时候交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为<script type="math/tex">O(n^2)</script></p>
<p>尽管与冒泡排序同为<script type="math/tex">O(n^2)</script>，但简单选择排序的性能上还是要略优于冒泡排序</p>
<h1 id="9-4-直接插入排序"><a href="#9-4-直接插入排序" class="headerlink" title="9.4 直接插入排序"></a>9.4 直接插入排序</h1><h2 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h2><p><strong>直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表</strong></p>
<p>直接插入排序法的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 设置哨兵 */</span></span><br><span class="line">L-&gt;r[<span class="number">0</span>] = L-&gt;r[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; L-&gt;r[j] &gt; L-&gt;r[<span class="number">0</span>]; j--)</span><br><span class="line"><span class="comment">/* 记录后移 */</span></span><br><span class="line">L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[j];</span><br><span class="line"><span class="comment">/* 插入到正确位置 */</span></span><br><span class="line">L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．传入的SqList参数的值为length=6,r[6]={0,5,3,4,6,2}，r[0]=0将用于后面起到哨兵的作用</p>
<p>2．i从2开始的意思是假设r[1]=5已经放好位置，后面的牌是插入到它的左侧还是右侧的问题</p>
<p>3．i=2，L.r[i]=3比L.r[i-1]=5要小，将L.r[0]赋值为L.r[i]=3的目的是为了起到记录后移的循环终止的判断依据。虚线箭头就是L.r[j+1]=L.r[j]的过程，将5右移一位</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/260import.png" alt></p>
<p>4．移动完成后，空出了空位，然后L.r[j+1]=L.r[0]，将哨兵的3赋值给j=0时的L.r[j+1]，将扑克牌3放置到L.r[1]的位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/261import.png" alt></p>
<p>5．i=3，L.r[i]=4比L.r[i-1]=5要小，将5再右移一位，将4放置到当前5所在位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/262import.png" alt></p>
<p>6．i=4。L.r[i]=6比L.r[i-1]=5要大，前三张牌的位置没有变化</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/263import.png" alt></p>
<p>7．i=5，L.r[i]=2比L.r[i-1]=6要小，6、5、4、3都比2大，都将右移一位，将2放置到当前3所在位置。排序也完成</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/264import.png" alt></p>
<h2 id="直接插入排序复杂度分析"><a href="#直接插入排序复杂度分析" class="headerlink" title="直接插入排序复杂度分析"></a>直接插入排序复杂度分析</h2><ul>
<li>最好的情况：排序的表本身有序，比较次数是L.r[i]与L.r[i-1]的比较，共比较了(n-1)（<script type="math/tex">\sum_{i=2}^ n 1</script>）次，由于每次都是L.r[i]&gt;L.r[i-1]，因此没有移动的记录，时间复杂度为<script type="math/tex">O(n)</script></li>
<li>最坏的情况，待排序表是逆序,需要比较<script type="math/tex">\sum_{i=2}^{ n} i=2+3+...+n=\frac{(n+2)(n-1)}{2}</script>次，记录的移动次数也达到最大值<script type="math/tex">\sum_{i=2}^ n (i+1)=\frac{(n+4)(n-1)}{2}</script>次</li>
<li>排序记录是随机的，根据概率相同的原则，平均比较和移动次数约为<script type="math/tex">\frac{n^2}{4}</script>次</li>
</ul>
<p>插入排序法的时间复杂度为<script type="math/tex">O(n^2)</script>。同样的<script type="math/tex">O(n^2)</script>时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好</p>
<h1 id="9-5-希尔排序"><a href="#9-5-希尔排序" class="headerlink" title="9.5 希尔排序"></a>9.5 希尔排序</h1><h2 id="希尔排序原理"><a href="#希尔排序原理" class="headerlink" title="希尔排序原理"></a>希尔排序原理</h2><p>将原本有大量记录数的记录进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数比较少，然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，再对全体记录进行一次直接插入排序</p>
<p>基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间</p>
<p>{2,1,3,6,4,7,5,8,9}可以称为基本有序。{1,5,9,3,7,8,2,4,6}的9在第三位，2在倒数第三位谈不上基本有序</p>
<p>跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</p>
<h2 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> increment = L-&gt;length;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 增量序列 */</span></span><br><span class="line">increment = increment / <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = increment + <span class="number">1</span>; i &lt;= L-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - increment])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 需将L-&gt;r[i]插入有序增量子表 */</span></span><br><span class="line"><span class="comment">/* 暂存在L-&gt;r[0] */</span></span><br><span class="line">L-&gt;r[<span class="number">0</span>] = L-&gt;r[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - increment; j &gt; <span class="number">0</span> &amp;&amp;</span><br></pre></td></tr></table></figure>
<p>1．传入的SqList参数的值为length=9,r[10]={0,9,1,5,8,3,7,4,6,2}</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/265import.png" alt></p>
<p>2．变量increment是“增量”，初始值让它等于待排序的记录数</p>
<p>3．do循环提终止条件是增量为1时停止循环</p>
<p>4．increment=9/3+1=4</p>
<p>5．for循环i从4+1=5开始到9结束</p>
<p>6．L.r[5]=3小于L.r[i-incre-ment]=L.r[1]=9,将第5位的3和第1位的9交换位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/266import.png" alt></p>
<p>7．i=6，L.r[6]=7&gt;L.r[i-incre-ment]=L.r[2]=1，不交换数据</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png267" alt></p>
<p>8．i=7，L.r[7]=4&lt;L.r[i-incre-ment]=L.r[3]=5，交换数据</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/268import.png" alt></p>
<p>9．i=8，L.r[8]=6&lt;L.r[i-incre-ment]=L.r[4]=8，交换数据</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/269import.png" alt></p>
<p>10．i=9，L.r[9]=2&lt;L.r[i-incre-ment]=L.r[5]=9，交换数据。继续比较L.r[5]与L.r[1]的大小，2&lt;3，交换L.r[5]与L.r[1]的数据</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/280import.png" alt></p>
<p>第一轮循环后，数组的排序：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/281import.png" alt></p>
<p>希尔排序的精华：将关键字较小的记录，跳跃式地往前移，使得每次完成一轮循环后，整个序列朝着有序坚实地迈进一步</p>
<p>11．在完成一轮do循环后，increment=4/3+1=2。i从2+1=3开始到9结束。当i=3、4时，不用交换，当i=5时，需要交换数据</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/283import.png" alt></p>
<p>12．i=6、7、8、9均不用交换</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/284import.png" alt></p>
<p>13．increment=2&gt;1，再次do循环，incre-ment=2/3+1=1是最后一轮do循环。尽管for循环i从 1+1=2开始到9结束，但由于当前序列已经基本有序，可交换数据的情况大为减少，效率其实很高。箭头连线为需要交换的关键字</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/285import.png" alt></p>
<p>最终完成排序过程：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/286import.png" alt></p>
<h2 id="希尔排序复杂度分析"><a href="#希尔排序复杂度分析" class="headerlink" title="希尔排序复杂度分析"></a>希尔排序复杂度分析</h2><p>希尔排序的关键是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高</p>
<p>当增量序列为dlta[k]=<script type="math/tex">2^{t-k+1}-1</script>（0≤k≤t≤[<script type="math/tex">\log_2(n+1)</script>]）时，可以获得不错的效率，其时间复杂度为<script type="math/tex">O(n^{\frac{3}{2}})</script>，要好于直接排序的<script type="math/tex">O(n^2)</script>。<strong>增量序列的最后一个增量值必须等于1</strong>。由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法</p>
<h1 id="9-6-堆排序"><a href="#9-6-堆排序" class="headerlink" title="9.6 堆排序"></a>9.6 堆排序</h1><p><strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/287import.png" alt></p>
<p>根结点一定是堆中所有结点最大（小）者。较大（小）的结点靠近根结点（不绝对，右图小顶堆中60、40均小于70，但没有70靠近根结点）</p>
<p>按照层序遍历的方式给结点从1开始编号，结点之间满足如下关系：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/290import.png" alt></p>
<p>将大顶堆和小顶堆用层序遍历存入数组：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/291import.png" alt></p>
<h2 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h2><p>堆排序（Heap Sort）是利用堆（假设利用大顶堆）进行排序的方法。基本思想是将待排序的序列构造成一个大顶堆。此整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值。如此反复执行，便能得到一个有序序列</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/292import.png" alt></p>
<p>实现需要解决两个问题：</p>
<ol>
<li>如何由一个无序序列构建成一个堆</li>
<li>如何在输出堆顶元素后，调整剩余元素成为一个新的堆</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L进行堆排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">/* 把L中的r构建成一个大顶堆 */</span></span><br><span class="line"><span class="keyword">for</span> (i = L-&gt;length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">HeapAdjust(L, i, L-&gt;length);</span><br><span class="line"><span class="keyword">for</span> (i = L-&gt;length; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></span><br><span class="line">swap(L, <span class="number">1</span>, i);</span><br><span class="line"><span class="comment">/* 将L-&gt;r[1..i-1]重新调整为大顶堆 */</span></span><br><span class="line">HeapAdjust(L, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设要排序的序列是{50,10,90,30,70,40,80,60,20}，L.length=9，第一个for循环，i从=4开始，4→3→2→1的变量变化。4到1都是有孩子的结点。灰色结点的下标编号就是1、2、3、4</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/293import.png" alt></p>
<p>将待排序的序列构建成为一个大顶堆，就是从下往上、从右到左，将每个非终端结点（非叶结点）当作根结点，将其和其子树调整成大顶堆。i的4→3→2→1的变量变化，就是30，90，10、50的结点调整过程</p>
<p>HeapAdjust（堆调整）函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义 */</span></span><br><span class="line"><span class="comment">/* 本函数调整L-&gt;r[s]的关键字，使L-&gt;r[s..m]成为一个大顶堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, j;</span><br><span class="line">temp = L-&gt;r[s];</span><br><span class="line"><span class="comment">/* 沿关键字较大的孩子结点向下筛选 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line"><span class="comment">/* j为关键字中较大的记录的下标 */</span></span><br><span class="line">++j;</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= L-&gt;r[j])</span><br><span class="line"><span class="comment">/* rc应插入在位置s上 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">L-&gt;r[s] = L-&gt;r[j];</span><br><span class="line">s = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 插入 */</span></span><br><span class="line">L-&gt;r[s] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．函数被第一次调用时，s=4，m=9，传入的SqList参数的值为length=9,r[10]={0,50,10,90,30,70,40,80,60,20}</p>
<p>2．将L.r[s]=L.r[4]=30赋值给temp</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png306" alt>3．循环遍历结点的孩子。j变量从2s开始是二叉树的性质5，因为完全二叉树，当前结点序号是s，其左孩子的序号一定是2s，右孩子的序号一定是2s+1，它们的孩是以2的位数序号增加</p>
<p>4．j=2*4=8&lt;m说明不是最后一个结点，如果L.r[j]&lt;L.r[j+1]，则说明左孩子小于右孩子。目的是要找到较大值，需要让j+1以便变成指向右孩子的下标。当前30的左右孩子是60和20，并不满足此条件，因此j还是8</p>
<p>5．temp=30，L.r[j]=60，不满足条件</p>
<p>6．将60赋值给L.r[4]，并令s=j=8。算出以30为根结点的子二叉树当前最大值是60，在第8的位置。此时L.r[4]和L.r[8]的值均为60</p>
<p>7．再循环因为j=2*j=16&gt;m，跳出循环。</p>
<p>8．将temp=30赋值给L.r[s]=L.r[8]，完成30与60的交换本次函数调用完成</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png307" alt></p>
<p>9．再次调用HeapAdjust，此时s=3，m=9。temp=L.r[3]=90，由于40&lt;80得到j+1=2*s+1=7。由于90&gt;80，因此退出循环</p>
<p>10．再次调用HeapAdjust，此时s=2，m=9。temp=L.r[2]=10，60&lt;70，使得j=5。最终本次调用使得10与70进行了互换</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png308" alt></p>
<p>11．再次调用HeapAdjust，此时s=1，m=9。temp=L.r[1]=50，70&lt;90，使得j=3。L.r[1]被赋值了90，并且s=3，再循环，2j=6并未大于m，再次执行循环体，L.r[3]被赋值了80，完成循环后，L.[7]被赋值为50，最终本次调用使得50、90、80进行了轮换</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png309" alt></p>
<p>HeapSort函数的排序过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = L-&gt;length; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></span><br><span class="line">swap(L,<span class="number">1</span>,i);</span><br><span class="line"><span class="comment">/* 将L-&gt;r[1..i-1]重新调整为大顶堆 */</span></span><br><span class="line">HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．i=9，交换20与90，将当前的根结点20进行大顶堆的调整，找到它左右子结点的较大值，互换，再找到其子结点的较大值互换。序列变为{80,70,50,60,10,40,20,30,90}</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/306import.png" alt></p>
<p>2．i=8，交换30与80，并将30与70交换，再与60交换，序列变为{70,60,50,30,10,40,20,80,90}</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/307import.png" alt></p>
<p>3．后面的变化</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/308import.png" alt><img src="https://baozou.gitbooks.io/-data-structure/content/assets/309import.png" alt></p>
<h2 id="堆排序复杂度分析"><a href="#堆排序复杂度分析" class="headerlink" title="堆排序复杂度分析"></a>堆排序复杂度分析</h2><p>运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上</p>
<p>构建堆：因为是完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点，最多进行两次比较和互换操作，时间复杂度为<script type="math/tex">O(n)</script></p>
<p>正式排序：第<script type="math/tex">i</script>次取堆顶记录重建堆需要用<script type="math/tex">O(\log i)</script>的时间（完全二叉树的某个结点到根结点的距离为<script type="math/tex">[log_2 i] + 1</script>），并且需要取<script type="math/tex">n-1</script>次堆顶记录，因此重建堆的时间复杂度为<script type="math/tex">O(n\log n)</script></p>
<p>总体堆排序的时间复杂度为<script type="math/tex">O(nlogn)</script></p>
<p>空间复杂度上只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与交换是跳跃式进行，堆排序也是一种不稳定的排序方法</p>
<p>由于初始构建堆所需的比较次数较多，不适合待排序序列个数较少的情况</p>
<h1 id="9-7-归并排序"><a href="#9-7-归并排序" class="headerlink" title="9.7 归并排序"></a>9.7 归并排序</h1><h2 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h2><p><strong>归并：将两个或两个以上的有序表组合成一个新的有序表</strong></p>
<p>假设初始序列含有n个记录，看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到|n/2|（|x|表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作归并排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MSort(L-&gt;r, L-&gt;r, <span class="number">1</span>, L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对数组{50,10,90,30,70,40,80,60,20}进行排序，L.length=9：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将SR[s..t]归并排序为TR1[s..t] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR1[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> TR2[MAXSIZE + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (s == t)</span><br><span class="line">TR1[s] = SR[s];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */</span></span><br><span class="line">m = (s + t) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 递归将SR[s..m]归并为有序的TR2[s..m] */</span></span><br><span class="line">MSort(SR, TR2, s, m);</span><br><span class="line"><span class="comment">/* 递归将SR[m+1..t]归并为有序TR2[m+1..t] */</span></span><br><span class="line">MSort(SR, TR2, m + <span class="number">1</span>, t);</span><br><span class="line"><span class="comment">/* 将TR2[s..m]和TR2[m+1..t] 归并到TR1[s..t] */</span></span><br><span class="line">Merge(TR2,TR1, s, m, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．MSort被调用时，SR与TR1都是{50,10,90,30,70,40,80,60,20}，s=1，t=9，最终是要将TR1中的数组排好顺序</p>
<p>2．调用“MSort(SR,TR2,1,5);”是将数组SR中的第1～5的关键字归并到有序的TR2（调用前TR2为空数组），调用“MSort(SR,TR2,6,9);”是将数组SR中的第6～9的关键字归并到有序的TR2</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/310import.png" alt></p>
<p>3．调用“Merge(TR2,TR1,1,5,9);”是将获得的数组TR2（下标为1～5和6～9的关键字分别有序）归并为TR1，整个排序完成</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/311import.png" alt></p>
<p>4．递归调用进去后，s=1，t=5，m=(1+5)/2=3。相当于将5个记录拆分为三个和两个。继续递归进去，直到细分为一个记录填入TR2，此时s与t相等，递归返回，如左图。每次递归返回后都会执行当前递归函数的Merge(TR2,TR1, s, m, t);，将TR2归并到TR1中，如右图，最终使得当前序列有序</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/312import.png" alt></p>
<p>5．MSort(SR, TR2, m + 1, t); 也是类似</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/313import.png" alt></p>
<p>8．最后一次执行Merge(TR2,TR1, s, m, t);，将{10,30,50,70,90}与{20,40,60,80}归并为最终有序的序列</p>
<p>整个数据变换示意图：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/314import.png" alt></p>
<p>Merge函数的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, k, l;</span><br><span class="line"><span class="comment">/* 将SR中记录由小到大归并入TR */</span></span><br><span class="line"><span class="keyword">for</span> (j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (SR[i] &lt; SR[j])</span><br><span class="line">TR[k] = SR[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">TR[k] = SR[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= m - i; l++)</span><br><span class="line"><span class="comment">/* 将剩余的SR[i..m]复制到TR */</span></span><br><span class="line">TR[k + l]=SR[i + l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line"><span class="comment">/* 将剩余的SR[j..n]复制到TR */</span></span><br><span class="line">TR[k + l] = SR[j + l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．假设调用的Merge是将{10,30,50,70,90}与{20,40,60,80}归并为最终有序的序列，因此数组SR为{10,30,50,70,90,20,40,60,80}，i=1，m=5，n=9</p>
<p>2．j由m+1=6开始到9，i由1开始到5，k由1开始每次加1，k值用于目标数组TR的下标</p>
<p>3．SR[i]=SR[1]=10，SR[j]=SR[6]=20，TR[k]=TR[1]=10，并且i++</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/315import.png" alt></p>
<p>4．k++得到k=2，SR[i]=SR[2]=30，SR[j]=SR[6]=20，TR[k]=TR[2]=20，并且j++</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/316import.png" alt></p>
<p>5．k++得到k=3，SR[i]=SR[2]=30，SR[j]=SR[7]=40，TR[k]=TR[3]=30，并且i++</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/317import.png" alt></p>
<p>6．到j++后，j=10，大于9退出循环</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/320import.png" alt></p>
<p>7．将归并剩下的数组数据，移动到TR的后面。当前k=9，i=m=5，for循环l=0，TR[k+l]=SR[i+l]=90，完成归并排序</p>
<h2 id="归并排序复杂度分析"><a href="#归并排序复杂度分析" class="headerlink" title="归并排序复杂度分析"></a>归并排序复杂度分析</h2><p>一趟归并需要将SR[1]～SR[n]中相邻的长度为h的有序序列进行两两归并，将结果放到TR1[1]～TR1[n]中，需要将待排序序列中的所有记录扫描一遍，耗费<script type="math/tex">O(n)</script>时间，由完全二叉树的深度可知，整个归并排序需要进行<script type="math/tex">[log_2n]</script>次，总的时间复杂度为<script type="math/tex">O(nlogn)</script>，这是归并排序算法中最好、最坏、平均的时间性能</p>
<p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间<script type="math/tex">n</script>存放归并结果以及递归时深度为<script type="math/tex">log
_2n</script>的栈空间，因此空间复杂度为<script type="math/tex">O(n+logn)</script></p>
<p>Merge函数中if(SR[i]&lt;SR[j])语句说明需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法</p>
<p>归并排序是一种比较占用内存，但却效率高且稳定的算法</p>
<h2 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作归并非递归排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 申请额外空间 */</span></span><br><span class="line"><span class="keyword">int</span> * TR = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(L-&gt;length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; L-&gt;length)</span><br><span class="line">&#123;</span><br><span class="line">MergePass(L-&gt;r, TR, k, L-&gt;length);</span><br><span class="line"><span class="comment">/*子序列长度加倍 */</span></span><br><span class="line">k = <span class="number">2</span> * k;</span><br><span class="line">MergePass(TR, L-&gt;r, k, L-&gt;length);</span><br><span class="line"><span class="comment">/* 子序列长度加倍 */</span></span><br><span class="line">k = <span class="number">2</span> * k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．k=1，MergePass函数将原来的无序数组两两归并入TR</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/321import.png" alt></p>
<p>2．k=2，MergePass函数将TR中已经两两归并的有序序列再次归并回数组L.r中</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/322import.png" alt></p>
<p>3．k=4,再次归并，k=16，结束循环，完成排序工作</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/323import.png" alt></p>
<p>MergePass代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n - <span class="number">2</span> * s + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 两两归并 */</span></span><br><span class="line">Merge(SR, TR, i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);</span><br><span class="line">i = i + <span class="number">2</span> * s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 归并最后两个序列 */</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; n - s + <span class="number">1</span>)</span><br><span class="line">Merge(SR, TR, i, i + s - <span class="number">1</span>, n);</span><br><span class="line"><span class="comment">/* 若最后只剩下单个子序列 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt;= n; j++)</span><br><span class="line">TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．第一次调用“MergePass(L.r,TR,k,L.length);”，此时L.r是初始无序状态，TR为新申请的空数组，k=1，L.length=9</p>
<p>2．循环的目的就两两归并，因s=1，n-2×s＋1=8，循环i从1到8而不是9是因为两两归并，最终9条记录定会剩下来，无法归并</p>
<p>3．i=1，i＋s-1=1，i＋2×s-1=2。将SR（即L.r）中的第一个和第二个记录归并到TR中，i=i＋2×s=3，再循环，将第三个和第四个记录归并到TR中，一直到第七和第八个记录完成归并</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/325import.png" alt></p>
<p>4．处理最后的尾数，将最后剩下的多个记录归并到TR中。由于i=9，n-s＋1=9，将20放入到TR数组的最后</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/326import.png" alt></p>
<p>5．再次调用MergePass时，s=2，由i=i＋2×s知此时i以4为增量进行循环，即将两个有两个记录的有序序列进行归并为四个记录的有序序列。最终再将最后剩下的第九条记录“20”插入TR</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/327import.png" alt></p>
<p>非递归的迭代方法，避免了递归时深度为<script type="math/tex">log_2n</script>的栈空间，空间只是用到申请归并临时用的TR数组，空间复杂度为<script type="math/tex">O(n)</script>，避免递归在时间性能上也有一定的提升</p>
<h1 id="9-8-快速排序"><a href="#9-8-快速排序" class="headerlink" title="9.8 快速排序"></a>9.8 快速排序</h1><p>希尔排序相当于直接插入排序的升级，同属于插入排序类，堆排序相当于简单选择排序的升级，同属于选择排序类。快速排序是最慢的冒泡排序的升级，属于交换排序类。它是通过不断比较和移动交换来实现排序的，只不过它的实现增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从后面直接移动到前面，减少了总的比较次数和移动交换次数</p>
<h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><p>快速排序（Quick Sort）的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，分别对这两部分记录继续排序，达到整个序列有序</p>
<p>对数组{50,10,90,30,70,40,80,60,20}进行排序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QSort(L, <span class="number">1</span>, L-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QSort的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></span><br><span class="line">pivot = Partition(L, low, high);</span><br><span class="line"><span class="comment">/* 对低子表递归排序 */</span></span><br><span class="line">QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 对高子表递归排序 */</span></span><br><span class="line">QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的核心是“pivot=Partition(L,low,high);”,执行它之前，L.r的数组值为{50,10,90,30,70,40,80,60,20}。Partition函数要做的是先选取当中的一个关键字，如50，想尽办法将它放到一个位置，使得左边的值都比它小，右边的值比它大，这样的关键字称为<strong>枢轴（pivot）</strong></p>
<p>经过Partition(L,1,9)的执行之后，数组变成{20,10,40,30,50,70,80,60,90}，并返回值5给pivot，数字5表明50放置在数组下标为5的位置。计算机把原来的数组变成了两个位于50左和右小数组{20,10,40,30}和{70,80,60,90}，而后的递归调用“QSort(L,1,5-1);”和“QSort(L,5+1,9);”，对{20,10,40,30}和{70,80,60,90}分别进行同样的Partition操作，直到顺序全部正确为止</p>
<p>Partition函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></span><br><span class="line"><span class="comment">/* 此时在它之前（后）的记录均不大（小）于它*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivotkey;</span><br><span class="line"><span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">pivotkey = L-&gt;r[low];</span><br><span class="line"><span class="comment">/* 从表的两端交替向中间扫描 */</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)</span><br><span class="line">high--;</span><br><span class="line"><span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></span><br><span class="line">swap(L, low, high);</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class="line">low++;</span><br><span class="line"><span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></span><br><span class="line">swap(L, low, high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1．low=1，high=L.length=9。将L.r[low]=L.r[1]=50赋值给枢轴变量pivotkey</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png436" alt></p>
<p>2．交换L.r[low]与L.r[high]的值，使得L.r[1]=20，L.r[9]=50</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/347import.png" alt></p>
<p>3．low=3，L.r[3]=90&gt;50，<br>交换L.r[low]=L.r[3]与L.r[high]=L.r[9]的值，使得L.r[3]=50，L.r[9]=90。此时low指向3</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/337import.png" alt></p>
<p>4．low=3&lt;high=9，执行循环体。<br>到high=6。L.r[6]=40&lt;50，退出循环，交换L.r[low]=L.r[3]=50与L.r[high]=L.r[6]=40的值，使得L.r[3]=40，L.r[6]=50</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/338import.png" alt></p>
<p>5．当low=5。L.r[5]=70&gt;50，退出循环。<br>交换L.r[low]=L.r[5]=70与L.r[high]=L.r[6]=50的值，使得L.r[5]=50，L.r[6]=70</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/339import.png" alt></p>
<p>6．再次循环。因low=5&lt;high=6，执行循环体后，low=high=5，退出循环</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/340import.png" alt></p>
<p>7．最后返回low的值5。函数执行完成。接下来是递归调用“QSort(L,1,5-1);”和“QSort(L,5+1,9);”语句，对{20,10,40,30}和{70,80,60,90}分别进行同样的Partition操作，直到顺序全部正确为止</p>
<h2 id="快速排序复杂度分析"><a href="#快速排序复杂度分析" class="headerlink" title="快速排序复杂度分析"></a>快速排序复杂度分析</h2><p>快速排序的时间性能取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。下图是{50,10,90,30,70,40,80,60,20}在快速排序过程中的递归过程。由于第一个关键字是50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/341import.png" alt></p>
<p>在最优情况下，Partition每次都划分得很均匀，如果排序<script type="math/tex">n</script>个关键字，其递归树的深度为<script type="math/tex">[\log_2n]+1</script>，即仅需递归<script type="math/tex">log_2n</script>次，需要时间为<script type="math/tex">T(n)</script>的话，第一次Partiation需要对整个数组扫描一遍，做<script type="math/tex">n</script>次比较。然后获得的枢轴将数组一分为二，各自还需要<script type="math/tex">T(\frac{n}{2})</script>的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，就有了下面的不等式推断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T(n) ≤ <span class="number">2</span>T(n / <span class="number">2</span>) + n, T(<span class="number">1</span>) = <span class="number">0</span></span><br><span class="line">T(n) ≤ <span class="number">2</span>(<span class="number">2</span>T(n / <span class="number">4</span>) + n / <span class="number">2</span>) + n = <span class="number">4</span>T(n / <span class="number">4</span>)+<span class="number">2</span>n</span><br><span class="line">T(n) ≤ <span class="number">4</span>(<span class="number">2</span>T(n / <span class="number">8</span>) + n / <span class="number">4</span>) + <span class="number">2</span>n = <span class="number">8</span>T(n / <span class="number">8</span>)+<span class="number">3</span>n</span><br><span class="line">……</span><br><span class="line">T(n) ≤ nT(<span class="number">1</span>) + (log2n) × n = O(nlogn)</span><br></pre></td></tr></table></figure>
<p>在最优的情况下，快速排序算法的时间复杂度为<script type="math/tex">O(n\log n)</script></p>
<p>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n-1次递归调用，且第i次划分需要经过n-i次关键字的比较才能找到第i个记录，也就是枢轴的位置，比较次数为<script type="math/tex">\sum_{i=1}^{ n-1} n-i=(n-1)+(n-2)+...+1=\frac{n(n-1)}{2}</script>，最终其时间复杂度为<script type="math/tex">O(n^2)</script></p>
<p>平均的情况，设枢轴的关键字应该在第k的位置（1≤k≤n），那么：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/442import.png" alt></p>
<p>数量级为<script type="math/tex">O(nlogn)</script></p>
<p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为<script type="math/tex">log_2n</script>，其空间复杂度也就为<script type="math/tex">O(logn)</script>，最坏情况，需要进行<script type="math/tex">n-1</script>递归调用，其空间复杂度为<script type="math/tex">O(n)</script>，平均情况，空间复杂度也为<script type="math/tex">O(logn)</script></p>
<p>由于关键字的比较和交换是跳跃进行的，快速排序是一种不稳定的排序方法</p>
<h2 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h2><p>1．<strong>优化选取枢轴。</strong>排序速度的快慢取决于L.r[1]的关键字处在整个序列的位置，L.r[1]太小或者太大，都会影响性能</p>
<p><strong>三数取中（median-of-three）法：</strong>取三个关键字先进行排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。这样至少这个中间数一定不会是最小或者最大的数</p>
<p>取左端、右端和中间三个数的实现代码，在Partition函数增加这样一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pivotkey;</span><br><span class="line"><span class="comment">/* 计算数组中间的元素的下标 */</span></span><br><span class="line"><span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[low] &gt; L-&gt;r[high])</span><br><span class="line"><span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></span><br><span class="line">swap(L, low, high);</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[m] &gt; L-&gt;r[high])</span><br><span class="line"><span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></span><br><span class="line">swap(L, high, m);</span><br><span class="line"><span class="keyword">if</span> (L-&gt;r[m] &lt; L-&gt;r[low])</span><br><span class="line"><span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></span><br><span class="line">swap(L, m, low);</span><br><span class="line"><span class="comment">/* 此时L.r[low]已经为整个序列左中右三个关键字的中间值。 */</span></span><br><span class="line"><span class="comment">/*用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">pivotkey = L-&gt;r[low];</span><br></pre></td></tr></table></figure>
<p>对数组{9,1,5,8,3,7,4,6,2}，取左9、中3、右2来比较，使得L.r[low]=3，一定要比9和2来得更为合理</p>
<p>三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey，但对非常大的待排序的序列不足以保证选择出一个好的pivotkey</p>
<p><strong>九数取中（me-dian-of-nine）：</strong>先从数组中分三次取样，每次取三个数，三个样品各取出中数，然后从这三个中数当中再取出一个中数作为枢轴。更加保证了取到的pivotkey是比较接近中间值的关键字</p>
<p>2．优化不必要的交换</p>
<p>优化Partition函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivotkey;</span><br><span class="line"><span class="comment">/* 这里省略三数取中代码 */</span></span><br><span class="line"><span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></span><br><span class="line">pivotkey = L-&gt;r[low];</span><br><span class="line"><span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></span><br><span class="line">L-&gt;r[<span class="number">0</span>] = pivotkey;</span><br><span class="line"><span class="comment">/* 从表的两端交替向中间扫描 */</span></span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)</span><br><span class="line">high--;</span><br><span class="line"><span class="comment">/* 采用替换而不是交换的方式进行操作 */</span></span><br><span class="line">L-&gt;r[low] = L-&gt;r[high];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class="line">low++;</span><br><span class="line"><span class="comment">/* 采用替换而不是交换的方式进行操作 */</span></span><br><span class="line">L-&gt;r[high] = L-&gt;r[low];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将枢轴数值替换回L.r[low] */</span></span><br><span class="line">L-&gt;r[low] = L-&gt;r[<span class="number">0</span>];</span><br><span class="line"><span class="comment">/* 返回枢轴所在位置 */</span></span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当low与high会合，即找到了枢轴的位置时，再将L.r[0]的数值赋值回L.r[low]</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/349import.png" alt></p>
<p>3．优化小数组时的排序方案</p>
<p>改进QSort函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LENGTH_INSERT_SORT 7 <span class="comment">/* 数组长度阀值 */</span></span></span><br><span class="line"><span class="comment">/* 对顺序表L中的子序列L.r[low..high]作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot;</span><br><span class="line"><span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 当high-low大于常数时用快速排序 */</span></span><br><span class="line"><span class="comment">/* 将L.r[low..high]一分为二， */</span></span><br><span class="line"><span class="comment">/* 并算出枢轴值pivot */</span></span><br><span class="line">pivot = Partition(L, low, high);</span><br><span class="line"><span class="comment">/* 对低子表递归排序 */</span></span><br><span class="line">QSort(L, low, pivot - <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 对高子表递归排序 */</span></span><br><span class="line">QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 当high-low小于等于常数时用直接插入排序 */</span></span><br><span class="line">InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4．优化递归操作</p>
<p>QSort函数在其尾部有两次递归操作。如果待排序的序列划分极端不平衡，递归深度将趋近于n，而不是平衡时的<script type="math/tex">log
_2n</script>，栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。如果能减少递归，将大大提高性能</p>
<p>对QSort实施尾递归优化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表L中的子序列L.r[low..high]作快速排序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot;</span><br><span class="line"><span class="keyword">if</span> ((high - low) &gt; MAX_LENGTH_INSERT_SORT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* L.r[low..high]一分为二, */</span></span><br><span class="line"><span class="comment">/* 算出枢轴值pivot */</span></span><br><span class="line">pivot = Partition1(L, low, high);</span><br><span class="line"><span class="comment">/* 对低子表递归排序 */</span></span><br><span class="line">QSort1(L, low, pivot - <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 尾递归 */</span></span><br><span class="line">low = pivot + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将if改成while，因为第一次递归以后，变量low就没有用处了，所以可以将pivot+1赋值给low，再循环后，来一次Partition(L,low,high)，其效果等同于“QSort(L,pivot+1,high);”。结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深度，从而提高了整体性能</p>
<h1 id="9-9-总结回顾"><a href="#9-9-总结回顾" class="headerlink" title="9.9 总结回顾"></a>9.9 总结回顾</h1><p>排序稳定对于某些特殊需求来说是至关重要的，因此在排序算法中，需要关注此算法的稳定性如何</p>
<p>排序记录是否全部被放置在内存中，将排序分为内排序与外排序两种，外排序需要在内外存之间多次交换数据才能进行</p>
<p>根据排序过程中借助的主要操作，我们将内排序分为：插入排序、交换排序、选择排序和归并排序四类</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/350import.png" alt></p>
<p>7种算法的各种指标对比：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/351import.png" alt></p>
<p>从算法的简单性，将7种算法分为两类：</p>
<ul>
<li>简单算法：冒泡、简单选择、直接插入</li>
<li>改进算法：希尔、堆、归并、快速</li>
</ul>
<p>平均情况：最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法</p>
<p>最好情况：冒泡和直接插入排序要更胜一筹</p>
<p>最坏情况：堆排序与归并排序强过快速排序以及其他简单排序</p>
<p>执行算法的软件所处的环境非常在乎内存使用量的多少时，归并排序和快速排序不是一个较好的决策</p>
<p>非常在乎排序稳定性的应用中，归并排序是个好算法</p>
<p>从待排序记录的个数上来说，待排序的个数n越小，采用简单排序方法越合适。反之，n越大，采用改进排序方法越合适</p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第七章  图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第七章  图/" itemprop="url">大话数据结构 第七章  图</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:47:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:45:50Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第七章  图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第七章  图/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第七章  图/" class="leancloud_visitors" data-flag-title="大话数据结构 第七章  图">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="7-1-图的定义"><a href="#7-1-图的定义" class="headerlink" title="7.1 图的定义"></a>7.1 图的定义</h1><p><strong>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/150import.png" alt></p>
<ul>
<li>线性表中数据元素叫<strong>元素</strong>，树中将数据元素叫<strong>结点</strong>，图中数据元素称之为<strong>顶点（Vertex）</strong></li>
<li>线性表中可以没有数据元素，称为<strong>空表</strong>。树中可以没有结点，叫做<strong>空树</strong>。在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空</li>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的</li>
</ul>
<h2 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h2><p><strong>若顶点</strong><script type="math/tex">v_i</script><strong>到</strong><script type="math/tex">v_j</script><strong>之间的边没有方向，则称这条边为无向边（Edge），用无序偶对</strong>(<script type="math/tex">v_i,v_j</script>)<strong>来表示</strong>。<strong>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/151import.png" alt></p>
<p>由于是无方向的，连接顶点A与D的边，可以表示成无序对(A,D)，也可以写成(D,A)</p>
<p>对于无向图<script type="math/tex">G_1</script>：</p>
<ul>
<li><script type="math/tex; mode=display">G_1=(V_1,\{E_1\})</script></li>
<li>顶点集合<script type="math/tex">V_1=\{A,B,C,D\}</script></li>
<li>边集合<script type="math/tex">E_1=\{(A,B),(B,C),(C,D),(D,A),(A,C)\}</script></li>
</ul>
<p><strong>若从顶点</strong><script type="math/tex">v_i</script><strong>到</strong><script type="math/tex">v_j</script><strong>的边有方向，则称这条边为有向边，也称为弧（Arc）。用有序偶</strong><script type="math/tex"><v_i,v_j></script><strong>来表示，</strong><script type="math/tex">v_i</script><strong>称为弧尾（Tail），</strong><script type="math/tex">v_j</script><strong>称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/152import.png" alt></p>
<p>连接顶点A到D的有向边就是弧，A是弧尾，D是弧头，&lt;A,D&gt;表示弧，不能写成&lt;D,A&gt;</p>
<p>对于有向图<script type="math/tex">G_2</script>：</p>
<ul>
<li><script type="math/tex; mode=display">G_2=(V_2,\{E_2\})</script></li>
<li>顶点集合<script type="math/tex">V_2=\{A,B,C,D\}</script></li>
<li>弧集合<script type="math/tex">E_2=\{<A,D>,<B,A>,<C,A>,<B,C>\}</script></li>
</ul>
<p>无向边用小括号“()”表示，而有向边则是用尖括号“&lt;&gt;”表示</p>
<p><strong>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/154import.png" alt></p>
<blockquote>
<p>两个图就不属于要讨论的范围</p>
</blockquote>
<p><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有n个顶点的无向完全图有<script type="math/tex">\frac{n(n-1)}{2}</script>条边</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/155import.png" alt></p>
<p><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有n个顶点的有向完全图有<script type="math/tex">n\times (n-1)</script>条边</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/157import.png" alt></p>
<p>对于具有n个顶点和e条边数的图，无向图0≤e≤<script type="math/tex">\frac{n(n-1)}{2}</script>，有向图0≤e≤n(n-1)</p>
<p><strong>有很少条边或弧的图称为稀疏图，反之称为稠密图</strong>。稀疏和稠密是模糊的概念，是相对而言的</p>
<p><strong>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网（Network）</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/158import.png" alt></p>
<p><strong>假设有两个图</strong><script type="math/tex">G=(V,\{E\})</script><strong>和</strong><script type="math/tex">G{'}=(V{'},\{E{'}\})</script><strong>，如果</strong><script type="math/tex">V{'}\subseteq V</script><strong>且</strong><script type="math/tex">E{'}\subseteq E</script><strong>，则称</strong><script type="math/tex">G{'}</script><strong>为G的子图（Sub-graph）</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/160import.png" alt></p>
<blockquote>
<p>带底纹的图均为左侧无向图与有向图的子图</p>
</blockquote>
<h2 id="图的顶点与边间关系"><a href="#图的顶点与边间关系" class="headerlink" title="图的顶点与边间关系"></a>图的顶点与边间关系</h2><p>对于无向图G=(V,{E})，如果边(v,v’)∈E，则称顶点v和v’互为邻接点（Adjacent），即v和v’相邻接。边(v,v’)依附（incident）于顶点v和v’，或者说(v,v’)与顶点v和v’相关联。顶点v的度（Degree）是和v相关联的边的数目，记为TD(v)。边数是各顶点度数和的一半，多出的一半是因为重复两次记数,<script type="math/tex">e=\frac{1}{2}\sum_{i=1}^{n}TD\{V_i\}</script></p>
<p>对于有向图G=(V,{E})，如果弧&lt;v,v’&gt;∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v。弧&lt;v,v’&gt;和顶点v，v’相关联。以顶点v为头的弧的数目称为v的<strong>入度（InDegree）</strong>，记为ID(v)；以v为尾的弧的数目称为v的<strong>出度（OutDegree）</strong>，记为OD(v)</p>
<p>顶点v的度为<script type="math/tex">TD(v)=ID(v)+OD(v)</script>,<script type="math/tex">e=\sum_{i=1}^{ n} ID(v_i)=\sum_{i=1}^{n}OD(v_i)</script></p>
<p><strong>路径的长度是路径上的边或弧的数目</strong></p>
<p>无向图G=(V,{E})中从顶点v到顶点v’的路径（Path）是一个顶点序列<script type="math/tex">(v=v_{i,0},v_{i,1},...,v_{i,m}=v{'})</script>，其中<script type="math/tex">(v_{i,j-1},v_{i,j})</script>∈E，1≤j≤m</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/156import.png" alt></p>
<blockquote>
<p>顶点B到顶点D四种不同的路径,上方两条路径长度为2，下方两条路径长度为3</p>
</blockquote>
<p>如果G是有向图，则路径也是有向的，顶点序列应满足<script type="math/tex"><v_{i,j-1},v_{i,j}></script>∈E，1≤j≤m。</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png1" alt></p>
<blockquote>
<p>顶点B到D有两种路径。而顶点A到B，就不存在路径,左侧路径长为2，右侧路径长度为3</p>
</blockquote>
<p><strong>第一个顶点和最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png12" alt></p>
<p>两个图的粗线都构成环，左侧的环因第一个顶点和最后一个顶点都是B，且C、D、A没有重复出现，因此是一个简单环。右侧的环由于顶点C的重复，不是简单环</p>
<h2 id="连通图相关术语"><a href="#连通图相关术语" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h2><p><strong>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点</strong><script type="math/tex">v_i,v_j</script><strong>∈V，</strong><script type="math/tex">v_i</script><strong>和</strong><script type="math/tex">v_j</script><strong>都是连通的，则称G是连通图（Connected Graph）</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png2" alt></p>
<p>图1的顶点A到顶点B、C、D都是连通的，但显然顶点A与顶点E或F就无路径，因此不能算是连通图。图2顶点A、B、C、D相互都是连通的，所以它本身是连通图</p>
<p><strong>无向图中的极大连通子图称为连通分量</strong>。强调：</p>
<ul>
<li>要是子图；</li>
<li>子图要是连通的；</li>
<li>连通子图含有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png3" alt></p>
<p>图1是一个无向非连通图。但有两个连通分量，即图2和图3。而图4，尽管是图1的子图，但是它却不满足连通子图的极大顶点数（图2满足）。因此它不是图1的无向图的连通分量</p>
<p><strong>在有向图G中，如果对于每一对</strong><script type="math/tex">v_i,v_j</script><strong>∈V、</strong><script type="math/tex">v_i</script><strong>≠</strong><script type="math/tex">v_j</script><strong>，从</strong><script type="math/tex">v_i</script><strong>到</strong><script type="math/tex">v_j</script><strong>和从</strong><script type="math/tex">v_j</script><strong>到</strong><script type="math/tex">v_i</script><strong>都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png4" alt></p>
<p>图1不是强连通图，因为顶点A到顶点D存在路径，而D到A就不存在。图2是强连通图，而且图2是图1的<strong>极大强连通子图</strong>，即是它的<strong>强连通分量</strong></p>
<p><strong>连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</strong>。</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png6" alt></p>
<p>图1是一普通图，但显然不是生成树，当去掉两条构成环的边后，比如图2或图3，就满足n个顶点n-1条边且连通的定义。它们都是一棵生成树。</p>
<p>如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1边条，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。比如图2和图3，随便加哪两顶点的边都将构成环。</p>
<p>不过有n-1条边并不一定是生成树，比如图4</p>
<p><strong>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一个有向树</strong>。入度为0相当于树中的根结点，其余顶点入度为1是说树的非根结点的双亲只有一个。<strong>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧</strong>。</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png5" alt></p>
<p>图1是一个有向图。去掉一些弧后，可以分解为两棵有向树，如图2和图3，这两棵就是图1有向图的生成森林</p>
<h2 id="图的定义与术语总结"><a href="#图的定义与术语总结" class="headerlink" title="图的定义与术语总结"></a>图的定义与术语总结</h2><p>图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分</p>
<p>图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图</p>
<p>图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度</p>
<p>图上的边或弧上带权则称为网</p>
<p>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大，连通则就是连通分量，有向的则称强连通分量</p>
<p>无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林</p>
<h1 id="7-2-图的抽象数据类型"><a href="#7-2-图的抽象数据类型" class="headerlink" title="7.2 图的抽象数据类型"></a>7.2 图的抽象数据类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ADT 图(Graph)</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line"></span><br><span class="line">顶点的有穷非空集合和边的集合</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line"></span><br><span class="line">CreateGraph(*G,V,VR):按照顶点集合V和边弧集VR的定义构造图G。</span><br><span class="line"></span><br><span class="line">DestroyGraph(*G):图G存在则销毁。</span><br><span class="line"></span><br><span class="line">LocateVex(G,u):若图G中存在顶点u，则返回图中的位置。</span><br><span class="line"></span><br><span class="line">GetVex(G,v):返回图G中顶点v的值。</span><br><span class="line"></span><br><span class="line">PutVex(G,v,value):将图G中顶点v赋值value。</span><br><span class="line"></span><br><span class="line">FirstAdjvex(G,*v):返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。</span><br><span class="line"></span><br><span class="line">NextAdjVex(G,v,*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回“空”。  </span><br><span class="line"></span><br><span class="line">InsertVex(*G,v):在图G中增添新顶点v.</span><br><span class="line"></span><br><span class="line">DeleteVex(*G,v):删除图G中顶点v及其相关的弧。</span><br><span class="line"></span><br><span class="line">InsertArc(*G,v,w):在图G中增添弧&lt;v,w&gt;,若G是无向图，还需要增添对称弧&lt;w,v&gt;。</span><br><span class="line"></span><br><span class="line">DeleteArc(*G,v,w):在图G中删除弧&lt;v,w&gt;，若G是无向图，则还删除对称弧&lt;w,v&gt;。</span><br><span class="line"></span><br><span class="line">DESTraverse(G):对图G中进行深度优先遍历，在遍历过程中对每个顶点调用。</span><br><span class="line"></span><br><span class="line">HFSTraverse(G):对图G中进行广度优先遍历，在遍历过程中对每个顶点调用。</span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h1 id="7-3-图的存储结构"><a href="#7-3-图的存储结构" class="headerlink" title="7.3 图的存储结构"></a>7.3 图的存储结构</h1><p>从图的逻辑结构定义来看，图上任何一个顶点都可被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关系</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png7" alt></p>
<blockquote>
<p>同一个图，顶点位置不同</p>
</blockquote>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><strong>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息</strong></p>
<p>设图G有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png8" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png0" alt></p>
<p>顶点数组为<script type="math/tex">vertex[4]=\{v_0,v_1,v_2,v_3\}</script>，边数组arc[4][4]为右图这样的一个矩阵。矩阵的主对角线的值，即arc[0][0]、arc[1][1]、arc[2][2]、arc[3][3]全为0是因为不存在顶点到自身的边，无向图的边数组是一个对称矩阵。<strong>对称矩阵就是n阶矩阵的元满足</strong><script type="math/tex">a_{ij}=a_{ji}</script><strong>，（0≤i,j≤n）。即从矩阵的左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元全都是相等的</strong></p>
<p>有了这个矩阵，很容易知道图中的信息：</p>
<ol>
<li>判定任意两顶点是否有边无边</li>
<li>要知道某个顶点的度，就是这个顶点<script type="math/tex">v_i</script>在邻接矩阵中第i行（或第i列）的元素之和。</li>
<li>求顶点<script type="math/tex">v_i</script>的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.pngq" alt></p>
<p>顶点数组为<script type="math/tex">vertex[4]=\{v_0,v_1,v_2,v_3\}</script>，弧数组arc[4][4]为右图的一个矩阵。主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称</p>
<p>有向图讲究入度与出度，顶点<script type="math/tex">v_1</script>的入度为1，正好是第<script type="math/tex">v_1</script>列各数之和。顶点<script type="math/tex">v_1</script>的出度为2，即第<script type="math/tex">v_1</script>行的各数之和</p>
<p>判断顶点<script type="math/tex">v_i</script>到<script type="math/tex">v_j</script>是否存在弧，只需要查找矩阵中arc[i][j]是否为1。求<script type="math/tex">v_i</script>的所有邻接点就是将矩阵第i行元素扫描一遍，查找arc[i][j]为1的顶点</p>
<p>设图G是网图，有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：</p>
<script type="math/tex; mode=display">
arc[i][j]]=\left\{\begin{matrix}
W_{ij}&if\quad (v_i,v_j) \in E \quad or\quad <v_i,v_j>\in E \\
0 &if\quad i=j \\
\infty &other
\end{matrix}\right.</script><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png13" alt></p>
<p>$w_{ij}$表示<script type="math/tex">(v_i,v_j)</script>或<script type="math/tex"><v_i,v_j></script>上的权值。∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值</p>
<p>图的邻接矩阵存储结构的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">//顶点类型，由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType; <span class="comment">//边上的权值类型，由用户定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 100 <span class="comment">//最大顶点数，应由用户定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535 <span class="comment">//用65535来代表∞</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType vexs[MAXVEX]; <span class="comment">//顶点表</span></span><br><span class="line">EdgeType arc[MAXVEX][MAXVEX]; <span class="comment">//邻接矩阵，可看作边表</span></span><br><span class="line"><span class="keyword">int</span> numVertexes,numEdges; <span class="comment">//图中当前的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<p>有了以上的结构定义，构造一个图就是给顶点表和边表输入数据的过程。</p>
<p>无向网图的创建代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateMGraph</span><span class="params">(MGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,w;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入顶点数和边数：\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);<span class="comment">//输入顶点数和边数</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexes;i++)</span><br><span class="line"><span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexes;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;numVertexes;j++)</span><br><span class="line">G-&gt;arc[i][j] = INFINITY;<span class="comment">//邻接矩阵初始化</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++) <span class="comment">//读入numEdges条边，建立邻接矩阵</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入边(vi,vj)上的下标i,下标j和权w:\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%d,%d"</span>,&amp;i,&amp;j,&amp;w); <span class="comment">//输入边(vi,vj)上的权w</span></span><br><span class="line">G-&gt;arc[i][j] = w;</span><br><span class="line">G-&gt;arc[j][i] = G-&gt;arc[i][j];<span class="comment">//因为是无向图，矩阵对称。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为<script type="math/tex">O(n+n^2+e)</script>,其中对邻接矩阵G-&gt;arc的初始化耗费了<script type="math/tex">O(n^2)</script>的时间</p>
<p>邻接矩阵对于边数相对顶点较少的图来说对存储空间是极大的浪费</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><strong>数组与链表相结合的存储方法称为邻接表(Adjacency List)</strong></p>
<p>邻接表的处理办法：</p>
<ol>
<li>图中顶点用一个一维数组存储，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息</li>
<li>图中每个顶点<script type="math/tex">v_i</script>的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点<script type="math/tex">v_i</script>的边表，有向图则称为顶点<script type="math/tex">v_i</script>作为弧尾的出边表</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png15" alt></p>
<p>顶点表的各个结点由data 和 firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此结点的第一个邻接点</p>
<p>边表结点由adjvex和next 两个域组成，adjvex 是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针</p>
<p>要想知道某个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点<script type="math/tex">v_i</script>到<script type="math/tex">v_j</script>是否存在边，只需要测试顶点<script type="math/tex">v_i</script>的边表中adjvex是否存在结点<script type="math/tex">v_j</script>的下标j就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到的adjvex域对应的顶点就是邻接点</p>
<p>若是有向图，第一幅图的邻接表就是第二幅图。有向图由于有方向，是以顶点为弧尾来存储边表的，很容易得到每个顶点的出度。有时为了便于确定顶点的入度或以顶点为弧头的弧，可以建立一个有向图的逆邻接表，即对每个顶点<script type="math/tex">v_i</script>都建立一个链接为<script type="math/tex">v_i</script>为弧头的表</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png16" alt></p>
<p>对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域存储权值信息</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png17" alt></p>
<p>结点定义的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">//顶点类型，由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> //边表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex; <span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line">EdgeType weight; <span class="comment">//用于存储权值，对于非网图可以不需要</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span><span class="comment">//链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> //顶点表结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VertexType data; <span class="comment">//顶点域，存储顶点信息</span></span><br><span class="line">EdgeNode *firstedge; <span class="comment">//边表头指针</span></span><br><span class="line">&#125;VertexNode,AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">AdjList adjList;</span><br><span class="line"><span class="keyword">int</span> numVertexes,numEdges; <span class="comment">//图中当前顶点数和边数</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure>
<p>无向图的邻接表创建代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 建立图的邻接表结构 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(GraphAdjList *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">EdgeNode *e;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入顶点数和边数：\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);<span class="comment">//输入顶点数和边数</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numVertexes,i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(&amp;G-&gt;adjList[i].data);<span class="comment">//输入顶点信息</span></span><br><span class="line">G-&gt;adjList[i].firstedge=<span class="literal">NULL</span>;<span class="comment">//将边表置位空表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G-&gt;numEdges;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入边(vi,vj)上的顶点序号：\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>,&amp;i,&amp;j);<span class="comment">//输入边(vi,vj)上的顶点序号</span></span><br><span class="line">e=(EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">/*向内存申请空间，生成边表结点*/</span></span><br><span class="line">e-&gt;adjvex = j;<span class="comment">//邻接序号为j</span></span><br><span class="line">e-&gt;next = G-&gt;adjList[i].firstedge;<span class="comment">//将e指针指向当前顶点指向的结点</span></span><br><span class="line">G-&gt;adjList[i].firstedge = e;<span class="comment">//将当前顶点的指针指向e</span></span><br><span class="line"></span><br><span class="line">e=(EdgeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">/*向内存申请空间，生成边表结点*/</span></span><br><span class="line"></span><br><span class="line">e-&gt;adjvex = i;<span class="comment">//邻接序号为i</span></span><br><span class="line">e-&gt;next=G-adjList[j].firstedge;<span class="comment">//将e指针指向当前顶点指向的结点</span></span><br><span class="line">G-&gt;adjList[j].firstedge = e;<span class="comment">//将当前顶点的指针指向e</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对i和j分别进行了插入。本算法的时间复杂度，对于n个顶点e条边来说是<script type="math/tex">O(n+e)</script></p>
<p>邻接表的缺陷：</p>
<ul>
<li>关心了出度问题，想了解入度就必须要遍历整个图才能知道</li>
<li>逆邻接表解决了入度却不了解出度的情况</li>
</ul>
<h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p><strong>十字链表（Orthogonal List）：把邻接表和逆邻接表结合起来的存储方式</strong></p>
<p>重新定义顶点表结点结构如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">data</th>
<th style="text-align:center">firstin</th>
<th style="text-align:center">firstout</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示出边表头指针，指向该顶点的出边表中的第一个结点</p>
</blockquote>
<p>重新定义的边表结点结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">tailvex</th>
<th style="text-align:center">headvex</th>
<th style="text-align:center">headlink</th>
<th style="text-align:center">taillink</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>顶点依然是存入一个一维数组<script type="math/tex">{v_0,v_1,v_2,v_3}</script>，实线箭头指针的图示邻接表相同。以顶点<script type="math/tex">v_0</script>来说，firstout指向的是出边表中的第一个结点<script type="math/tex">v_3</script>。所以<script type="math/tex">v_0</script>边表结点的headvex=3，而tailvex其实就是当前顶点<script type="math/tex">v_0</script>的下标0，由于<script type="math/tex">v_0</script>只有一个出边顶点，所以headlink和taillink都是空</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png20" alt></p>
<p>虚线箭头的含义此图的逆邻接表的表示。<script type="math/tex">v_0</script>有两个顶点<script type="math/tex">v_1</script>和<script type="math/tex">v_2</script>的入边。因此<script type="math/tex">v_0</script>的firstin指向顶点<script type="math/tex">v_1</script>的边表结点中headvex为0的结点，如图中的①。接着由入边结点的headlink指向下一个入边顶点<script type="math/tex">v_2</script>，如图中的②。对于顶点<script type="math/tex">v_1</script>，它有一个入边顶点<script type="math/tex">v_2</script>，所以它的firstin指向顶点<script type="math/tex">v_2</script>的边表结点中headvex为1的结点，如图中的③。顶点<script type="math/tex">v_2</script>和<script type="math/tex">v_3</script>也是同样有一个入边顶点，如图中④和⑤</p>
<p>十字链表的好处：</p>
<ul>
<li>把邻接表和逆邻接表整合在了一起，容易找到以<script type="math/tex">v_i</script>为尾的弧和以<script type="math/tex">v_i</script>为头的弧，容易求得顶点的出度和入度</li>
<li>除了结构复杂一点外，创建图算法的时间复杂度和邻接表相同的</li>
</ul>
<h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><p>重新定义的边表结点结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ivex</th>
<th style="text-align:center">ilink</th>
<th style="text-align:center">jvex</th>
<th style="text-align:center">jlink</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>ivex和jvex是与某条边依附的两个顶点在顶点表中的下标。ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。这就是邻接多重表结构</p>
</blockquote>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png21" alt></p>
<p>首先连线的①②③④就是将顶点的firstedge指向一条边，顶点下标要与ivex的值相同，接着，由于顶点<script type="math/tex">v_0</script>的<script type="math/tex">(v_0,v_1)</script>边的邻边有<script type="math/tex">(v_0,v_3)</script>和<script type="math/tex">(v_0,v_2)</script>。因此⑤⑥的连线就是满足指向下一条依附于顶点<script type="math/tex">v_0</script>的边的目标，ilink指向的结点的jvex一定要和它本身的ivex的值相同。连线⑦就是指<script type="math/tex">(v_1,v_0)</script>这条边，相当于顶点<script type="math/tex">v_1</script>指向<script type="math/tex">(v_1,v_2)</script>边后的下一条。<script type="math/tex">v_2</script>有三条边依附，所以在③之后就有了⑧⑨。连线⑩的就是顶点<script type="math/tex">v_3</script>在连线④之后的下一条边。左图一共有5条边，所以右图有10条连线</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/212import.png" alt></p>
<p>邻接多重表和邻接表的区别：同一条边在邻接表中用两个结点表示，在邻接多重表中只有一个结点。若要删除左图的<script type="math/tex">(v_0,v_2)</script>这条边，只需要将右图的⑥⑨的链接指向改为∧即可</p>
<h2 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h2><p><strong>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成</strong></p>
<p>定义的边数组结构如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">begin</th>
<th style="text-align:left">end</th>
<th style="text-align:left">weight</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>begin是存储起点下标，end是存储终点下标，weight是存储权值</p>
</blockquote>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png23" alt></p>
<p>边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作</p>
<h1 id="7-4-图的遍历"><a href="#7-4-图的遍历" class="headerlink" title="7.4 图的遍历"></a>7.4 图的遍历</h1><p><strong>从图中的某一顶点出发，访遍图中其余顶点，且使每一顶点仅被访问一次，这一过程就叫做图的遍历(Traversing Graph)</strong></p>
<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p><strong>深度优先遍历(Depth First Search)，也有称为深度优先搜索，简称为DFS。</strong>类似于树的前序遍历</p>
<p>从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到，以上说的只是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直至图中所有顶点都被访问到位置</p>
<p>访问数组visited[n]，n是图中顶点的个数，初值为0，访问过后设置为1</p>
<p>用邻接矩阵的方式来遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Boolean;<span class="comment">//Boolean 是布尔类型，其值是TRUE或FALSE</span></span><br><span class="line">Boolean visited[MAX];<span class="comment">//访问标志的数组</span></span><br><span class="line"><span class="comment">/* 邻接矩阵的深度优先递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">visited[i]=TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vexs[i]);<span class="comment">//打印顶点，也可以其他操作</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)</span><br><span class="line"><span class="keyword">if</span>(G.arc[i][j]==<span class="number">1</span>&amp;&amp;!visited[j])</span><br><span class="line">DFS(G,j); <span class="comment">//对为访问的邻接顶点递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++)</span><br><span class="line">visited[i] = FALSE; <span class="comment">/* 初始所有顶点状态都是未访问过状态 */</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numVertexes;i++)</span><br><span class="line"><span class="keyword">if</span>(!visited[i]) <span class="comment">/* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */</span></span><br><span class="line">DFS(G,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果图结构为邻接表结构，其DFSTraverse函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接表的深度优先递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(GraphAdjList GL,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode *p;</span><br><span class="line">visited[i] = TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,GL-&gt;adjList[i].data);<span class="comment">//打印顶点，也可以其他操作</span></span><br><span class="line">p = GL-&gt;adjList[i].firstedge;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[p-&gt;adjvex]) <span class="comment">/* 对未访问的邻接顶点递归调用 */</span></span><br><span class="line">DFS(GL,p-&gt;adjvex);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表的深度遍历操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">visited[i] = FALSE;<span class="comment">//初始所有顶点状态都是未访问过状态</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line"><span class="keyword">if</span>(!visited[i])<span class="comment">//对未访问过的顶点调用DFS，若是连通图，只会执行一次</span></span><br><span class="line">DFS(GL,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此需要<script type="math/tex">O(n^2)</script>的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是<script type="math/tex">O(n+e)</script>。对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高</p>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p><strong>广度优先遍历(Breadth_First_Search)，又称为广度优先搜索，简称为BFS</strong>。类似于树的层序遍历。</p>
<p>将第一幅图稍微变形，变形原则是顶点A放置在最上第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E为第三层，再将这四个顶点有边的D、H放在第四层</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png24" alt></p>
<p>邻接矩阵的广度优先遍历算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">Queue Q;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.numVertexes;i++)</span><br><span class="line">visited[i] = FALSE;</span><br><span class="line">InitQueue(&amp;Q);<span class="comment">//初始化一辅助用的队列</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++) <span class="comment">//对每一个顶点做循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])<span class="comment">//若是未访问过</span></span><br><span class="line">&#123;</span><br><span class="line">visited[i] = TRUE;<span class="comment">//设置当前顶点访问过</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vexs[i]);<span class="comment">//打印顶点，也可以其他操作</span></span><br><span class="line">EnQueue(&amp;Q,i);<span class="comment">//将此顶点如队列</span></span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(Q))<span class="comment">//若当前队列不为空</span></span><br><span class="line">&#123;</span><br><span class="line">DeQueue(&amp;Q,&amp;i);<span class="comment">//将队列中元素出队列，赋值给i</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断其他顶点若与当前顶点存在边且未访问过</span></span><br><span class="line"><span class="keyword">if</span>(G.arc[i][j]==<span class="number">1</span>&amp;&amp;!visited[j])</span><br><span class="line">&#123;</span><br><span class="line">visited[j] = TRUE;<span class="comment">//将找到的此顶点标记为已访问过</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,G.vexs[j]);<span class="comment">//打印顶点</span></span><br><span class="line">EnQueue(&amp;Q,j);<span class="comment">//将找到的此顶点入队列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邻接表的广度优先遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*邻接表的广度遍历算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">EdgeNode *p;</span><br><span class="line">Queue Q;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">visited = FALSE;</span><br><span class="line">InitQueue(&amp;Q);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])</span><br><span class="line">&#123;</span><br><span class="line">visited[i]=TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,GL-&gt;adjList[i].data);<span class="comment">//打印顶点，也可以其他操作</span></span><br><span class="line">EnQueue(&amp;Q,i);</span><br><span class="line"><span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line">DeQueue(&amp;Q,&amp;i);</span><br><span class="line">p = GL-&gt;adjList[i].firstedge;<span class="comment">//找到当前顶点边表链表头指针</span></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[p-&gt;adjvex)<span class="comment">//若此顶点未被访问</span></span><br><span class="line">&#123;</span><br><span class="line">visited[p-&gt;adjvex] = TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,GL-&gt;adjList[p-&gt;adjvex].data);</span><br><span class="line">EnQueue(&amp;Q,p-&gt;adjvex);<span class="comment">//将此顶点如队列</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;<span class="comment">//指针指向下一个邻接点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图的深度优先遍历和广度优先遍历算法在时间复杂度上一样，不同之处仅在于对顶点的访问次序不同深度优先算法更适合目标比较明确的。以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况</p>
<h1 id="7-5-最小生成树"><a href="#7-5-最小生成树" class="headerlink" title="7.5 最小生成树"></a>7.5 最小生成树</h1><p><strong>最小成本，就是n个顶点，用n-1条边把一个连通图连接起来，并且使得权值的和最小</strong></p>
<p><strong>最小生成树：构造连通网的最小代价生成树</strong></p>
<h2 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png25" alt></p>
<blockquote>
<p>存储结构为MGragh的G有9个顶点，用65535来代表∞</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Prim</span><span class="params">(MGraph MG)</span> <span class="comment">/* Prim算法生成最小生成树 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min, i, j, k;</span><br><span class="line"><span class="keyword">int</span> adjvex[MAXVEX];<span class="comment">/* 保存相关顶点下标 */</span></span><br><span class="line"><span class="keyword">int</span> lowcost[MAXVEX];<span class="comment">/* 保存相关顶点间边的权值 */</span></span><br><span class="line">lowcost[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">/* 初始化第一个权值为0，即v0加入生成树,lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */</span></span><br><span class="line">adjvex[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">/* 初始化第一个顶点下标为0 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MG.numVertexes; i++) <span class="comment">/* 循环除下标为0外的全部顶点 */</span></span><br><span class="line">&#123;</span><br><span class="line">lowcost[i] = MG.arc[<span class="number">0</span>][i];<span class="comment">/* 将v0顶点与之有边的权值存入数组 */</span></span><br><span class="line">adjvex[i] = <span class="number">0</span>;<span class="comment">/* 初始化都为v0的下标 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MG.numVertexes; i++)</span><br><span class="line">&#123;</span><br><span class="line">min = INFINITY; <span class="comment">/* 初始化最小权值为∞ */</span></span><br><span class="line">j = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; MG.numVertexes)<span class="comment">/* 循环全部顶点 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min)</span><br><span class="line">&#123; <span class="comment">/* 如果权值不为0且权值小于min */</span></span><br><span class="line">min = lowcost[j];<span class="comment">/* 则让当前权值成为最小值 */</span></span><br><span class="line">k = j;<span class="comment">/* 将当前最小值的下标存入k */</span></span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d,%d)"</span>, adjvex[k], k); <span class="comment">/* 打印当前顶点边中权值最小的边 */</span></span><br><span class="line">lowcost[k] = <span class="number">0</span>;<span class="comment">/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; MG.numVertexes; j++)<span class="comment">/* 循环所有顶点 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; MG.arc[k][j] &lt; lowcost[j])</span><br><span class="line">&#123; <span class="comment">/* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */</span></span><br><span class="line">lowcost[j] = MG.arc[k][j];<span class="comment">/* 将较小的权值存入lowcost相应位置 */</span></span><br><span class="line">adjvex[j] = k;<span class="comment">/* 将下标为k的顶点存入adjvex */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始运行，第4～5行，创建了两个一维数组lowcost和adjvex，长度都为顶点个数9</li>
<li>第6～7行分别给这两个数组的第一个下标位赋值为0，adjvex[0]=0意思是从顶点<script type="math/tex">v_0</script>开始，lowcost[0]=0就表示<script type="math/tex">v_0</script>已经被纳入到最小生成树中，之后凡是lowcost数组中的值被设置为0就是表示此下标的顶点被纳入最小生成树。</li>
<li>第8～12行表示读取右图邻接矩阵的第一行数据。将数值赋值给lowcost数组，此时lowcost数组值为{0,10,65535,65535,65535,11,65535,65535,65535}，而adjvex则全部为0。此时已经完成了整个初始化的工作，准备开始生成</li>
<li>第13～36行，整个循环过程就是构造最小生成树的过程</li>
<li>第15～16行，将min设置为了一个极大值65535，目的是为了之后找到一定范围内的最小权值。j是用来做顶点下标循环的变量，k是用来存储最小权值的顶点下标</li>
<li>第17～25行，循环中不断修改min为当前lowcost数组中最小值，并用k保留此最小值的顶点下标。经过循环后，min=10，k=1。19行if判断的lowcost[j]!=0表示已经是生成树的顶点不参与最小权值的查找</li>
<li>第26行，因k=1，adjvex[1]=0，所以打印结果为(0,1)，表示<script type="math/tex">v_0</script>至<script type="math/tex">v_1</script>边为最小生成树的第一条边<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png26" alt></li>
<li>第27行，此时因k=1将lowcost[k]=0就是说顶点<script type="math/tex">v_1</script>纳入到最小生成树中。此时lowcost数组值为{0,0,65535,65535,65535,11,65535,65535,65535}。</li>
<li>第28～35行，j循环由1至8，因k=1，查找邻接矩阵的第<script type="math/tex">v_1</script>行的各个权值，与low-cost的对应值比较，若更小则修改low-cost值，并将k值存入adjvex数组中。因第<script type="math/tex">v_1</script>行有18、16、12均比65535小，所以最终lowcost数组的值为：{0,0,18,65535,65535,11,16,65535,12}。adjvex数组的值为：{0,0,1,0,0,0,1,0,1}。第30行if判断的lowcost[j]!=0也说明<script type="math/tex">v_0</script>和<script type="math/tex">v_1</script>已经是生成树的顶点不参与最小权值的比对</li>
<li>再次循环，由第15行到第26行，此时min=11，k=5，adjvex[5]=0。打印结构为(0,5)。表示<script type="math/tex">v_0</script>至<script type="math/tex">v_5</script>边为最小生成树的第二条边<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png29" alt></li>
<li>接下来执行到36行，lowcost数组的值为：{0,0,18,65535,26,0,16,65535,12}。ad-jvex数组的值为：{0,0,1,0,5,0,1,0,1}。</li>
<li>之后通过不断的转换，构造的过程如图1～图6<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png30" alt></li>
</ol>
<hr>
<p>普里姆（Prim）算法的实现定义：</p>
<p><strong>假设N=(V,{E})是连通网，TE是N上最小生成树中边的集合。算法从U={</strong><script type="math/tex">u_0</script><strong>}(</strong><script type="math/tex">u_0</script><strong>∈V)，TE={}开始。重复执行下述操作：在所有u∈U,v∈V-U的边(u,v)∈E中找一条代价最小的边(</strong><script type="math/tex">u_0,v_0</script><strong>)并入集合TE，同时</strong><script type="math/tex">v_0</script><strong>并入U，直至U=V为止。此时TE中必有n-1条边，则T=(V,{TE})为N的最小生成树</strong></p>
<p>由算法代码中的循环嵌套可得知此算法的时间复杂度为<script type="math/tex">O(n^2)</script></p>
<h2 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h2><p>edge边集数组结构的定义代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对边集数组Edge结构的定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> begin;</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125; Edge;</span><br></pre></td></tr></table></figure>
<p>将邻接矩阵通过程序转化为右图的边集数组，并且对它们按权值从小到大排序</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png31" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_Kruskal</span><span class="params">(MGraph G)</span> <span class="comment">// Kruskal算法生成最小生成树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, n, m;</span><br><span class="line">Edge edges[MAGEDGE]; <span class="comment">// 定义边集数组</span></span><br><span class="line"><span class="keyword">int</span> parent[MAXVEX]; <span class="comment">// 定义parent数组用来判断边与边是否形成环路</span></span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; G.numVertexes; i++ )</span><br><span class="line">parent[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; G.numEdges; i++ )</span><br><span class="line">&#123;</span><br><span class="line">n = Find(parent, edges[i].begin); <span class="comment">// 4 2 0 1 5 3 8 6 6 6 7</span></span><br><span class="line">m = Find(parent, edges[i].end); <span class="comment">// 7 8 1 5 8 7 6 6 6 7 7</span></span><br><span class="line"><span class="keyword">if</span>( n != m ) <span class="comment">// 如果n==m，则形成环路，不满足！</span></span><br><span class="line">&#123;</span><br><span class="line">parent[n] = m; <span class="comment">// 将此边的结尾顶点放入下标为起点的parent数组中，表示此顶点已经在生成树集合中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(%d, %d) %d "</span>, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> *parent, <span class="keyword">int</span> f)</span> <span class="comment">//查找连线顶点的尾部小标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>( parent[f] &gt; <span class="number">0</span> )</span><br><span class="line">f = parent[f];</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始运行，第5行之后，省略掉颇占篇幅但却很容易实现的将邻接矩阵转换为边集数组，并按权值从小到大排序的代码，也就是说，在第5行开始，已经有了结构为edge，数据内容是上图右图的一维数组edges。</li>
<li>第5～7行，声明一个数组parent，并将它的值都初始化为0</li>
<li>第8～17行，开始对边集数组做循环遍历，开始时，i=0。</li>
<li>第10行，调用了第19～25行的函数Find，传入的参数是数组parent和当前权值最小边(<script type="math/tex">v_4,v_7</script>)的begin:4。因为parent中全都是0所以传出值使得n=4。</li>
<li>第11行，传入(<script type="math/tex">v_4,v_7</script>)的end:7。传出值使得m=7。</li>
<li>第12～16行，n与m不相等，因此parent[4]=7。此时parent数组值为{0,0,0,0,7,0,0,0,0}，并且打印得到“(4,7)7”。此时已经将边(<script type="math/tex">v_4,v_7</script>)纳入到最小生成树中<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png322" alt></li>
<li>循环返回，执行10～16行，此时i=1，edge[1]得到边(<script type="math/tex">v_2,v_8</script>)，n=2，m=8，parent[2]=8，打印结果为“(2,8)8”，此时parent数组值为{0,0,8,0,7,0,0,0,0}，这也就表示边(<script type="math/tex">v_4,v_7</script>)和边(<script type="math/tex">v_2,v_8</script>)已经纳入到最小生成树<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png33" alt></li>
<li>再次执行10～16行，此时i=2，edge[2]得到边(<script type="math/tex">v_0,v_1</script>)，n=0，m=1，parent[0]=1，打印结果为“(0,1)10”，此时parent数组值为{1,0,8,0,7,0,0,0,0}，此时边(<script type="math/tex">v_4,v_7</script>)、(<script type="math/tex">v_2,v_8</script>)和(<script type="math/tex">v_0,v_1</script>)已经纳入到最小生成树<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png34" alt></li>
<li>当i=3、4、5、6时，分别将边<script type="math/tex">(v_0,v_5),(v_1,v_8),(v_3,v_7),(v_1,v_6)</script>纳入到最小生成树中。此时parent数组值为{1,5,8,7,7,8,0,0,6}<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png41" alt></li>
<li>从图i=6的粗线连线可以得到，有两个连通的边集合A与B中纳入到最小生成树中的。当parent[0]=1，表示<script type="math/tex">v_0</script>和<script type="math/tex">v_1</script>已经在生成树的边集合A中。此时将parent[0]=1的1改为下标，由parent[1]=5，表示<script type="math/tex">v_1</script>和<script type="math/tex">v_5</script>在边集合A中，parent[5]=8表示<script type="math/tex">v_5</script>与<script type="math/tex">v_8</script>在边集合A中，parent[8]=6表示<script type="math/tex">v_8</script>与<script type="math/tex">v_6</script>在边集合A中，parent[6]=0表示集合A暂时到头，此时边集合A有<script type="math/tex">v_0,v_1,v_5,v_8,v_6</script>。查看parent中没有查看的值，parent[2]=8表示<script type="math/tex">v_2</script>与<script type="math/tex">v_8</script>在一个集合中，因此<script type="math/tex">v_2</script>也在边集合A中。再由parent[3]=7、parent[4]=7和parent[7]=0可知<script type="math/tex">v_3,v_4,v_7</script>在另一个边集合B中。<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png44" alt></li>
<li>当i=7时，第10行，调用Find函数，会传入参数edges[7].begin=5。此时第21行，parent[5]=8&gt;0，所以f=8，再循环得parent[8]=6。因parent[6]=0所以Find返回后第10行得到n=6。而此时第11行，传入参数edges[7].end=6得到m=6。此时n=m，不再打印，继续下一循环。因为边<script type="math/tex">(v_5,v_6)</script>使得边集合A形成了环路。因此不能将它纳入到最小生成树中，如上图所示。</li>
<li>当i=8时，与上面相同，由于边<script type="math/tex">(v_1,v_2)</script>使得边集合A形成了环路。因此不能将它纳入到最小生成树中，如上图所示。</li>
<li>当i=9时，边<script type="math/tex">(v_6,v_7)</script>，第10行得到n=6，第11行得到m=7，因此parent[6]=7，打印“(6,7)19”。此时parent数组值为{1,5,8,7,7,8,7,0,6}。此后边的循环均造成环路，最终最小生成树即下图所示、<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png45" alt></li>
</ol>
<p>克鲁斯卡尔（Kruskal）算法的实现定义：</p>
<p>假设N=(V,{E})是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止</p>
<p>此算法的Find函数由边数e决定，时间复杂度为<script type="math/tex">O(loge)</script>，而外面有一个for循环e次。所以克鲁斯卡尔算法的时间复杂度为<script type="math/tex">O(eloge)</script></p>
<p>克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，对于稀疏图有很大的优势；普里姆算法对于稠密图，即边数非常多的情况会更好一些</p>
<h1 id="7-6-最短路径"><a href="#7-6-最短路径" class="headerlink" title="7.6 最短路径"></a>7.6 最短路径</h1><p>非网图的最短路径，是指两顶点之间经过的边数最少的路径；网图的最短路径是指两顶点之间经过的边上权值之和最少的路径，并且称路径上的第一个顶点是源点，最后一个顶点是终点。就地图来说，距离就是两顶点间的权值之和。非网图可以理解为所有的边的权值都为1的网</p>
<h2 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535 <span class="comment">// 是 2^16 ，而不是 2^32，因为这样可以防止溢出</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Patharc[MAXVEX]; <span class="comment">// 用于存储最短路径下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX]; <span class="comment">// 用于存储到各点最短路径的权值和</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Dijkstar</span><span class="params">(MGraph G, <span class="keyword">int</span> V0, Patharc *P, ShortPathTable *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v, w, k, min;</span><br><span class="line"><span class="keyword">int</span> final[MAXVEX]; <span class="comment">// final[w] = 1 表示已经求得顶点V0到Vw的最短路径</span></span><br><span class="line"><span class="keyword">for</span>( v=<span class="number">0</span>; v &lt; G.numVertexes; v++ ) <span class="comment">// 初始化数据</span></span><br><span class="line">&#123;</span><br><span class="line">final[v] = <span class="number">0</span>; <span class="comment">// 全部顶点初始化为未找到最短路径</span></span><br><span class="line">(*D)[V] = G.arc[V0][v]; <span class="comment">// 将与V0点有连线的顶点加上权值</span></span><br><span class="line">(*P)[V] = <span class="number">0</span>; <span class="comment">// 初始化路径数组P为0</span></span><br><span class="line">&#125;</span><br><span class="line">(*D)[V0] = <span class="number">0</span>; <span class="comment">// V0至V0的路径为0</span></span><br><span class="line">final[V0] = <span class="number">1</span>; <span class="comment">// V0至V0不需要求路径</span></span><br><span class="line"><span class="keyword">for</span>( v=<span class="number">1</span>; v &lt; G.numVertexes; v++ ) <span class="comment">// 开始主循环，每次求得V0到某个V顶点的最短路径</span></span><br><span class="line">&#123;</span><br><span class="line">min = INFINITY;</span><br><span class="line"><span class="keyword">for</span>( w=<span class="number">0</span>; w &lt; G.numVertexes; w++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !final[w] &amp;&amp; (*D)[w]&lt;min )</span><br><span class="line">&#123;</span><br><span class="line">k = w;</span><br><span class="line">min = (*D)[w];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">final[k] = <span class="number">1</span>; <span class="comment">// 将目前找到的最近的顶点置1</span></span><br><span class="line"><span class="keyword">for</span>( w=<span class="number">0</span>; w &lt; G.numVextexes; w++ ) <span class="comment">// 修正当前最短路径及距离</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !final[w] &amp;&amp; (min+G.arc[k][w] &lt; (*D)[w]) ) <span class="comment">// 如经过v顶点的路径比现在这条路径的长度短的话，更新</span></span><br><span class="line">&#123;</span><br><span class="line">(*D)[w] = min + G.arc[k][w]; <span class="comment">// 修改当前路径长度</span></span><br><span class="line">(*p)[w] = k; <span class="comment">// 存放前驱顶点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png50" alt></p>
<ol>
<li>程序开始运行，第4行final数组是为了<script type="math/tex">v_0</script>到某顶点是否已经求得最短路径的标记，如果<script type="math/tex">v_0</script>到<script type="math/tex">v_w</script>已经有结果，则final[w]=1。</li>
<li>第5～10行，是在对数据进行初始化的工作。此时final数组值均为0，表示所有的点都未求得最短路径。D数组为{65535,1,5,65535,65535,65535,65535,65535,65535}。因为<script type="math/tex">v_0</script>与<script type="math/tex">v_1</script>和<script type="math/tex">v_2</script>的边权值为1和5。P数组全为0，表示目前没有路径。</li>
<li>第11行，表示<script type="math/tex">v_0</script>到<script type="math/tex">v_0</script>自身，权值和结果为0。D数组为{0,1,5,65535,65535,65535,65535,65535,65535}。第12行，表示<script type="math/tex">v_0</script>点算是已经求得最短路径，因此final[0]=1。此时final数组为{1,0,0,0,0,0,0,0,0}。此时整个初始化工作完成。</li>
<li>第13～33行，为主循环，每次循环求得<script type="math/tex">v_0</script>与一个顶点的最短路径。因此v从1而不是0开始。</li>
<li>第15～23行，先令min为65535的极大值，通过w循环，与D[w]比较找到最小值min=1，k=1。</li>
<li>第24行，由k=1，表示与<script type="math/tex">v_0</script>最近的顶点是<script type="math/tex">v_1</script>，并且由D[1]=1，知道此时<script type="math/tex">v_0</script>到<script type="math/tex">v_1</script>的最短距离是1。因此将<script type="math/tex">v_1</script>对应的final[1]设置为1。此时final数组为{1,1,0,0,0,0,0,0,0}。</li>
<li>第25～32行是一循环，目的是在刚才已经找到<script type="math/tex">v_0</script>与<script type="math/tex">v_1</script>的最短路径的基础上，对<script type="math/tex">v_1</script>与其他顶点的边进行计算，得到<script type="math/tex">v_0</script>与它们的当前最短距离，如下图。因为min=1，所以本来D[2]=5，现在<script type="math/tex">v_0\rightarrow v_1\rightarrow v_2=D[2]=min+3=4</script>,<script type="math/tex">v_0\rightarrow v_1\rightarrow v_3=D[3]=min+7=8</script>,<script type="math/tex">v_0\rightarrow v_1\rightarrow v_4=D[4]=min+5=6</script>，因此，D数组当前值为{0,1,4,8,6,65535,65535,65535,65535}。而P[2]=1，P[3]=1，P[4]=1，它表示的意思是<script type="math/tex">v_0</script>到<script type="math/tex">v_2,v_3,v_4</script>点的最短路径它们的前驱均是<script type="math/tex">v_1</script>。此时P数组值为：{0,0,1,1,1,0,0,0,0}。<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png51" alt></li>
<li>重新开始循环，此时v=2。第15～23行，对w循环，注意因为final[0]=1和fi-nal[1]=1，由第18行的!final[w]可知，<script type="math/tex">v_0</script>与<script type="math/tex">v_1</script>并不参与最小值的获取。通过循环比较，找到最小值min=4，k=2。</li>
<li>第24行，由k=2，表示已经求出<script type="math/tex">v_{0}</script>到<script type="math/tex">v_{2}</script>的最短路径，并且由D[2]=4，知道最短距离是4。因此将<script type="math/tex">v_2</script>对应的final[2]设置为1，此时final数组为：{1,1,1,0,0,0,0,0,0}。</li>
<li>第25～32行。在刚才已经找到<script type="math/tex">v_0</script>与<script type="math/tex">v_2</script>的最短路径的基础上，对<script type="math/tex">v_2</script>与其他顶点的边，进行计算，得到<script type="math/tex">v_0</script>与它们的当前最短距离，如下图。因为min=4，所以本来D[4]=6，现在<script type="math/tex">v_0\rightarrow v_2\rightarrow v_4=D[4]=min+1=5,v_0\rightarrow v_2\rightarrow v_5=D[5]=min+7=11</script>，因此，D数组当前值为：{0,1,4,8,5,11,65535,65535,65535}。而原本P[4]=1，此时P[4]=2，P[5]=2，它表示<script type="math/tex">v_0</script>到<script type="math/tex">v_4,v_5</script>点的最短路径它们的前驱均是<script type="math/tex">v_2</script>。此时P数组值为：{0,0,1,1,2,2,0,0,0}<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png52" alt></li>
<li>重新开始循环，此时v=3。第15～23行，通过对w循环比较找到最小值min=5，k=4。</li>
<li>第24行，由k=4，表示已经求出<script type="math/tex">v_0</script>到<script type="math/tex">v_4</script>的最短路径，并且由D[4]=5，知道最短距离是5。因此将<script type="math/tex">v_4</script>对应的final[4]设置为1。此时final数组为：{1,1,1,0,1,0,0,0,0}。</li>
<li>第25～32行。对<script type="math/tex">v_4</script>与其他顶点的边进行计算，得到<script type="math/tex">v_0</script>与它们的当前最短距离，如图。因为min=5，所以本来D[3]=8，现在<script type="math/tex">v_0\rightarrow v_4\rightarrow v_3=D[3]=min+2=7</script>，本来D[5]=11，现在<script type="math/tex">v_0\rightarrow v_4\rightarrow v_5=D[5]=min+3=8</script>，另外<script type="math/tex">v_0\rightarrow v_4\rightarrow v_6=D[6]=min+6=11</script>，<script type="math/tex">v_0\rightarrow v_4\rightarrow v_7=D[7]=min+9=14</script>，因此，D数组当前值为：{0,1,4,7,5,8,11,14,65535}。而原本P[3]=1，此时P[3]=4，原本P[5]=2，此时P[5]=4，另外P[6]=4，P[7]=4，它表示<script type="math/tex">v_0</script>到<script type="math/tex">v_3,v_5,v_6,v_7</script>点的最短路径它们的前驱均是<script type="math/tex">v_4</script>。此时P数组值为：{0,0,1,4,2,4,4,4,0}。<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png53" alt></li>
<li>得到最终的结果如图。此时final数组为：{1,1,1,1,1,1,1,1,1}，它表示所有的顶点均完成了最短路径的查找工作。此时D数组为：{0,1,4,7,5,8,10,12,16}，它表示<script type="math/tex">v_0</script>到各个顶点的最短路径数，比如D[8]=1+3+1+2+3+2+4=16。此时的P数组为：{0,0,1,4,2,4,3,6,7}，P[8]=7意思是<script type="math/tex">v_0</script>到<script type="math/tex">v_8</script>的最短路径，顶点<script type="math/tex">v_8</script>的前驱顶点是<script type="math/tex">v_7</script>，再由P[7]=6表示<script type="math/tex">v_7</script>的前驱是<script type="math/tex">v_6</script>，P[6]=3，表示<script type="math/tex">v_6</script>的前驱是<script type="math/tex">v_3</script>。这样就可以得到，<script type="math/tex">v_0</script>到<script type="math/tex">v_8</script>的最短路径即<script type="math/tex">v_0\rightarrow v_1\rightarrow v_2\rightarrow v_4\rightarrow v_3\rightarrow v_6\rightarrow v_7\rightarrow v_8</script>。<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png58" alt></li>
</ol>
<p>最终返回的数组D和数组P可以得到<script type="math/tex">v_0</script>到任意一个顶点的最短路径和路径长度,迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套得到此算法的时间复杂度为<script type="math/tex">O(n^2)</script></p>
<h2 id="弗洛伊德（Floyd）算法"><a href="#弗洛伊德（Floyd）算法" class="headerlink" title="弗洛伊德（Floyd）算法"></a>弗洛伊德（Floyd）算法</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png59" alt></p>
<blockquote>
<p><script type="math/tex">D^{-1}</script>是网图的邻接矩阵，<script type="math/tex">P^{-1}</script>初设为P[i][j]=j这样的矩阵，用来存储路径</p>
</blockquote>
<p>时间复杂度为<script type="math/tex">O(n^3)</script>,代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Pathmatirx[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"><span class="comment">/* Floyd算法，求网图G中各顶点v到其余顶点w最短 路径P[v][w]及带权长度D[v][w] */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(MGraph G, Pathmatirx *P, ShortPathTable *D)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v, w, k;</span><br><span class="line"><span class="keyword">for</span>( v=<span class="number">0</span>; v &lt; G.numVertexes; v++ ) <span class="comment">// 初始化D和P</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( w=<span class="number">0</span>; w &lt; G.numVertexes; w++ )</span><br><span class="line">&#123;</span><br><span class="line">(*D)[v][w] = G.matirx[v][w]; <span class="comment">/* D[v][w]值即为对应点间的权值 */</span></span><br><span class="line">(*P)[v][w] = w; <span class="comment">/* 初始化P */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( k=<span class="number">0</span>; k &lt; G.numVertexes; k++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( v=<span class="number">0</span>; v &lt; G.numVertexes; v++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( w=<span class="number">0</span>; w &lt; G.numVertexes; w++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( (*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w] )</span><br><span class="line">&#123;<span class="comment">/* 如果经过下标为k顶点路径比原两点间路径更短 将当前两点间权值设为更小的一个 */</span></span><br><span class="line">(*D)[v][w] = (*D)[v][k] + (*D)[k][w];</span><br><span class="line">(*P)[v][w] = (*P)[v][k]; <span class="comment">/* 路径设置经过下标为k的顶点 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始运行，第4～11行初始化D和P</li>
<li>第12～25行，是算法的主循环，一共三层嵌套，k代表中转顶点的下标。v代表起始顶点，w代表结束顶点</li>
<li>当K=0时，所有的顶点都经过<script type="math/tex">V_0</script>中转，计算是否有最短路径的变化。不过没有任何变化<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png60" alt></li>
<li>当K=1时，所有的顶点都经过<script type="math/tex">v_1</script>中转。此时，当v=0时，原本D[0][2]=5，现在由于D[0][1]+D[1][2]=4。因此由代码的第20行，二者取其最小值，得到D[0][2]=4，同理可得D[0][3]=8、D[0][4]=6，当v=2、3、4时，也修改了一些数据，即左图中虚线框数据。由于最小权值的修正，路径矩阵P改为当前的P[v][k]值，见代码第21行<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png61" alt></li>
<li>k=2一直到8结束，表示针对每个顶点做中转得到的计算结果，<script type="math/tex">D^0</script>是以<script type="math/tex">D^{-1}</script>为基础，<script type="math/tex">D^1</script>是以<script type="math/tex">D^0</script>为基础，……，<script type="math/tex">D^8</script>是以<script type="math/tex">D^7</script>为基础，路径矩阵P也是如此。当k=8时，两矩阵数据如图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png62" alt></li>
</ol>
<p>最短路径的显示代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G.numVertexes; ++v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(w=v+<span class="number">1</span>; w&lt;G.numVertexes; w++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"v%d-v%d weight: %d "</span>,v,w,D[v][w]);</span><br><span class="line">k=P[v][w]; <span class="comment">/* 获得第一个路径顶点下标 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" path: %d"</span>,v); <span class="comment">/* 打印源点 */</span></span><br><span class="line"><span class="keyword">while</span>(k!=w) <span class="comment">/* 如果路径顶点下标不是终点 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" -&gt; %d"</span>,k); <span class="comment">/* 打印路径顶点 */</span></span><br><span class="line">k=P[k][w]; <span class="comment">/* 获得下一个路径顶点下标 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" -&gt; %d\n"</span>,w); <span class="comment">/* 打印终点 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-7-拓扑排序"><a href="#7-7-拓扑排序" class="headerlink" title="7.7 拓扑排序"></a>7.7 拓扑排序</h1><p>无环，即图中没有回路</p>
<h2 id="拓扑排序介绍"><a href="#拓扑排序介绍" class="headerlink" title="拓扑排序介绍"></a>拓扑排序介绍</h2><p><strong>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网（ActivityOn Vertex Network）。</strong>AOV网中的弧表示活动之间存在的某种制约关系。AOV网中不能存在回路</p>
<p><strong>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列</strong><script type="math/tex">v_1,v_2,\cdots,v_n</script><strong>，满足若从顶点</strong><script type="math/tex">v_i</script><strong>到</strong><script type="math/tex">v_j</script><strong>有一条路径，则在顶点序列中顶点</strong><script type="math/tex">v_i</script><strong>必在顶点</strong><script type="math/tex">v_j</script><strong>之前。称这样的顶点序列为一个拓扑序列</strong></p>
<p><strong>拓扑排序是对一个有向图构造拓扑序列的过程</strong>。</p>
<p>构造时会有两个结果：</p>
<ul>
<li>如果此网的全部顶点都被输出，说明它是不存在环（回路）的AOV网</li>
<li>如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是AOV网</li>
</ul>
<h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><p>对AOV网进行拓扑排序的基本思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止</p>
<p>为AOV网建立一个邻接表。考虑到算法过程中始终要查找入度为0的顶点，因此在原来顶点表结点结构中，增加一个入度域in，其中in就是入度的数字</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">in</th>
<th style="text-align:center">data</th>
<th style="text-align:center">firstedge</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png64" alt></p>
<p>在拓扑排序算法中，涉及的结构代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> /* 边表结点 */</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex; <span class="comment">/* 邻接点域，存储该顶点对应的下标 */</span></span><br><span class="line"><span class="keyword">int</span> weight; <span class="comment">/* 用于存储权值，对于非网图可以不需要 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span> <span class="comment">/* 链域，指向下一个邻接点 */</span></span><br><span class="line">&#125; EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> /* 顶点表结点 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> in; <span class="comment">/* 顶点入度*/</span></span><br><span class="line"><span class="keyword">int</span> data; <span class="comment">/* 顶点域，存储顶点信息 */</span></span><br><span class="line">EdgeNode *firstedge; <span class="comment">/* 边表头指针 */</span></span><br><span class="line">&#125; VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">AdjList adjList;</span><br><span class="line"><span class="keyword">int</span> numVertexes,numEdges; <span class="comment">/* 图中当前顶点数和边数 */</span></span><br><span class="line">&#125; graphAdjList, *GraphAdjList;</span><br></pre></td></tr></table></figure>
<p>在算法中，还需要辅助的数据结构—栈，用来存储处理过程中入度为0的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为0的顶点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TopoLogicalSort</span><span class="params">(GraphAdjList GL)</span> <span class="comment">/*拓扑排序，若GL无回路，则输出拓扑排序序列并返回OK，若有回路返回ERROR*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode *e;</span><br><span class="line"><span class="keyword">int</span> i,k,gettop;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>; <span class="comment">/*用于栈指针下表*/</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">/*用于统计输出顶点的个数*/</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">stack</span>; <span class="comment">/*建栈用于存储入度为0的顶点*/</span></span><br><span class="line"><span class="built_in">stack</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes *<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;GL-&gt;numVertexes; i++)</span><br><span class="line"><span class="keyword">if</span>(GL-&gt;adjList[i].in == <span class="number">0</span>) <span class="comment">/*将入度为0的顶点入栈*/</span></span><br><span class="line"><span class="built_in">stack</span>[++top] = i;</span><br><span class="line"><span class="keyword">while</span>(top != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">gettop = <span class="built_in">stack</span>[top--]; <span class="comment">/*出栈*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>,GL-&gt;adjList[gettop].data); <span class="comment">/*打印此顶点*/</span></span><br><span class="line">count++; <span class="comment">/*统计输出顶点数*/</span></span><br><span class="line"><span class="keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge; e！; e=e-&gt;next)</span><br><span class="line">&#123; <span class="comment">/*对此顶点弧表遍历*/</span></span><br><span class="line">k = e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(--GL-&gt;adjList[k].in == <span class="number">0</span>) <span class="comment">//将k号顶点邻接点的入度减1,且减1后，入度为0的顶点需要存到栈中</span></span><br><span class="line"><span class="built_in">stack</span>[++top] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count &lt; GL-&gt;numVertexes) <span class="comment">/*如果count小于顶点数，说明存在环*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始运行，第3～7行都是变量的定义，其中stack是一个栈，用来存储整型的数字。</li>
<li>第9～11行，作了一个循环判断，把入度为0的顶点下标都入栈，此时stack应该为：{0,1,3}，即<script type="math/tex">v_0,v_1,v_3</script>的顶点入度为0<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png65" alt></li>
<li>第12～23行，while循环，当栈中有数据元素时，始终循环</li>
<li>第14～16行，<script type="math/tex">v_3</script>出栈得到gettop=3。并打印此顶点，然后count加1</li>
<li>第17～22行，循环是对<script type="math/tex">v3</script>顶点对应的弧链表进行遍历，即下图中的灰色部分，找到<script type="math/tex">v_3</script>连接的两个顶点<script type="math/tex">v_2</script>和<script type="math/tex">v_{13}</script>，并将它们的入度减少一位，此时<script type="math/tex">v_2</script>和<script type="math/tex">v_{13}</script>的in值都为1。目的是为了将<script type="math/tex">v_3</script>顶点上的弧删除<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png66" alt></li>
<li>再次循环，第12～23行。此时处理的是顶点<script type="math/tex">v_1</script>。经过出栈、打印、count=2后，对<script type="math/tex">v_1</script>到<script type="math/tex">v_2,v_4,v_8</script>的弧进行了遍历。并同样减少了它们的入度数，此时<script type="math/tex">v_2</script>入度为0，于是由第20～21行知，<script type="math/tex">v_2</script>入栈，如图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png67" alt></li>
<li>接下来是同样的处理方式。<script type="math/tex">v_2 ,v_6 ,v_0, v_4,v_5 ,v_8</script>的打印删除过程如下，后面还剩几个顶点都类似<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png68" alt></li>
<li>最终拓扑排序打印结果为3-&gt;1-&gt;2-&gt;6-&gt;0-&gt;4-&gt;5-&gt;8-&gt;7-&gt;12-&gt;9-&gt;10-&gt;13-&gt;11，这结果并不是唯一的一种拓扑排序方案</li>
</ol>
<p>对一个具有n个顶点e条弧的AOV网来说，第9～11行扫描顶点表，将入度为0的顶点入栈的时间复杂为<script type="math/tex">O(n)</script>，之后的while循环中，每个顶点进一次栈，出一次栈，入度减1的操作共执行了e次，所以整个算法的时间复杂度为<script type="math/tex">O(n+e)</script></p>
<h1 id="7-8-关键路径"><a href="#7-8-关键路径" class="headerlink" title="7.8 关键路径"></a>7.8 关键路径</h1><p><strong>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为AOE网（Activity On Edge Net-work）</strong></p>
<p>AOE网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点</p>
<p>$v_0$是源点，表示一个工程的开始，<script type="math/tex">v_9</script>是汇点，表示整个工程的结束，顶点<script type="math/tex">v_0,v_1,\cdots,v_9</script>分别表示事件，弧<script type="math/tex"><v_0,v_1>,</script> <script type="math/tex"><v_0,v_2>,</script> <script type="math/tex">\cdots,<v_8,v_9></script>都表示一个活动，用<script type="math/tex">a_0,a_1,\cdots,a_{12}</script>表示，它们的值代表着活动持续的时间，弧<script type="math/tex"><v_0,v_1></script>就是从源点开始的第一个活动<script type="math/tex">a_0</script>，它的时间是3个单位</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png70" alt></p>
<p>AOV网是顶点表示活动的网，它只描述活动之间的制约关系，而AOE网是用边表示活动的网，边上的权值表示活动持续的时间，AOE网是要建立在活动之间制约关系没有矛盾的基础之上，再来分析完成整个工程至少需要多少时间，或者为缩短完成工程所需时间，应当加快哪些活动等问题</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png71" alt></p>
<p><strong>路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png72" alt></p>
<blockquote>
<p>开始→发动机完成→部件集中到位→组装完成就是关键路径，路径长度为5.5</p>
</blockquote>
<h2 id="关键路径算法原理"><a href="#关键路径算法原理" class="headerlink" title="关键路径算法原理"></a>关键路径算法原理</h2><p>所有活动的最早开始时间和最晚开始时间如果相等就意味着此活动是关键活动，活动间的路径为关键路径</p>
<p>定义如下几个参数：</p>
<ol>
<li>事件的最早发生时间etv（earliest time ofvertex）：即顶点<script type="math/tex">v_k</script>的最早发生时间</li>
<li>事件的最晚发生时间ltv（latest time ofvertex）：即顶点<script type="math/tex">v_k</script>的最晚发生时间，也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工期</li>
<li>活动的最早开工时间ete（earliest time ofedge）：即弧<script type="math/tex">a_k</script>的最早发生时间</li>
<li>活动的最晚开工时间lte（latest time ofedge）：即弧<script type="math/tex">a_k</script>的最晚发生时间，也就是不推迟工期的最晚开工时间</li>
</ol>
<p>由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断<script type="math/tex">a_k</script>是否是关键活动</p>
<h2 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h2><p>将AOE网转化为邻接表结构，与拓扑排序时邻接表结构不同的是弧链表增加了weight域，用来存储弧的权值</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png80" alt><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png81" alt></p>
<p>求事件的最早发生时间etv的过程，就是从头至尾找拓扑序列的过程，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算etv和拓扑序列列表。为此，首先在程序开始处声明几个全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *etv, *ltv; <span class="comment">/* 事件最早发生时间和最迟发生时间数组 */</span></span><br><span class="line"><span class="keyword">int</span> *stack2; <span class="comment">/* 用于存储拓扑序列的栈 */</span></span><br><span class="line"><span class="keyword">int</span> top2; <span class="comment">/* 用于stack2的指针 */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>stack2用来存储拓扑序列，以便后面求关键路径时使用</p>
</blockquote>
<p>改进过的求拓扑序列算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">status <span class="title">TopoLogicalSort</span><span class="params">(GraphAdjList GL)</span> <span class="comment">/* 拓扑排序，用于关键路径计算 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode *e;</span><br><span class="line"><span class="keyword">int</span> i,k,gettop;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>; <span class="comment">/*用于栈指针下表*/</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">/*用于统计输出顶点的个数*/</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">stack</span>; <span class="comment">/*建栈用于存储入度为0的顶点*/</span></span><br><span class="line"><span class="built_in">stack</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes *<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//动态分配内存，大小为n个顶点</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;GL-&gt;numVertexes; i++)</span><br><span class="line"><span class="keyword">if</span>(GL-&gt;adjList[i].in == <span class="number">0</span>) <span class="comment">/*将入度为0的顶点入栈*/</span></span><br><span class="line"><span class="built_in">stack</span>[++top] = i;</span><br><span class="line">top2 = <span class="number">0</span>; <span class="comment">//初始化为0</span></span><br><span class="line">etv = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(GL-&gt;numVertexes*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">/*事件的最早发生时间*/</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;GL-&gt;numVertexes; i++)</span><br><span class="line">etv[i] = <span class="number">0</span>; <span class="comment">//初始化为0</span></span><br><span class="line">stack2 = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(GL-&gt;numVertexes*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">/*初始化*/</span></span><br><span class="line"><span class="keyword">while</span>(top != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">gettop = <span class="built_in">stack</span>[top--]; <span class="comment">/*出栈*/</span></span><br><span class="line">count++; <span class="comment">/*统计输出顶点数*/</span></span><br><span class="line">stack2[++top2] = gettop; <span class="comment">/*将弹出的顶点序列号压入拓扑序列的栈中*/</span></span><br><span class="line"><span class="keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge; e; e=e-&gt;next)</span><br><span class="line">&#123; <span class="comment">/*对此顶点弧表遍历*/</span></span><br><span class="line">k = e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(!(--GL-&gt;adjList[k].in)) <span class="comment">//将k号顶点邻接点的入度减1,且减1后，入度为0的顶点需要存到栈中</span></span><br><span class="line"><span class="built_in">stack</span>[++top] = k;</span><br><span class="line"><span class="keyword">if</span>((etv[gettop]+e-&gt;weight)&gt;etv[k]) <span class="comment">/*求各顶点时间最早发生时间*/</span></span><br><span class="line">etv[k] = etv[gettop] + e-&gt;weight; <span class="comment">/*某个顶点的最早发生时间= 和它相关的活动必须全部完成*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count &lt; GL-&gt;numVertexes) <span class="comment">/*如果count小于顶点数，说明存在环*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第27～28行是求etv数组的每一个元素的值。比如说已经求得顶点<script type="math/tex">v_0</script>对应的etv[0]=0，顶点<script type="math/tex">v_1</script>对应的etv[1]=3，顶点<script type="math/tex">v_2</script>对应的etv[2]=4，求顶点<script type="math/tex">v_3</script>对应的etv[3]就是求etv[1]+len&lt;<script type="math/tex">v_1,v_3</script>&gt;与etv[2]+len&lt;<script type="math/tex">v_2,v_3</script>&gt;的较大值。显然3+5&lt;4+8，得到etv[3]=12，代码中e-&gt;weight就是当前弧的长度</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png82" alt></p>
<p>计算顶点<script type="math/tex">v_k</script>即求etv[k]的最早发生时间的公式是：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png83" alt></p>
<p>P[K]表示所有到达顶点<script type="math/tex">v_k</script>的弧的集合。比如P[3]就是&lt;<script type="math/tex">v_1,v_3</script>&gt;和&lt;<script type="math/tex">v_2,v_3</script>&gt;两条弧。len&lt;<script type="math/tex">v_i,v_k</script>&gt;是弧&lt;<script type="math/tex">v_i,v_k</script>&gt;上的权值</p>
<p>求关键路径的算法代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(GraphAdjList GL)</span> <span class="comment">/*求关键路径，GL为有向网，输出GL的各项关键活动*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EdgeNode *e;</span><br><span class="line"><span class="keyword">int</span> i,gettop,k,j;</span><br><span class="line"><span class="keyword">int</span> ete,lte; <span class="comment">/*声明活动最早发生时间和最迟发生时间*/</span></span><br><span class="line">TopoLogicalSort(GL); <span class="comment">/*求拓扑序列，计算数组etv和stack2的值*/</span></span><br><span class="line">ltv = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(GL-&gt;numVertexes*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">/*时间的最晚发生时间*/</span></span><br><span class="line"><span class="keyword">for</span>(i= <span class="number">0</span>; i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">ltv[i]=etv[GL-&gt;numVertexes<span class="number">-1</span>]; <span class="comment">/*初始化ltv[i] 为工程完成的最早时间，etv[i]初始化为0*/</span></span><br><span class="line"><span class="keyword">while</span>(top2!=<span class="number">0</span>) <span class="comment">/*计算ltv*/</span></span><br><span class="line">&#123;</span><br><span class="line">gettop = stack2[top2--];</span><br><span class="line"><span class="keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge;e!=NUll;e=e-&gt;next)</span><br><span class="line">&#123;<span class="comment">/*求各定点事件的最迟发生时间ltv值*/</span></span><br><span class="line">k=e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span>(ltv[k]-e-&gt;weight&lt;ltv[gettop])</span><br><span class="line">ltv[gettop]= ltv[k]-e-&gt;weight; <span class="comment">/*求最晚发生时间，是从拓扑序列的最后一个顶点逆着推导*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;GL-&gt;numVertexes;j++) <span class="comment">/*求ete，lte关键活动*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(e=GL-&gt;adjList[j].firstedge;e!=<span class="literal">NULL</span>;e=e-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">k=e-&gt;adjvex;</span><br><span class="line">ete = etv[j]; <span class="comment">/*活动最早开始时间*/</span></span><br><span class="line">lte = ltv[k] - e-&gt;weight;<span class="comment">/*活动最晚发生时间*/</span></span><br><span class="line"><span class="keyword">if</span>(ete ==lte)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;v%d,v%d&gt; length: %d, "</span>,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始执行。第5行，声明了ete和lte两个活动最早最晚发生时间变量</li>
<li>第6行，调用求拓扑序列的函数。执行完毕后，全局变量数组etv和栈stack的值如下图，top2=10。即对于每个事件的最早发生时间，已经计算出来<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png84" alt></li>
<li>第7～9行为初始化全局变量ltv数组，因为etv[9]=27，所以数组ltv当前的值为：{27,27,27,27,27,27,27,27,27,27}</li>
<li>第10～19行为计算ltv的循环。第12行，先将stack2的栈头出栈，由后进先出得到gettop=9。根据邻接表中，<script type="math/tex">v_9</script>没有弧表，所以第13～18行循环体未执行</li>
<li>再次来到第12行，gettop=8，在第13～18行的循环中，<script type="math/tex">v_8</script>的弧表只有一条&lt;<script type="math/tex">v_8,v_9</script>&gt;，第15行得到k=9，因为ltv[9]-3&lt;ltv[8]，所以ltv[8]=ltv[9]-3=24<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png85" alt></li>
<li>再次循环，当gettop=7、5、6时，同理可算出ltv相对应的值为19、13、25，此时ltv值为：{27，27，27，27，27，13，25，19，24，27}</li>
<li>当gettop=4时，由邻接表可得到<script type="math/tex">v_4</script>有两条弧&lt;<script type="math/tex">v_4,v_6</script>&gt;、&lt;<script type="math/tex">v_4,v_7</script>&gt;，通过第13～18行的循环，可以得到ltv[4]=min(ltv[7]-4,ltv[6]-9)=min(19-4,25-9)=1<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png87" alt></li>
<li>可以得出计算顶点<script type="math/tex">v_k</script>即求ltv[k]的最晚发生时间的公式如下，S[K]表示所有从顶点<script type="math/tex">v_k</script>出发的弧的集合。比如S[4]就是&lt;<script type="math/tex">v_4,v_6</script>&gt;和&lt;<script type="math/tex">v_4,v_7</script>&gt;两条弧，len&lt;<script type="math/tex">v_k,v_j</script>&gt;是弧&lt;<script type="math/tex">v_k,v_j</script>&gt;上的权值。<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png88" alt></li>
<li>当程序执行到第20行时，相关变量的值如图，比如etv[1]=3而ltv[1]=7，表示的意思就是如果时间单位是天的话，哪怕<script type="math/tex">v_1</script>这个事件在第7天才开始，也可以保证整个工程的按期完成，可以提前<script type="math/tex">v_1</script>事件开始时间，但最早也只能在第3天开始<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png89" alt></li>
<li>第20～30行是来求另两个变量活动最早开始时间ete和活动最晚开始时间lte，并对相同下标的它们做比较。两重循环嵌套是对邻接表的顶点和每个顶点的弧表遍历</li>
<li>当j=0时，从<script type="math/tex">v_0</script>点开始，有&lt;<script type="math/tex">v_0,v_2</script>&gt;和&lt;<script type="math/tex">v_0,v_1</script>&gt;两条弧。当k=2时，ete=etv[j]=etv[0]=0。lte=ltv[k]-e-&gt;weight=ltv[2]-len&lt;<script type="math/tex">v_0,v_2</script>&gt;=4-4=0，此时ete=lte，表示弧&lt;<script type="math/tex">v_0,v_2</script>&gt;是关键活动，因此打印。当k=1时，ete=etv[j]=etv[0]=0。lte=ltv[k]-e-&gt;weight=ltv[1]-len&lt;<script type="math/tex">v_0,v_1</script>&gt;=7-3=4，此时ete≠lte，因此&lt;<script type="math/tex">v_0,v_1</script>&gt;并不是关键活动<img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png90" alt></li>
<li>ete本来是表示活动&lt;<script type="math/tex">v_k,v_j</script>&gt;的最早开工时间，是针对弧来说的。但只有此弧的弧尾顶点<script type="math/tex">v_k</script>的事件发生了，它才可以开始，因此ete=etv[k]。而lte表示的是活动&lt;<script type="math/tex">v_k,v_j</script>&gt;的最晚开工时间，但此活动再晚也不能等<script type="math/tex">v_j</script>事件发生才开始，而必须要在<script type="math/tex">v_j</script>事件之前发生，所以lte=ltv[j]-len&lt;<script type="math/tex">v_k,v_j</script>&gt;。判断ete与lte是否相等，相等意味着活动没有任何空闲，是关键活动，否则就不是</li>
<li>j=1一直到j=9为止，做法是完全相同的，关键路径打印结果为“&lt;<script type="math/tex">v_0,v_2</script>&gt;4,&lt;<script type="math/tex">v_2,v_3</script>&gt;8,&lt;<script type="math/tex">v_3,v_4</script>&gt;3,&lt;<script type="math/tex">v_4,v_7</script>&gt;4,&lt;<script type="math/tex">v_7,v_8</script>&gt;5,&lt;<script type="math/tex">v_8,v_9</script>&gt;3”</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png91" alt></p>
<p>分析整个求关键路径的算法，第6行是拓扑排序，时间复杂度为<script type="math/tex">O(n+e)</script>，第8～9行时间复杂度为<script type="math/tex">O(n)</script>，第10～19行时间复杂度为<script type="math/tex">O(n+e)</script>，第20～31行时间复杂也为<script type="math/tex">O(n+e)</script>，根据对时间复杂度的定义，所有的常数系数可以忽略，所以最终求关键路径算法的时间复杂度依然是<script type="math/tex">O(n+e)</script></p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第一章  数据结构概论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第一章  数据结构概论/" itemprop="url">大话数据结构 第一章  数据结构概论</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:47:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:20:07Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第一章  数据结构概论/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第一章  数据结构概论/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第一章  数据结构概论/" class="leancloud_visitors" data-flag-title="大话数据结构 第一章  数据结构概论">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="1-1-基本概念和术语"><a href="#1-1-基本概念和术语" class="headerlink" title="1.1 基本概念和术语"></a>1.1 基本概念和术语</h1><p><strong>数据</strong>：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型</p>
<p>这里说的数据就是符号，必须具备两个前提：</p>
<ol>
<li>可以输入到计算机中</li>
<li>能被计算机程序处理</li>
</ol>
<p><strong>数据元素</strong>：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p>
<p><strong>数据项</strong>：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。但真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点</p>
<p><strong>数据对象</strong>：是性质相同的数据元素的集合，是数据的子集。</p>
<p><strong>性质相同</strong>：是指数据元素具有相同数量和类型的数据项</p>
<p><strong>数据结构</strong>：是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式</p>
<p><strong>结构</strong>：指各个组成部分相互搭配和排列的方式。简单的理解就是关系，比如分子结构，就是说组成分子的原子之间的排列方式</p>
<h1 id="1-2-逻辑结构与物理结构"><a href="#1-2-逻辑结构与物理结构" class="headerlink" title="1.2 逻辑结构与物理结构"></a>1.2 逻辑结构与物理结构</h1><p>按照视点的不同，把数据结构分为逻辑结构和物理结构</p>
<h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><strong>逻辑结构</strong>：指数据对象中数据元素之间的相互关系</p>
<p>逻辑结构分为以下四种：</p>
<ol>
<li><strong>集合结构</strong>：集合结构中的数据元素除了同属于一个集合外没有其他关系。各个数据元素是“平等”的，共同属性是“同属于一个集合”。集合关系就类似于数学中的集合<br><img src="https://baozou.gitbooks.io/-data-structure/content/assets/1import.png" alt></li>
<li><strong>线性结构</strong>：线性结构中的数据元素之间是一对一的关系<img src="https://baozou.gitbooks.io/-data-structure/content/assets/2import.png" alt></li>
<li>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系<img src="https://baozou.gitbooks.io/-data-structure/content/assets/8import.png" alt></li>
<li><strong>图形结构</strong>：图形结构的数据元素是多对多的关系<img src="https://baozou.gitbooks.io/-data-structure/content/assets/3import.png" alt></li>
</ol>
<p>用示意图表示数据的逻辑结构时，要注意两点：</p>
<ol>
<li>将每一个数据元素看做一个结点，用圆圈表示。</li>
<li>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。</li>
</ol>
<p>逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系</p>
<h2 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h2><p><strong>物理结构</strong>：指数据的逻辑结构在计算机中的存储形式</p>
<p>数据是数据元素的集合，根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中</p>
<p>数据的存储结构应正确反映数据元素之间的逻辑关系</p>
<p>数据元素的存储结构形式有两种：</p>
<ol>
<li><strong>顺序存储结构</strong>：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的<img src="https://baozou.gitbooks.io/-data-structure/content/assets/4import.png" alt></li>
<li><strong>链式存储结构</strong>：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，需要用一个指针存放数据元素的地址，通过地址就可以找到相关联数据元素的位置<img src="https://baozou.gitbooks.io/-data-structure/content/assets/5import.png" alt></li>
</ol>
<p>逻辑结构是面向问题的，而物理结构是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中</p>
<h1 id="1-3-抽象数据类型"><a href="#1-3-抽象数据类型" class="headerlink" title="1.3 抽象数据类型"></a>1.3 抽象数据类型</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>数据类型</strong>：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作</p>
<p>在C语言中，按照取值的不同，数据类型可以分为两类：</p>
<ol>
<li><strong>原子类型</strong>：是不可以再分解的基本类型，包括整型、实型、字符型等。</li>
<li><strong>结构类型</strong>：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。</li>
</ol>
<p>比如，在C语言中变量声明int a,b，这就意味着，在给变量a和b赋值时不能超出int的取值范围，变量a和b之间的运算只能是int类型所允许的运算。</p>
<p><strong>抽象：</strong>指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p><strong>抽象数据类型（Abstract Data Type，ADT）</strong>：指一个数学模型及定义在该模型上的一组操作</p>
<p>抽象数据类型的定义仅取决于它的一组<strong>逻辑特性</strong>，而与其在计算机内部如何表示和实现无关</p>
<p>一个抽象数据类型定义了：一个<strong>数据对象</strong>、数据对象中各数据元素之间的<strong>关系</strong>及对数据元素的<strong>操作</strong></p>
<p>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来</p>
<p>抽象数据类型的标准格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ADT</span><br><span class="line"></span><br><span class="line">抽象数据类型名</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line"></span><br><span class="line">数据元素之间逻辑关系的定义</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line"></span><br><span class="line">操作<span class="number">1</span></span><br><span class="line"></span><br><span class="line">初始条件</span><br><span class="line"></span><br><span class="line">操作结果描述</span><br><span class="line"></span><br><span class="line">操作<span class="number">2</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">操作n</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>严版：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名 &#123;</span><br><span class="line"></span><br><span class="line">数据对象：&lt;数据对象的定义&gt;</span><br><span class="line"></span><br><span class="line">数据关系：数据关系的定义&gt;</span><br><span class="line"></span><br><span class="line">基本操作：&lt;基本操作的定义&gt;</span><br><span class="line"></span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>
<h1 id="1-4-回顾总结"><a href="#1-4-回顾总结" class="headerlink" title="1.4 回顾总结"></a>1.4 回顾总结</h1><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/6import.png" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/7import.png" alt></p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第六章  树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第六章  树/" itemprop="url">大话数据结构 第六章  树</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:47:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:25:41Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第六章  树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第六章  树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第六章  树/" class="leancloud_visitors" data-flag-title="大话数据结构 第六章  树">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="6-1-树的定义"><a href="#6-1-树的定义" class="headerlink" title="6.1 树的定义"></a>6.1 树的定义</h1><p><strong>树（Tree）</strong>是n（n≥0）个结点的有限集。n=0时称为<strong>空树</strong>。在任意一棵非空树中：（1）有且仅有一个特定的称为<strong>根（Root）</strong>的结点；（2）当n＞1时，其余结点可分为m（m＞0）个互不相交的有限集<script type="math/tex">T_1</script>、<script type="math/tex">T_2</script>、……、<script type="math/tex">T_m</script>，其中每一个集合本身又是一棵树，并且称为根的<strong>子树（SubTree）</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/108import.png" alt></p>
<p>子树<script type="math/tex">T_1</script>和子树<script type="math/tex">T_2</script>就是根结点A的子树。D、G、H、I组成的树又是B为根结点的子树，E、J组成的树是以C为根结点的子树</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/109import.png" alt></p>
<p>树的定义还需要强调两点：</p>
<ol>
<li>n&gt;0时根结点是唯一的，不可能存在多个根结点，</li>
<li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。下图中的两个结构就不符合树的定义，因为它们都有相交的子树</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/110import.png" alt></p>
<h2 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h2><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的<strong>度（De-gree）</strong>。度为0的结点称为<strong>叶结点（Leaf）</strong>或<strong>终端结点</strong>；度不为0的结点称为<strong>非终端结点</strong>或<strong>分支结点</strong>。除根结点之外，分支结点也称为<strong>内部结点</strong>。树的度是树内各结点的度的<strong>最大值</strong>。</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/111import.png" alt></p>
<blockquote>
<p>结点的度的最大值是结点D的度，为3，所以树的度也为3</p>
</blockquote>
<h2 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h2><p>结点的子树的根称为该结点的<strong>孩子（Child）</strong>，相应地，该结点称为孩子的<strong>双亲（Parent）</strong>，同一个双亲的孩子之间互称<strong>兄弟（Sibling）</strong>。结点的祖先是从根到该结点所经分支上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/112import.png" alt></p>
<h2 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h2><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第l层，则其子树就在第l+1层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的<strong>深度（Depth）</strong>或<strong>高度</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/113import.png" alt></p>
<p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为<strong>有序树</strong>，否则称为<strong>无序树。森林（Forest）</strong>是m（m≥0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林</p>
<p>线性表与树的结构：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/114import.png" alt></p>
<h1 id="6-2-树的抽象数据类型"><a href="#6-2-树的抽象数据类型" class="headerlink" title="6.2 树的抽象数据类型"></a>6.2 树的抽象数据类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ADT 树 (tree)</span><br><span class="line">Data:</span><br><span class="line">树是由一个根结点和若干棵子数构成.树中结点具有相同数据类型及层次关系</span><br><span class="line">Operation:</span><br><span class="line">InitTree (*T):构成空树T</span><br><span class="line">DestroyTree(*T):销毁树T</span><br><span class="line">CreateTree(*T,definition):按definition中给出的树的定义来构造树</span><br><span class="line">ClearTree(*T):若树T存在,则将树T请为空树</span><br><span class="line">TreeEmpty(T):若T为空树,返回<span class="literal">true</span>,否则返回<span class="literal">false</span></span><br><span class="line">TreeDepth(T):返回T的深度</span><br><span class="line">Root(T):返回T的根结点</span><br><span class="line">Value(T,cur_e):cur_e是树T中一个结点,返回此结点的值</span><br><span class="line">Assign(T,cur_e,value):给树T的结点cur_e赋值为value</span><br><span class="line">Parent(T,cur_e):若cur_e是树T的非根结点,返回它的双亲,否则返回空</span><br><span class="line">LeftChild(T,cur_e):若cur_e是树T的非叶节点,则返回它的最左孩子,否则返回空</span><br><span class="line">RightSibling(T,cur_e):若cur_e有右兄弟,则返回他的右兄弟,否则返回空</span><br><span class="line">InsertChild(*T,*p,i,c):其中p指向树T的某个结点,T为所指结点p的度加上<span class="number">1</span>,非空树c与T</span><br><span class="line">不相交,操作结果为插入c为树T中p所指结点的第i棵子树</span><br><span class="line">DeleteChile(*T,*p,i):其中p指向树T的某个结点,i为所指结点p的度,操作结果为删除T中p所指结点的第i棵子树</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h1 id="6-3-树的存储结构"><a href="#6-3-树的存储结构" class="headerlink" title="6.3 树的存储结构"></a>6.3 树的存储结构</h1><h2 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h2><p>假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。每个结点除了知道自己是谁以外，还知道它的双亲在哪里</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">data</th>
<th style="text-align:center">parent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据域，存储结点的数据信息</td>
<td style="text-align:center">指针域，存储该结点的双亲在数组中的下标</td>
</tr>
</tbody>
</table>
</div>
<p>结点结构定义代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的双亲表示法结点结构定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElemType; <span class="comment">//树结点的数据类型,目前暂定义为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> //结点结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data; <span class="comment">//结点数据</span></span><br><span class="line"><span class="keyword">int</span> parent; <span class="comment">//双亲位置</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //树结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PTNode nodes[MAX_TREE_SIZE]; <span class="comment">//结点数组</span></span><br><span class="line"><span class="keyword">int</span> r,n; <span class="comment">//根的位置和结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<p>由于根结点是没有双亲的,约定根结点的位置域设置为-1,这就意味着所有的结点都存在他的双亲结点</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-8c15b75546c75a60.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p>根据结点的parent指针很容易找到它的双亲结点,所用时间复杂度为O(1),知道parent为-1,表示找到了树结点的根.如果要知道结点的孩子是什么,就必须遍历整个结构才行</p>
<p>改进：</p>
<p>增加一个结点最左边孩子的域,叫<strong>长子域，</strong>如果没有孩子的结点,这个长子域就设置为-1</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-22d8048a6f0c1c75.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p>每一个结点如果它存在右兄弟,则记录下右兄弟的下标,如果右兄弟不存在,则赋值为-1</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-92cb0e0a0f25f155.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<h2 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h2><p>由于树中每个结点可能有多棵子树,可以考虑多重链表,即<strong>每个指针指向一棵子数的根结点,这种方法叫多重链表表示法</strong></p>
<p>不过,树的每个结点的度,也就是它的孩子个数是不同的</p>
<ul>
<li><strong>方案一:指针域的个数等于树的度</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-9aff0ffd7f66af3b.png?imageMogr2/auto-orient/strip|imageView2/2/w/618" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-017c8b0d9d90e928.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p>这种方法对于树中各结点的度相差很大时,显然很浪费空间,因为有很多的结点指针域都是空的.如果树的各结点度相差很小时,开辟空间被充分利用了,这时缺点变优点</p>
<ul>
<li><strong>方案二:按需分配空间</strong></li>
</ul>
<p>每个结点指针域的个数等于该结点的度,取一个位置来储存结点指针域的个数</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-3286187d8e61deb9.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-69b27b0fff0eea31.png?imageMogr2/auto-orient/strip|imageView2/2/w/573" alt></p>
<p>克服了浪费空间的缺点,对空间利用率提高,但由于各个结点的链表是不相同的结构,加上要维护结点的度的数值,在运算上会带来时间上的损耗</p>
<p>孩子表示法:把每个结点的孩子结点排列起来,以单链表作存储结构,则n个结点有n个孩子链表,如果是叶子结点则此链表为空.然后n个头指针又组成一个线性表,采用顺序存储结构,存放进一个一维数组中</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-ffa671baeef07788.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p>为此设置了两种结点结构:一个是孩子链表的孩子结点</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-e7285074b120f193.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p>另一个是表头数组的表头结点</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-1a1614ef097f7315.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数的孩子表示法结构定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> //孩子结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> child;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //表头结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;</span><br><span class="line">ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //树结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">CTBox nodes[MAX_TREE_SIZE]; <span class="comment">//结点数组</span></span><br><span class="line"><span class="keyword">int</span> r, n; <span class="comment">//根的位置和结点数</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
<p>这样的结构对于要查找某个结点的某个孩子,或者找某结点的兄弟,只需要查找这个结点的孩子单链表即可.但要知道某结点的双亲是谁,比较麻烦,需要遍历整棵树才行</p>
<p><strong>双亲孩子表示法</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-ef0cbb402f488d56.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<h2 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h2><p>任意一棵树,它的结点的第一个<strong>孩子</strong>如果存在就是唯一的,它的<strong>右兄弟</strong>如果存在也是唯一的,因此,设置两个指针,分别指向该结点的<strong>第一个孩子</strong>和此结点的<strong>兄弟</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-2d9ad2191c3d90e8.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p>结构定义代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 树的孩子兄弟表示法结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
<p><a href="http://melodyofnight.github.io/images/树-孩子兄弟表示法.png" target="_blank" rel="noopener"><img src="https://baozou.gitbooks.io/-data-structure/content/assets/115import.png" alt></a></p>
<p>这种表示法，查找某个结点的某个孩子只需要通过fistchild找到此结点的长子，再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子</p>
<p>这个表示法的最大好处是把一棵复杂的树变成了一棵二叉树</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/116import.png" alt></p>
<h1 id="6-4-二叉树的定义"><a href="#6-4-二叉树的定义" class="headerlink" title="6.4 二叉树的定义"></a>6.4 二叉树的定义</h1><p><strong>二叉树是n(n&gt;=0)个结点的有限集合,该集合或者为空集(称为空二叉树),或者由一个根结点和两棵互不相交的,分别称为根结点的左子树和右子树的二叉树组成</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-2cf0898d8befcaf6.png?imageMogr2/auto-orient/strip|imageView2/2/w/278" alt></p>
<h2 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h2><ol>
<li>每个结点<strong>最多</strong>有_<strong>两颗</strong>_子树,所以二叉树不存在度大于2的结点</li>
<li>左子树和右子树是有顺序的,次序不能任意颠倒</li>
<li>即使树中某结点只有一颗子树,也要区分左子树和右子树的</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-44a8eb0d9731cb36.png?imageMogr2/auto-orient/strip|imageView2/2/w/488" alt></p>
<p>二叉树的五种基本形态：</p>
<ol>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根结点只有左子树</li>
<li>根结点只有右子树</li>
<li>树既有左子树也有右子树</li>
</ol>
<p>只从形态上考虑，三个结点的树只有两种情况，图中有两层的树1和有三层的后四种的任意一种，对于二叉树来说，由于要区分左右，就演变成五种形态，树2、树3、树4和树5分别代表不同的二叉树</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/117import.png" alt></p>
<h2 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h2><p><strong>1.斜树</strong><br>斜树一定是斜的,<strong>所有的结点都只有左子树的二叉树叫左斜树.所有的二叉树只有右子数的树叉树叫右斜树.两者统称为斜树</strong>。斜树每一层都只有一个结点,结点的个数跟二叉树的深度相同.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-91b069343b92d9b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/521" alt></p>
<p>线性表就是特殊的二叉树</p>
<p><strong>2.满二叉树</strong></p>
<p><strong>在一棵二叉树中,如果所有分支结点都存在左子树和右子树,并且所有叶子都在同一层上,这样的二叉树称为满二叉树</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-bcb35fe4316cb8ce.png?imageMogr2/auto-orient/strip|imageView2/2/w/388" alt></p>
<p>满二叉树的特点:</p>
<ol>
<li>叶子只能出现在最下一层,出现在其他层就不可能达到平衡</li>
<li>非叶子结点的度一定是2</li>
<li>在同样深度的二叉树中,满二叉树的结点个数最多,叶子树最多</li>
</ol>
<p><strong>3.完全二叉树</strong></p>
<p><strong>对一棵具有n个结点的二叉树按层序编号,如果编号为i(1&lt;= i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同,则这棵二叉树树完全二叉树</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-14d589a906b5540d.png?imageMogr2/auto-orient/strip|imageView2/2/w/363" alt></p>
<blockquote>
<p>尽管不是满二叉树，但是编号是连续的，所以它是完全二叉树</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-1f5b091daf8fca83.png?imageMogr2/auto-orient/strip|imageView2/2/w/535" alt></p>
<blockquote>
<p>满二叉树一定是完全二叉树,而完全二叉树不一定是满二叉树</p>
</blockquote>
<p>完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。关键词是按层序编号，树1因为5结点没有左子树，却有右子树，使得按层序编号的第10个编号空档。树2由于3结点没有子树，使得6、7编号的位置空档。树3因为5编号下没有子树造成第10和第11位置空档。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-ea935c12020d1891.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p><strong>完全二叉树的特点:</strong></p>
<ol>
<li>叶子结点只能出现在最下两层</li>
<li>最下层的叶子一定集中在左部连续位置</li>
<li>倒数两层,若有叶子结点,一定都在右部连续位置</li>
<li>若结点度为1,则该结点只有左孩子,即不存在只有右子树的情况</li>
<li>同样结点树的二叉树,完全二叉树的深度最小</li>
</ol>
<h1 id="6-5-二叉树的性质"><a href="#6-5-二叉树的性质" class="headerlink" title="6.5 二叉树的性质"></a>6.5 二叉树的性质</h1><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2><p>在二叉树的第i层上至多有<script type="math/tex">2^{i-1}</script>个结点(i&gt;=1)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-4d867eb9ed8033c0.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2><p>深度为k的二叉树至多有<script type="math/tex">2^{k-1}</script>个结点(k&gt;=1)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-8e27a12ccaa011ca.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2><p>对任何一棵二叉树T,如果其<strong>终端结点数</strong>(叶子结点数)为<script type="math/tex">n_0</script>,度为<strong>2</strong>的结点数为<script type="math/tex">n_2</script>,则<script type="math/tex">n_0 = n_2+1</script></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-816bc979d99483e3.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<p>一棵二叉树中,除了叶子结点外,剩下的就是度为1或2的结点树了,设<script type="math/tex">n_1</script>为度为1的结点数.则树的总结点数<script type="math/tex">n = n_0+n_1+n_2</script></p>
<h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2><p>具有n个结点的完全二叉树的深度为<script type="math/tex">[log_2N]+1</script>（|x|表示不大于x的最大整数）</p>
<p>深度为k的满二叉树的结点数n一定是<script type="math/tex">2^k-1</script>。这是最多的结点个数。对于<script type="math/tex">n=2^k-1</script>倒推得到满二叉树的深度为<script type="math/tex">k=\log_2(n+1)</script>，比如结点数为15的满二叉树，深度为4。完全二叉树的叶子结点只会出现在最下面的两层。结点数一定少于等于同样深度的满二叉树的结点数<script type="math/tex">2^k-1</script>，但一定多于<script type="math/tex">2^{k-1}-1</script>。即满足<script type="math/tex">2^{k-1}-1<n<= 2^k-1</script>。由于结点数n是整数，<script type="math/tex">n<=2^k-1</script>意味着<script type="math/tex">n<2^k</script>，<script type="math/tex">n>2^{k-1}-1</script>，意味着<script type="math/tex">n>=2^{k-1}</script>，所以<script type="math/tex">2^{k-1}<=n<2^k</script>，不等式两边取对数，得到<script type="math/tex">k-1<=\log_2n<k</script>，而k作为深度也是整数，因此<script type="math/tex">k=|log_2n|+1</script></p>
<h2 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h2><p>具有n个结点的完全二叉树(深度[<script type="math/tex">log_2N]+1</script>)的结点按层序编号(从第1层到第<script type="math/tex">[log_2N]+1</script>层,每层从左到右),对任一结点i(1&lt;=&lt;=n)有:</p>
<ol>
<li>如果i= 1,则结点i是二叉树的根,无双亲;如果i&gt;1,则双亲是结点<script type="math/tex">[\frac{i}{2}]</script></li>
<li>如果2i&gt;n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i</li>
<li>如果2i+1&gt;n,则结点i无右孩子,否则其右孩子是结点2i+1</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-04030db73a6d0925.png?imageMogr2/auto-orient/strip|imageView2/2/w/422" alt></p>
<h1 id="6-6-二叉树的存储结构"><a href="#6-6-二叉树的存储结构" class="headerlink" title="6.6 二叉树的存储结构"></a>6.6 二叉树的存储结构</h1><h2 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h2><p>二叉树的顺序结构是用一维数组存储二叉树中的结点,并且结点的存储位置,也就是数组的下标要能体现结点之间的逻辑关系,比如双亲与孩子的关系,左右兄弟的关系</p>
<p><strong>完全二叉树的存储</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-97ccc7664ad183dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/417" alt></p>
<p>将这棵二叉树存入到数组中,相应的下标对应其同样的位置</p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-9efb4e954ffa3849.png?imageMogr2/auto-orient/strip|imageView2/2/w/552" alt></p>
<p>完全二叉树存入到数组中,相应的下标对应其同样的位置,一般的二叉树层序编号不能反映逻辑关系,但可以将其按<strong>完全二叉树</strong>编号,把不存在的结点设置为<strong>“^”</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-96331e5db062f0e5.png?imageMogr2/auto-orient/strip|imageView2/2/w/550" alt></p>
<p>一种极端的情况,一棵深度为k的右斜树,它只有k个结点,却需要分配<script type="math/tex">2^k-1</script>个存储单元,会造成对空间的极度浪费,所以顺序结构一般<strong>只用于完全二叉树</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-c86f656c2c0f6952.png?imageMogr2/auto-orient/strip|imageView2/2/w/700" alt></p>
<h2 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h2><p>二叉树每个结点最多有两个孩子,设计一个数据域和两个指针域,这样的链表为<strong>二叉链表</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/851071-919f592cedfa2143.png?imageMogr2/auto-orient/strip|imageView2/2/w/506" alt></p>
<p>二叉链表的结点结构定义代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data; <span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>结构示意图如图：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/119import.png" alt></p>
<h1 id="6-7-遍历二叉树"><a href="#6-7-遍历二叉树" class="headerlink" title="6.7 遍历二叉树"></a>6.7 遍历二叉树</h1><p><strong>二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得某个结点被访问一次且仅被访问一次</strong></p>
<p>访问是要根据实际的需要来确定具体做什么，简单地假定访问就是输出结点的数据信息</p>
<h2 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><strong>前序遍历</strong></h3><p>若二叉树为空,则空操作返回,否则</p>
<ol>
<li><strong>先</strong>访问<strong>根</strong>结点</li>
<li>前序遍历<strong>左</strong>子树,</li>
<li>前序遍历<strong>右</strong>子树.</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/120import.png" alt></p>
<blockquote>
<p>遍历的顺序为:ABDGHCEIF</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的前序遍历递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="comment">//若树为空，返回为空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">//显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild); <span class="comment">//再先序遍历左子树</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild); <span class="comment">//最后先序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>若树为空,则空操作返回,否则</p>
<ol>
<li>从根结点开始(注意不是先访问根结点)</li>
<li>中序遍历根结点的左子树,然后是访问根结点</li>
<li>中序遍历右子树</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/121import.png" alt></p>
<blockquote>
<p>遍历的顺序为GDHBAEICF</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的中序遍历递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">//显示结点数据，能够更改为其它对结点操作</span></span><br><span class="line">InOrderTraverse(T-&gt;rchild); <span class="comment">//最后中序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>若树为空,则空操作返回，否则</p>
<ol>
<li>从左到右先叶子后结点的方式遍历访问左右子树</li>
<li>最后是访问根结点.</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/122import.png" alt></p>
<blockquote>
<p>遍历的顺序为:GHDBIEFCA</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的后序遍历递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">PostOrderTraverse(T-&gt;lchild);<span class="comment">//先后序遍历左子树</span></span><br><span class="line">PostOrderTraverse(T-&gt;rchild);<span class="comment">//再后序遍历右子树</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data); <span class="comment">//显示结点数据。能够更改为其它对结点操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>若树为空,则空操作返回，否则</p>
<ol>
<li>从树的第一层,也就是根结点开始访问</li>
<li>从上而下逐层遍历</li>
<li>在同一层中,按从左到右的顺序对结点逐个访问</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/123import.png" alt></p>
<h2 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h2><p>二叉树遍历性质：</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，能够唯一确定一颗二叉树;</li>
<li>已知后序遍历序列和中序遍历序列。能够唯一确定一颗二叉树;</li>
<li>已知前序和后序遍历，不能确定一棵二叉树</li>
</ul>
<h1 id="6-8-二叉树的建立"><a href="#6-8-二叉树的建立" class="headerlink" title="6.8 二叉树的建立"></a>6.8 二叉树的建立</h1><p>对于一颗普通的二叉树，将二叉树中每一个结点的空指针引出一个虚结点，其值为一特定值，比方”#“。处理后的二叉树为原二叉树的扩展二叉树，扩展二叉树能够通过一个”前序”或”中序”或”后序”遍历序列确定一颗二叉树</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png120" alt></p>
<blockquote>
<p>前序遍历序列为AB#D##C##</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按前序输入而二叉树中借点的值(一个字符)*/</span></span><br><span class="line"><span class="comment">/*#表示空树，构造二叉链表表示二叉树T*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBitree</span><span class="params">(Bitree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TElemType ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch); <span class="comment">//输入结点数据字符</span></span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">'#'</span>)</span><br><span class="line">*T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)); <span class="comment">//为数据为字符的结点在内存中分配空间</span></span><br><span class="line"><span class="keyword">if</span>(!*T) <span class="comment">//假设分配未成功则异常结束(内存溢出)</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*T)-&gt;data = ch; <span class="comment">//生成根结点</span></span><br><span class="line">CreateBiTree(&amp;(*T)-&gt;lchild); <span class="comment">//构造左子树</span></span><br><span class="line">CreateBiiTree(&amp;(*T)-&gt;rchild); <span class="comment">//构造右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-9-线索二叉树"><a href="#6-9-线索二叉树" class="headerlink" title="6.9 线索二叉树"></a>6.9 线索二叉树</h1><h2 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h2><p>一个有n个结点的二叉链表。每一个结点有指向左右孩子的两个指针域，一共是2n个指针域。n个结点的二叉树一共同拥有n-1条分支线(根结点无前驱)，存在2n-(n-1)=n+1个空指针域</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/126import.png" alt></p>
<p><strong>将指向前驱和后驱的指针称为线索，加上线索的二叉链表则称为线索链表；加上线索的二叉树称为线索二叉树(Threaded Binary Tree)</strong></p>
<p>中序遍历后，将所有的空指针域中的rchild，改为指向它的后继结点。通过指针知道H的后继是D（①），I的后继是B（②），J的后继是E（③），E的后继是A（④），F的后继是C（⑤），G的后继因为不存在而指向NULL（⑥）。此时共有6个空指针域被利用</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/128import.png" alt></p>
<p>将这棵二叉树的所有空指针域中的lchild，改为指向当前结点的前驱。H的前驱是NULL（①），I的前驱是D（②），J的前驱是B（③），F的前驱是A（④），G的前驱是C（⑤）。一共5个空指针域被利用，正好和上面的后继加起来是11个</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/129import.png" alt></p>
<p>线索二叉树，等于是把一棵二叉树转变成了一个双向链表，对插入删除结点、查找某个结点都带来了方便。</p>
<p><strong>对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/130import.png" alt></p>
<blockquote>
<p>空心箭头实线为前驱，虚线黑箭头为后继</p>
</blockquote>
<p>每个结点再增设两个标志域ltag和rtag，ltag和rtag只是存放0或1数字的布尔型变量，占用的内存空间要小于像lchild和rchild的指针变量</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/132import.png" alt></p>
<ul>
<li>ltag为0时指向该结点的左孩子，为1时指向该结点的前驱</li>
<li>rtag为0时指向该结点的右孩子，为1时指向该结点的后继</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/133import.png" alt></p>
<h2 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h2><p>二叉树的线索存储结构定义代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> eum &#123;Link,Thread&#125; PointerTag; <span class="comment">/*二叉树的二叉线索存储结构定义*/</span></span><br><span class="line"><span class="comment">/*Link==0表示指向左右孩子指针*/</span></span><br><span class="line"><span class="comment">/*Thread==1表示指向前驱或后驱的线索*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> /*二叉线索存储结点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data; <span class="comment">//数据域：结点数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//指针域：左右孩子指针</span></span><br><span class="line">PointerTag LTag;</span><br><span class="line">PointerTag RTag; <span class="comment">//左右标志</span></span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>
<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。因为前驱和后继的信息只有在遍历该二叉树时才干得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong></p>
<p>中序遍历线索化的递归函数代码例如以下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre; <span class="comment">//全局变量。始终指向刚刚訪问过的结点</span></span><br><span class="line"><span class="comment">/*中序遍历进行中序线索化*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BitThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">InThreading(p-&gt;lchild); <span class="comment">//递归左子树线索化</span></span><br><span class="line"><span class="keyword">if</span>(!p-&gt;lchild) <span class="comment">//结点无左孩子</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;LTag=Thread; <span class="comment">//前驱线索：将结点左指针标志置1，说明左指针指向该结点的前驱</span></span><br><span class="line">p-&gt;lchild=pre; <span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!pre-&gt;rchild) <span class="comment">//前驱没有右孩子</span></span><br><span class="line">&#123;</span><br><span class="line">pre-&gt;RTag=Thread; <span class="comment">//后继线索</span></span><br><span class="line">pre-rchild=p; <span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">&#125;</span><br><span class="line">pre=p; <span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">InThreading(p-&gt;rchild); <span class="comment">//递归右子树线索化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码分析：</p>
<p>(1)结点前驱线索化</p>
<p>if(!p-&gt;lchild)表示假设某结点的左指针域为空，由于其前驱节点刚刚訪问过，赋值给了pre，所以能够将pre赋值给p-&gt;lchild。并改动p-&gt;LTag=Thread(也就是定义为1)以完成前驱结点的线索化。</p>
<p>(2)结点后驱线索化</p>
<p>因为该节点还没有訪问到，因此仅仅能对它的前驱结点pre的右指针rchild做推断，if(!pre-&gt;rchild)表示假设为空。则p就是pre的后继，于是pre-&gt;rchild=p，而且设置pre-&gt;RTag=Thread。完毕后继结点的线索化。</p>
<p>(3) pre=p语句的作用是完毕前驱和后继的推断后，将当前的结点p赋值给pre。以便下一次使用</p>
<p>二叉树的二叉线索存储表示（以中序为例）：在线索链表上加入一个头结点，并令其lchild域的指针指向二叉树的根结点（图中的①）。其rchild域的指针指向中序遍历时訪问的最后一个结点（图中的②）。令二叉树中序序列中的第一个结点的lchild域指针和最后一个结点的rchild域的指针均指向头结点（图中的③和④。这样就创建了一个双向线索链表。优点是既能够从第一个结点起顺后继进行遍历。也能够从最后一个结点起顺前驱进行遍历</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/134import.png" alt></p>
<p>遍历的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点*/</span></span><br><span class="line"><span class="comment">/* 中序遍历二叉线索链表表示的二叉树T，时间复杂度为O(n)*/</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiThrTree p;</span><br><span class="line">p=T-&gt;lchild; <span class="comment">//p指向根结点</span></span><br><span class="line"><span class="keyword">while</span>(p != T) <span class="comment">//空树或遍历结束时。p==T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;LTag==Link) <span class="comment">//当LTag==0时循环到中序序列第一个结点</span></span><br><span class="line">p=p-&gt;lchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data); <span class="comment">//显示结点数据，能够更改为其它对结点操作</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild !=T)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;rchild;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;rchild; <span class="comment">//p进至其右子树根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>代码中，第4行，p=T-&gt;lchild;意思就是图6-10-6中的①，让p指向根结点开始遍历。</li>
<li>第5～16行，while(p!=T)其实意思就是循环直到图中的④的出现，此时意味着p指向了头结点，于是与T相等（T是指向头结点的指针），结束循环，否则一直循环下去进行遍历操作。</li>
<li>第7～8行，while(p-&gt;LTag==Link)这个循环，就是由A→B→D→H，此时H结点的LTag不是Link（就是不等于0），所以结束此循环。</li>
<li>第9行，打印H。</li>
<li>第10～14行，while(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)，由于结点H的RTag==Thread（就是等于1），且不是指向头结点。因此打印H的后继D，之后因为D的RTag是Link，因此退出循环。</li>
<li>第15行，p=p-&gt;rchild;意味着p指向了结点D的右孩子I。</li>
<li>.……，就这样不断循环遍历，直到打印出HDIBJEAFCG，结束遍历操作。</li>
</ol>
<p>从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为O(n)</p>
<p>由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，<strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</strong></p>
<h1 id="6-10-树、森林与二叉树的转换"><a href="#6-10-树、森林与二叉树的转换" class="headerlink" title="6.10 树、森林与二叉树的转换"></a>6.10 树、森林与二叉树的转换</h1><h2 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h2><p>将树转换为二叉树的步骤如下</p>
<ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/135import.png" alt></p>
<p>F、G本都是树结点B的孩子，是结点E的兄弟，转换后，F就是二叉树结点E的右孩子，G是二叉树结点F的右孩子</p>
<h2 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h2><p>森林是由若干棵树组成的，可以理解为森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作：</p>
<ol>
<li>把每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/136import.png" alt></p>
<h2 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h2><p>二叉树转换为树是树转换为二叉树的逆过程步骤如下：</p>
<ol>
<li>加线。若某结点的左孩子结点存在，则将这个左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/137import.png" alt></p>
<h2 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h2><p>判断一棵二叉树能够转换成一棵树还是森林，看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。</p>
<p>步骤如下：</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每棵分离后的二叉树转换为树即可</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/138import.png" alt></p>
<h2 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h2><p>树的遍历分为两种方式：</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/141import.png" alt></p>
<blockquote>
<p>右下方的树先根遍历序列为ABEFCDG，后根遍历序列为EFBCGDA</p>
</blockquote>
<p>森林的遍历也分为两种方式：</p>
<ol>
<li>前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。比如下面三棵树的森林，前序遍历序列的结果就是ABCDEFGHJI。</li>
<li>后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。比如下面三棵树的森林，后序遍历序列的结果就是BCDAFEJHIG</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/140import.png" alt></p>
<p>森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/142import.png" alt></p>
<p>当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现</p>
<h1 id="6-11-赫夫曼树及其应用"><a href="#6-11-赫夫曼树及其应用" class="headerlink" title="6.11 赫夫曼树及其应用"></a>6.11 赫夫曼树及其应用</h1><h2 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h2><p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度</strong></p>
<p><strong>树的路径长度就是从树根到每一结点的路径长度之和</strong>。</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/143import.png" alt></p>
<blockquote>
<p>二叉树a中，根结点到结点D的路径长度就为4，二叉树b中根结点到结点D的路径长度为2。二叉树a的树路径长度就为1+1+2+2+3+3+4+4=20。二叉树b的树路径长度就为1+2+3+3+2+1+2+2=16</p>
</blockquote>
<p>如果考虑到带权的结点，<strong>结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和</strong>。假设有<script type="math/tex">n</script>个权值<script type="math/tex">{w_1,w_2,...,w_n}</script>，构造一棵有<script type="math/tex">n</script>个叶子结点的二叉树，每个叶子结点带权<script type="math/tex">w_k</script>，每个叶子的路径长度为<script type="math/tex">l_k</script>，则其中带权路径长度<script type="math/tex">WPL</script>最小的二叉树称做<strong>赫夫曼树(最优二叉树)</strong></p>
<p>二叉树<script type="math/tex">a</script>的<script type="math/tex">WPL=5\times1+15\times2+40\times3+30\times4+10\times4=315</script></p>
<p>二叉树<script type="math/tex">b</script>的<script type="math/tex">WPL=5\times3+15\times3+40\times2+30\times2+10\times2=220</script></p>
<p>构造赫夫曼树：</p>
<ol>
<li>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A5，E10，B15，D30，C40。</li>
<li>取头两个最小权值的结点作为一个新节点<script type="math/tex">N_1</script>的两个子结点，相对较小的是左孩子，这里就是A为<script type="math/tex">N_1</script>的左孩子，E为<script type="math/tex">N_1</script>的右孩子，新结点的权值为两个叶子权值的和5+10=15<img src="https://baozou.gitbooks.io/-data-structure/content/assets/145import.png" alt></li>
<li>将<script type="math/tex">N_1</script>替换A与E，插入有序序列中，保持从小到大排列。即：<script type="math/tex">N_1</script>15，B15，D30，C40。</li>
<li>重复步骤2。将<script type="math/tex">N_1</script>与B作为一个新节点<script type="math/tex">N_2</script>的两个子结点。<script type="math/tex">N_2</script>的权值=15+15=30<img src="https://baozou.gitbooks.io/-data-structure/content/assets/146import.png" alt></li>
<li>将<script type="math/tex">N_2</script>替换<script type="math/tex">N_1</script>与B，插入有序序列中，保持从小到大排列。即：<script type="math/tex">N_2</script>30，D30，C40。</li>
<li>重复步骤2。将<script type="math/tex">N_2</script>与D作为一个新节点<script type="math/tex">N_3</script>的两个子结点。<script type="math/tex">N_3</script>的权值=30+30=60<img src="https://baozou.gitbooks.io/-data-structure/content/assets/147import.png" alt></li>
<li>将<script type="math/tex">N_3</script>替换<script type="math/tex">N_2</script>与D，插入有序序列中，保持从小到大排列。即：C40，<script type="math/tex">N_3</script>60。</li>
<li>重复步骤2。将C与<script type="math/tex">N_3</script>作为一个新节点T的两个子结点，由于T即是根结点，完成赫夫曼树的构造<img src="https://baozou.gitbooks.io/-data-structure/content/assets/148import.png" alt></li>
</ol>
<blockquote>
<p>带权路径长度WPL=40×1+30×2+15×3+10×4+5×4=205</p>
</blockquote>
<p>构造赫夫曼树的赫夫曼算法描述：</p>
<ol>
<li>根据给定的n个权值<script type="math/tex">{w1,w2,\cdots,w_n}</script>构成<script type="math/tex">n</script>棵二叉树的集合<script type="math/tex">F={T_1,T_2,\cdots,T_n}</script>，其中每棵二叉树<script type="math/tex">T_i</script>中只有一个带权为<script type="math/tex">w_i</script>根结点，其左右子树均为空。</li>
<li>在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li>
<li>重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树</li>
</ol>
<h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h2><p>传输文字内容为“BADCADFEED”，相应的二进制数据表示如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制字符</td>
<td style="text-align:center">000</td>
<td style="text-align:center">001</td>
<td style="text-align:center">010</td>
<td style="text-align:center">011</td>
<td style="text-align:center">100</td>
<td style="text-align:center">101</td>
</tr>
</tbody>
</table>
</div>
<p>真正传输的数据就是编码后的“001000011010000011101100100011”</p>
<p>假设六个字母的频率为A 27，B 8，C 15，D15，E 30，F 5，合起来正好是100%。完全可以重新按照赫夫曼树来规划它们</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/149import.png" alt></p>
<blockquote>
<p>左图为构造赫夫曼树过程的权值显示。右图为将权值左分支改为0，右分支改为1的赫夫曼树</p>
</blockquote>
<p>对这六个字母用其从树根到叶子所经过路径的0或1来编码，可以得到如表所示这样的定义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二进制字符</td>
<td style="text-align:center">01</td>
<td style="text-align:center">1001</td>
<td style="text-align:center">101</td>
<td style="text-align:center">00</td>
<td style="text-align:center">11</td>
<td style="text-align:center">1000</td>
</tr>
</tbody>
</table>
</div>
<p>将文字内容为“BADCADFEED”再次编码，对比可以看到结果串变小了。</p>
<p>原编码二进制串：001000011010000011101100100011（共30个字符）</p>
<p>新编码二进制串：1001010010101001000111100（共25个字符）</p>
<p>数据被压缩了，节约了大约17%的存储或传输成本。随着字符的增加和多字符权重的不同，这种压缩会更加显出其优势</p>
<p><strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码</strong></p>
<p>在解码时，还要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则</p>
<p>设需要编码的字符集为<script type="math/tex">{d_1,d_2,\cdots,d_n}</script>，各个字符在电文中出现的次数或频率集合为<script type="math/tex">{w_1,w_2,\cdots,w_n}</script>，以<script type="math/tex">d_1,d_2,\cdots,d_n</script>作为叶子结点，以<script type="math/tex">w_1,w_2,\cdots,w_n</script>作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码</p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第八章  查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第八章  查找/" itemprop="url">大话数据结构 第八章  查找</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:47:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:51:03Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第八章  查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第八章  查找/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第八章  查找/" class="leancloud_visitors" data-flag-title="大话数据结构 第八章  查找">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="8-1-查找概论"><a href="#8-1-查找概论" class="headerlink" title="8.1 查找概论"></a>8.1 查找概论</h1><p><strong>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合</strong></p>
<p><strong>关键字（Key）是数据元素中某个数据项的值，又称为键值</strong>，可以标识一个数据元素，也可以标识一个记录的某个数据项（字段），称为关键码，如①和②</p>
<p><strong>若关键字可以唯一地标识一个记录，称此关键字为主关键字（Primary Key）</strong>。意味着对不同的记录其主关键字均不相同。主关键字所在的数据项称为主关键码，如③和④</p>
<p><strong>可以识别多个数据元素（或记录）的关键字，称为次关键字（SecondaryKey）</strong>，如⑤。可以理解为是不以唯一标识一个数据元素（或记录）的关键字，对应的数据项就是次关键码</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/400import.png" alt></p>
<p><strong>查找（Searching）是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）</strong></p>
<p>若表中存在这样的一个记录，则称查找是成功的，此时查找的结果给出整个记录的信息，或指示该记录在查找表中的位置。比如查找主关键码“<strong>代码</strong>”的主关键字为“sh601398”的记录时，得到第2条唯一记录。查找次关键码“涨跌额”为“<strong>-0.11</strong>”的记录时，得到两条记录</p>
<p>若表中不存在关键字等于给定值的记录，称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针</p>
<p>查找表按照操作方式来分有两大种：</p>
<ul>
<li><strong>静态查找表（Static Search Table）</strong>：只作查找操作的查找表</li>
</ul>
<p>主要操作：</p>
<ol>
<li>查询某个“特定的”数据元素是否在查找表中</li>
<li><p>检索某个“特定的”数据元素和各种属性</p>
</li>
<li><p><strong>动态查找表（Dynamic Search Table）</strong>：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</p>
</li>
</ol>
<p>主要操作：</p>
<ol>
<li>查找时插入数据元素</li>
<li>查找时删除数据元素</li>
</ol>
<p>面向查找操作的数据结构称为查找结构</p>
<h1 id="8-2-顺序表查找"><a href="#8-2-顺序表查找" class="headerlink" title="8.2 顺序表查找"></a>8.2 顺序表查找</h1><p><strong>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术</strong></p>
<p>查找过程是：</p>
<ol>
<li>从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较</li>
<li>若某个记录的关键字和给定值相等，则查找成功，找到所查的记录</li>
<li>如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</li>
</ol>
<h2 id="顺序表查找算法"><a href="#顺序表查找算法" class="headerlink" title="顺序表查找算法"></a>顺序表查找算法</h2><p>顺序查找的算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 顺序查找，a为数组，n为要查找的数组长度， key为要查找的关键字 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (a[i] == key)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表查找优化"><a href="#顺序表查找优化" class="headerlink" title="顺序表查找优化"></a>顺序表查找优化</h2><p>设置一个哨兵，可以解决不需要每次让i与n作比较</p>
<p>改进后的顺序查找算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">/* 设置a[0]为关键字值，我们称之为“哨兵” */</span></span><br><span class="line">a[<span class="number">0</span>] = key;</span><br><span class="line"><span class="comment">/* 循环从数组尾部开始 */</span></span><br><span class="line">i = n;</span><br><span class="line"><span class="keyword">while</span> (a[i] != key)</span><br><span class="line">i--;</span><br><span class="line"><span class="comment">/* 返回0则说明查找失败 */</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码是从尾部开始查找，由于a[0]=key，如果在a[i]中有key则返回i值，查找成功。否则一定在最终的a[0]处等于key，此时返回的是0，即说明a[1]～a[n]中没有关键字key，查找失败</p>
<p>时间复杂度为<script type="math/tex">O(n)</script></p>
<p>顺序查找技术n很大时，查找效率极为低下，不过优点是算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。</p>
<p>由于查找概率的不同，将容易查找到的记录放在前面，不常用的记录放置在后面，效率可以大幅提高</p>
<h1 id="8-3-有序表查找"><a href="#8-3-有序表查找" class="headerlink" title="8.3 有序表查找"></a>8.3 有序表查找</h1><p><strong>折半查找（Binary Search）技术，又称为二分查找。前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。</strong></p>
<p><strong>折半查找的基本思想：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</strong></p>
<p>有序表数组{0,1,16,24,35,47,59,62,73,88,99}，除0下标外共10个数字。对它进行查找是否存在62这个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low, high, mid;</span><br><span class="line"><span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">low = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">high = n;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 折半 */</span></span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 若查找值比中值小 */</span></span><br><span class="line"><span class="keyword">if</span> (key &lt; a[mid])</span><br><span class="line"><span class="comment">/* 最高下标调整到中位下标小一位 */</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 若查找值比中值大 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])</span><br><span class="line"><span class="comment">/* 最低下标调整到中位下标大一位 */</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个数组的查找过程绘制成一棵二叉树，如果查找的关键字不是中间记录47的话，折半查找等于是把静态有序查找表分成了两棵子树，即查找结果只需要找其中的一半数据记录即可，等于工作量少了一半，然后继续折半查找</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/200import.png" alt></p>
<p>折半算法的时间复杂度为<script type="math/tex">O(\log n)</script></p>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>折半查找代码改进为：</p>
<script type="math/tex; mode=display">
mid =low +\frac{key-a[low]}{a[high]-a[low]}(high - low)</script><p>假设a[11]={0,1,16,24,35,47,59,62,73,88,99}，low=1，high=10，则a[low]=1，a[high]=99，如果要找的是key=16时，按原来折半的做法，需要四次才可以得到结果，如果用新办法，<script type="math/tex">\frac{key-a[low]}{a[high]-a[low]}</script>=(16-1)/(99-1)≈0.153，即mid≈1+0.153×(10-1)=2.377取整得到mid=2，只需要二次就查找到结果</p>
<p>折半查找算法的代码中更改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br></pre></td></tr></table></figure>
<p>得到了另一种有序表查找算法，插值查找法</p>
<p><strong>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法</strong>，其核心就在于插值的计算公式<script type="math/tex">\frac{key-a[low]}{a[high]-a[low]}</script>。时间复杂度是<script type="math/tex">O(\log n)</script>，对于表长较大，关键字分布又比较均匀的查找表，插值查找算法的平均性能比折半查找要好得多</p>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span> <span class="comment">/* 斐波那契查找 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low,high,mid,i,k;</span><br><span class="line">low=<span class="number">1</span>; <span class="comment">/* 定义最低下标为记录首位 */</span></span><br><span class="line">high=n; <span class="comment">/* 定义最高下标为记录末位 */</span></span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>) <span class="comment">/* 计算n位于斐波那契数列的位置 */</span></span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++) <span class="comment">/* 将不满的数值补全 */</span></span><br><span class="line">a[i]=a[n];</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">&#123;</span><br><span class="line">mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>; <span class="comment">/* 计算当前分隔的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (key&lt;a[mid]) <span class="comment">/* 若查找记录小于当前分隔记录 */</span></span><br><span class="line">&#123;</span><br><span class="line">high=mid<span class="number">-1</span>; <span class="comment">/* 最高下标调整到分隔下标mid-1处 */</span></span><br><span class="line">k=k<span class="number">-1</span>; <span class="comment">/* 斐波那契数列下标减一位 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid]) <span class="comment">/* 若查找记录大于当前分隔记录 */</span></span><br><span class="line">&#123;</span><br><span class="line">low=mid+<span class="number">1</span>; <span class="comment">/* 最低下标调整到分隔下标mid+1处 */</span></span><br><span class="line">k=k<span class="number">-2</span>; <span class="comment">/* 斐波那契数列下标减两位 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line"><span class="keyword">return</span> mid; <span class="comment">/* 若相等则说明mid即为查找到的位置 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> n; <span class="comment">/* 若mid&gt;n说明是补全数值，返回n */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始运行，参数a={0,1,16,24,35,47,59,62,73,88,99}，n=10，要查找的关键字key=59。斐波那契数列F={0,1,1,2,3,5,8,13,21,……}<img src="https://baozou.gitbooks.io/-data-structure/content/assets/180import.png" alt></li>
<li>第6～8行是计算当前的n处于斐波那契数列的位置。现在n=10，F[6]&lt;n&lt;F[7]，所以计算得出k=7</li>
<li>第9～10行，由于k=7，计算时是以F[7]=13为基础，而a中最大的仅是a[10]，后面的a[11]，a[12]均未赋值，这不能构成有序数列，因此将它们都赋值为最大的数组值，所以此时a[11]=a[12]=a[10]=99</li>
<li>第13行，mid=1＋F[7-1]-1=8，第一个要对比的数值从下标为8开始</li>
<li>由于此时key=59而a[8]=73，因此执行第16～17行，得到high=7，k=6<img src="https://baozou.gitbooks.io/-data-structure/content/assets/161import.png" alt></li>
<li>再次循环，mid=1＋F[6-1]-1=5。此时a[5]=47&lt;key，因此执行第21～22行，得到low=6，k=6-2=4。注意此时k下调2个单位<img src="https://baozou.gitbooks.io/-data-structure/content/assets/162import.png" alt></li>
<li>再次循环，mid=6＋F[4-1]-1=7。此时a[7]=62&gt;key，因此执行第16～17行，得到high=6，k=4-1=3<img src="https://baozou.gitbooks.io/-data-structure/content/assets/163import.png" alt></li>
<li>再次循环，mid=6＋F[3-1]-1=6。此时a[6]=59=key，因此执行第26～27行，得到返回值为6。程序运行结束</li>
</ol>
<p>如果key=99，此时查找循环第一次时，mid=8与上例是相同的，第二次循环时，mid=11，如果a[11]没有值就会使得与key的比较失败，为了避免这样的情况出现，第9～10行的代码就起到这样的作用</p>
<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当key=a[mid]时，查找就成功</li>
<li>当key&lt;a[mid]时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个</li>
<li>当key&gt;a[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/164import.png" alt></p>
<p>时间复杂度为<script type="math/tex">O(\log n)</script>，就平均性能来说，斐波那契查找要优于折半查找。如果是最坏情况，比如这里key=1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找</p>
<p>折半查找是进行加法与除法运算</p>
<script type="math/tex; mode=display">
mid=\frac{low+high}{2}</script><p>插值查找进行复杂的四则运算</p>
<script type="math/tex; mode=display">
mid =low +\frac{key-a[low]}{a[high]-a[low]}(high - low)</script><p>斐波那契查找是最简单加减法运算</p>
<script type="math/tex; mode=display">
mid=low+F[k-1]-1</script><p>在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。三种有序表的查找本质上是分隔点的选择不同，各有优劣</p>
<h1 id="8-4-线性索引查找"><a href="#8-4-线性索引查找" class="headerlink" title="8.4 线性索引查找"></a>8.4 线性索引查找</h1><p><strong>索引是把一个关键字与它对应的记录相关联的过程</strong>，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息</p>
<p><strong>线性索引是将索引项集合组织为线性结构，也称为索引表</strong></p>
<h2 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h2><p><strong>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/165import.png" alt></p>
<p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong></p>
<h2 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h2><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p>
<ul>
<li>块内无序，即每一块内的记录不要求有序</li>
<li>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……只有块间有序，才有可能在查找时带来效率</li>
</ul>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引</p>
<p>分块索引的索引项结构分三个数据项：</p>
<ul>
<li>最大关键码，存储每一块中的最大关键字，使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>
<li>存储了块中的记录个数，以便于循环时使用</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/166import.png" alt></p>
<p>在分块索引表中查找，分两步进行：</p>
<ol>
<li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，很容易利用折半、插值等算法得到结果。上图的数据集中查找62，由57&lt;62&lt;96得到62在第三个块中</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找</li>
</ol>
<p>分块索引的平均查找长度：</p>
<p>设n个记录的数据集被平均分成m块，每个块中有t条记录，显然n=m×t（m=n/t）。<script type="math/tex">L_b</script>为查找索引表的平均查找长度，因最好与最差的等概率原则，所以<script type="math/tex">L_b</script>的平均长度为<script type="math/tex">\frac{m+1}{2}</script>。<script type="math/tex">L_w</script>为块中查找记录的平均查找长度，同理可知平均查找长度为<script type="math/tex">\frac{t+1}{2}</script>。这样分块索引查找的平均查找长度为：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/167import.png" alt></p>
<p>最佳的情况就是分的块数m与块中的记录数t相同，此时意味着<script type="math/tex">n=m\times t=t^2</script>，即：</p>
<h1 id><a href="#" class="headerlink" title="#"></a>#</h1><script type="math/tex; mode=display">
ASL_w=\frac{1}{2}\times(\frac{n}{t}+t)+1=t+1=\sqrt n+1</script><p>倒排索引</p>
<p>索引项的通用结构是：</p>
<ul>
<li><strong>次关键码</strong>，如“英文单词”</li>
<li><strong>记录号表</strong>，如“文章编号”</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/168import.png" alt></p>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（in-verted index）。倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引</p>
<h1 id="8-5-二叉排序树"><a href="#8-5-二叉排序树" class="headerlink" title="8.5 二叉排序树"></a>8.5 二叉排序树</h1><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/169import.png" alt></p>
<p>对集合{62,88,58,47,35,73,51,99,37,93}做查找，用二叉树结构排好序的二叉树来创建：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/170import.png" alt></p>
<p>进行中序遍历时，得到一个有序的序列{35,37,47,51,58,62,73,88,93,99}，称它为<strong>二叉排序树</strong></p>
<p><strong>二叉排序树（Binary Sort Tree），又称为二叉查找树</strong>。它或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>左、右子树也分别为二叉排序树</li>
</ul>
<h2 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h2><p>二叉树的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data; <span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>二叉排序树的查找实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 递归查找二叉排序树T中是否存在key, */</span></span><br><span class="line"><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span></span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span></span><br><span class="line"><span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!T) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">&#123;</span><br><span class="line">*p = f;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key==T-&gt;data) <span class="comment">/* 查找成功 */</span></span><br><span class="line">&#123;</span><br><span class="line">*p = T;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data)</span><br><span class="line"><span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p); <span class="comment">/* 在左子树中继续查找 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p); <span class="comment">/* 在右子树中继续查找 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数调用时的语句为SearchBST(T,93,NULL,p)，参数T是一个二叉链表，数据如图，key代表要查找的关键字，打算查找93，二叉树f指向T的双亲，当T指向根结点时，f的初值为NULL，它在递归时有用，最后的参数p是为了查找成功后可以得到查找到的结点位置</li>
<li>第7～11行，判断当前二叉树是否到叶子结点，下图当前T指向根结点62的位置，T不为空，第9～10行不执行<img src="https://baozou.gitbooks.io/-data-structure/content/assets/174import.png" alt></li>
<li>第12～16行是查找到相匹配的关键字时执行语句，显然93≠62，第14～15行不执行</li>
<li>第17～18行是当要查找关键字小于当前结点值时执行语句，由于93&gt;62，第18行不执行</li>
<li>第19～20行是当要查找关键字大于当前结点值时执行语句，由于93&gt;62，所以递归调用SearchBST(T-&gt;rchild,key,T,p)。此时T指向了62的右孩子88<img src="https://baozou.gitbooks.io/-data-structure/content/assets/175import.png" alt></li>
<li>此时第二层SearchBST，因93比88大，执行第20行，再次递归调用SearchBST(T-&gt;rchild,key,T,p)。此时T指向了88的右孩子99<img src="https://baozou.gitbooks.io/-data-structure/content/assets/176import.png" alt></li>
<li>第三层的SearchBST，因93比99小，所以执行第18行，递归调用SearchBST(T-&gt;lchild,key,T,p)。此时T指向了99的左孩子93<img src="https://baozou.gitbooks.io/-data-structure/content/assets/178import.png" alt></li>
<li>第四层SearchBST，因key等于T-&gt;data，所以执行第14～15行，此时指针p指向93所在的结点，并返回True到第三层、第二层、第一层，最终函数返回True</li>
</ol>
<h2 id="二叉排序树插入操作"><a href="#二叉排序树插入操作" class="headerlink" title="二叉排序树插入操作"></a>二叉排序树插入操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当二叉排序树T中不存在关键字等于key的数据元素时， */</span></span><br><span class="line"><span class="comment">/* 插入key并返回TRUE，否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree p,s;</span><br><span class="line"><span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) <span class="comment">/* 查找不成功 */</span></span><br><span class="line">&#123;</span><br><span class="line">s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">s-&gt;data = key;</span><br><span class="line">s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line">*T = s; <span class="comment">/* 插入s为新的根结点 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&lt;p-&gt;data)</span><br><span class="line">p-&gt;lchild = s; <span class="comment">/* 插入s为左孩子 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p-&gt;rchild = s; <span class="comment">/* 插入s为右孩子 */</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE; <span class="comment">/* 树中已有关键字相同的结点，不再插入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数是“InsertBST(&amp;T,93);”，那么结果就是FALSE，如果是“InsertBST(&amp;T,95);”，那么一定就是在93的结点增加一个右孩子95，并且返回True</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/179import.png" alt></p>
<p>实现二叉排序树的构建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span> &#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">InsertBST(&amp;T, a[i]);</span><br></pre></td></tr></table></figure>
<h2 id="二叉排序树删除操作"><a href="#二叉排序树删除操作" class="headerlink" title="二叉排序树删除操作"></a>二叉排序树删除操作</h2><p>如果需要查找并删除如37、51、73、93这些在二叉排序树中是叶子的结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/182import.png" alt></p>
<p>删除的结点只有左子树或只有右子树的情况，就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/183import.png" alt></p>
<blockquote>
<p>先删除35和99结点，再删除58结点</p>
</blockquote>
<p>要删除的结点既有左子树又有右子树的情况：</p>
<p>找到需要删除的结点p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除此结点s，若要删除47，即对二叉排序树进行中序遍历，得到的序列{29,35,36,37,47,48,49,50,51,56,58,62,73,88,93,99}，37和48正好是47的前驱和后继</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/181import.png" alt></p>
<p>删除结点三种情况的分析：</p>
<ul>
<li>叶子结点</li>
<li>仅有左或右子树的结点</li>
<li>左右子树都有的结点</li>
</ul>
<p>递归方式对二叉排序树T查找key，查找到时删除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span></span><br><span class="line"><span class="comment">/* 并返回TRUE；否则返回FALSE。 */</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key==(*T)-&gt;data) <span class="comment">/* 找到关键字等于key的数据元素 */</span></span><br><span class="line"><span class="keyword">return</span> Delete(T);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&lt;(*T)-&gt;data)</span><br><span class="line"><span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree q,s;</span><br><span class="line"><span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; *p=(*p)-&gt;lchild; <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">/* 只需重接它的右子树 */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; *p=(*p)-&gt;rchild; <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; s=(*p)-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span></span><br><span class="line">&#123;</span><br><span class="line">q=s; s=s-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">(*p)-&gt;data=s-&gt;data; <span class="comment">/* s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span></span><br><span class="line"><span class="keyword">if</span>(q!=*p)</span><br><span class="line">q-&gt;rchild=s-&gt;lchild; <span class="comment">/* 重接q的右子树 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">q-&gt;lchild=s-&gt;lchild; <span class="comment">/* 重接q的左子树 */</span></span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始执行，代码第5～8行目的是为了删除没有右子树只有左子树的结点。此时只需将此结点的左孩子替换它自己，然后释放此结点内存，就等于删除了。</li>
<li>代码第9～12行处理只有右子树没有左子树的结点删除问题</li>
<li>第13～26行处理复杂的左右子树均存在的问题</li>
<li>第15行，将要删除的结点p赋值给临时的变量q，再将p的左孩子p-&gt;lchild赋值给临时的变量s。此时q指向47结点，s指向35结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/191import.png" alt></li>
<li>第16～19行，循环找到左子树的右结点，直到右侧尽头。让q指向35，而s指向了37这个再没有右子树的结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/193import.png" alt></li>
<li>第20行，此时让要删除的结点p的位置的数据被赋值为s-&gt;data，即让p-&gt;data=37<img src="https://baozou.gitbooks.io/-data-structure/content/assets/194import.png" alt></li>
<li>第21～24行，如果p和q指向不同，则将s-&gt;lchild赋值给q-&gt;rchild，否则就是将s-&gt;lchild赋值给q-&gt;lchild。显然这个例子p不等于q，将s-&gt;lchild指向的36赋值给q-&gt;rchild，也就是让q-&gt;rchild指向36结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/195import.png" alt></li>
<li>第25行，free(s)，将37结点删除<img src="https://baozou.gitbooks.io/-data-structure/content/assets/196import.png" alt></li>
</ol>
<h2 id="二叉排序树总结"><a href="#二叉排序树总结" class="headerlink" title="二叉排序树总结"></a>二叉排序树总结</h2><p>二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可</p>
<p>对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。最少为1次，即根结点就是要找的结点，最多不超过树的深度</p>
<h1 id="8-6-平衡二叉树（AVL树）"><a href="#8-6-平衡二叉树（AVL树）" class="headerlink" title="8.6 平衡二叉树（AVL树）"></a>8.6 平衡二叉树（AVL树）</h1><p><strong>平衡二叉树（Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</strong></p>
<p>高度平衡的二叉排序树：</p>
<ul>
<li>要么它是一棵空树</li>
<li>要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1</li>
</ul>
<p><strong>二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）</strong>，平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的</p>
<p>当新插入结点37时，距离它最近的平衡因子绝对值超过1的结点是58（即它的左子树高度3减去右子树高度1），所以从58开始以下的子树为最小不平衡子树</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/197import.png" alt></p>
<h2 id="平衡二叉树实现原理"><a href="#平衡二叉树实现原理" class="headerlink" title="平衡二叉树实现原理"></a>平衡二叉树实现原理</h2><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树</p>
<p>对数组a[10]={3,2,1,4,5,6,7,10,9,8}构建平衡二叉树：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/198import.png" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/199import.png" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/201import.png" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/202import.png" alt></p>
<p>当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋，如上例中结点1、5、6、7的插入等。插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作，如上例中结点9、8的插入时</p>
<h2 id="平衡二叉树实现算法"><a href="#平衡二叉树实现算法" class="headerlink" title="平衡二叉树实现算法"></a>平衡二叉树实现算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data; <span class="comment">/* 结点数据 */</span></span><br><span class="line"><span class="keyword">int</span> bf; <span class="comment">/* 结点的平衡因子 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>对于右旋操作，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对以p为根的二叉排序树作右旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree L;</span><br><span class="line">L=(*P)-&gt;lchild; <span class="comment">/* L指向P的左子树根结点 */</span></span><br><span class="line">(*P)-&gt;lchild=L-&gt;rchild; <span class="comment">/* L的右子树挂接为P的左子树 */</span></span><br><span class="line">L-&gt;rchild=(*P);</span><br><span class="line">*P=L; <span class="comment">/* P指向新的根结点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数代码的意思是当传入一个二叉排序树P，将它的左孩子结点定义为L，将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P成为根结点。这样就完成了一次右旋操作，如图。图中三角形代表子树，N代表新增结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/203import.png" alt></p>
<p>左旋操作代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对以P为根的二叉排序树作左旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree R;</span><br><span class="line">R=(*P)-&gt;rchild; <span class="comment">/* R指向P的右子树根结点 */</span></span><br><span class="line">(*P)-&gt;rchild=R-&gt;lchild; <span class="comment">/* R的左子树挂接为P的右子树 */</span></span><br><span class="line">R-&gt;lchild=(*P);</span><br><span class="line">*P=R; <span class="comment">/* P指向新的根结点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左平衡旋转处理的函数代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">/* 左高 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0 <span class="comment">/* 等高 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">/* 右高 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对以指针T所指结点为根的二叉树作左平衡旋转处理 */</span></span><br><span class="line"><span class="comment">/* 本算法结束时，指针T指向新的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree L,Lr;</span><br><span class="line">L=(*T)-&gt;lchild; <span class="comment">/* L指向T的左子树根结点 */</span></span><br><span class="line"><span class="keyword">switch</span>(L-&gt;bf)</span><br><span class="line">&#123; <span class="comment">/* 检查T的左子树的平衡度，并作相应平衡处理 */</span></span><br><span class="line"><span class="keyword">case</span> LH: <span class="comment">/* 新结点插入在T的左孩子的左子树上，要作单右旋处理 */</span></span><br><span class="line">(*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">R_Rotate(T);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RH: <span class="comment">/* 新结点插入在T的左孩子的右子树上，要作双旋处理 */</span></span><br><span class="line">Lr=L-&gt;rchild; <span class="comment">/* Lr指向T的左孩子的右子树根 */</span></span><br><span class="line"><span class="keyword">switch</span>(Lr-&gt;bf)</span><br><span class="line">&#123; <span class="comment">/* 修改T及其左孩子的平衡因子 */</span></span><br><span class="line"><span class="keyword">case</span> LH: (*T)-&gt;bf=RH;</span><br><span class="line">L-&gt;bf=EH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EH: (*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RH: (*T)-&gt;bf=EH;</span><br><span class="line">L-&gt;bf=LH;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Lr-&gt;bf=EH;</span><br><span class="line">L_Rotate(&amp;(*T)-&gt;lchild); <span class="comment">/* 对T的左子树作左旋平衡处理 */</span></span><br><span class="line">R_Rotate(T); <span class="comment">/* 对T作右旋平衡处理 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数被调用，传入一个需调整平衡性的子树T。由于LeftBalance函数被调用时，已经确认当前子树是不平衡状态，且左子树的高度大于右子树的高度。此时T的根结点平衡因子BF的值是大于1</li>
<li>当L的平衡因子为LH，即为1时，表明它与根结点的BF值符号相同，第14行，将它们的BF值都改为0，第15行，进行右旋操作<img src="https://baozou.gitbooks.io/-data-structure/content/assets/205import.png" alt></li>
<li>当L的平衡因子为RH，即为-1时，表明它与根结点的BF值符号相反，此时需要做双旋处理。第19～28行，针对L的右孩子Lr的BF作判断，修改根结点T和L的BF值</li>
<li>第31行，对根结点的左子树进行左旋，如第二图所示</li>
<li>第32行，对根结点进行右旋，如第三图所示，完成平衡操作<img src="https://baozou.gitbooks.io/-data-structure/content/assets/204import.png" alt></li>
</ol>
<p>主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */</span></span><br><span class="line"><span class="comment">/* 数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */</span></span><br><span class="line"><span class="comment">/* 失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BiTree *T,<span class="keyword">int</span> e,Status *taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!*T)</span><br><span class="line">&#123; <span class="comment">/* 插入新结点，树“长高”，置taller为TRUE */</span></span><br><span class="line">*T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">(*T)-&gt;data=e;</span><br><span class="line">(*T)-&gt;lchild=(*T)-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">(*T)-&gt;bf=EH;</span><br><span class="line">*taller=TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (e==(*T)-&gt;data)</span><br><span class="line">&#123; <span class="comment">/* 树中已存在和e有相同关键字的结点则不再插入 */</span></span><br><span class="line">*taller=FALSE;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e&lt;(*T)-&gt;data)</span><br><span class="line">&#123; <span class="comment">/* 应继续在T的左子树中进行搜索 */</span></span><br><span class="line"><span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) <span class="comment">/* 未插入 */</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">if</span>(taller) <span class="comment">/* 已插入到T的左子树中且左子树“长高” */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/* 检查T的平衡度 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> LH: <span class="comment">/* 原本左子树比右子树高，需要作左平衡处理 */</span></span><br><span class="line">LeftBalance(T);</span><br><span class="line">*taller=FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EH: <span class="comment">/* 原本左、右子树等高，现因左子树增高而使树增高 */</span></span><br><span class="line">(*T)-&gt;bf=LH;</span><br><span class="line">*taller=TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RH: <span class="comment">/* 原本右子树比左子树高，现左、右子树等高 */</span></span><br><span class="line">(*T)-&gt;bf=EH;</span><br><span class="line">*taller=FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; <span class="comment">/* 应继续在T的右子树中进行搜索 */</span></span><br><span class="line"><span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) <span class="comment">/* 未插入 */</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">if</span>(*taller) <span class="comment">/* 已插入到T的右子树且右子树“长高” */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/* 检查T的平衡度 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> LH: <span class="comment">/* 原本左子树比右子树高，现左、右子树等高 */</span></span><br><span class="line">(*T)-&gt;bf=EH;</span><br><span class="line">*taller=FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EH: <span class="comment">/* 原本左、右子树等高，现因右子树增高而使树增高 */</span></span><br><span class="line">(*T)-&gt;bf=RH;</span><br><span class="line">*taller=TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RH: <span class="comment">/* 原本右子树比左子树高，需要作右平衡处理 */</span></span><br><span class="line">RightBalance(T);</span><br><span class="line">*taller=FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第6～13行是指当前T为空时，则申请内存新增一个结点</li>
<li>第16～20行表示当存在相同结点，则不需要插入</li>
<li>第21～43行，当新结点e小于T的根结点值时，则在T的左子树查找</li>
<li>第23～24行，递归调用本函数，直到找到则返回false，否则说明插入结点成功，执行下面语句</li>
<li>第25～42行，当taller为TRUE时，说明插入了结点，此时需要判断T的平衡因子，如果是1，说明左子树高于右子树，需要调用LeftBalance函数进行左平衡旋转处理。如果为0或-1，则说明新插入结点没有让整棵二叉排序树失去平衡性，只需要修改相关的BF值即可</li>
<li>第44～66行，说明新结点e大于T的根结点的值，在T的右子树查找</li>
</ol>
<p>只需要在构建平衡二叉树的时候执行如下列代码即可在内存中生成一棵下图的平衡二叉树：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">BiTree T=<span class="literal">NULL</span>;</span><br><span class="line">Status taller;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找时间复杂度为<script type="math/tex">O(\log n)</script>，插入和删除也为<script type="math/tex">O(\log n)</script></p>
<h1 id="8-7-多路查找树（B树）"><a href="#8-7-多路查找树（B树）" class="headerlink" title="8.7 多路查找树（B树）"></a>8.7 多路查找树（B树）</h1><p><strong>多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</strong>。由于是查找树，所有元素之间存在某种特定的排序关系</p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p><strong>2-3树是每一个结点都具有两个孩子（2结点）或三个孩子（3结点）的一棵多路查找树</strong></p>
<p>一个2结点包含一个元素和两个孩子（或没有孩子），左子树包含的元素小于该元素，右子树包含的元素大于该元素。这个2结点要么没有孩子，要有就有两个，不能只有一个孩子</p>
<p>一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。并且2-3树中所有的叶子都在同一层次上</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/206import.png" alt></p>
<h3 id="2-3树的插入实现"><a href="#2-3树的插入实现" class="headerlink" title="2-3树的插入实现"></a>2-3树的插入实现</h3><p>2-3树的插入操作一定是发生在叶子结点上。插入一个元素的过程有可能会对该树的其余结构产生连锁反应。</p>
<p>2-3树插入可分为三种情况：</p>
<ol>
<li>对于空树，插入一个2结点即可</li>
<li>插入结点到一个2结点的叶子上。由于其本身就只有一个元素，只需要将其升级为3结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/207import.png" alt></li>
<li><p>往3结点中插入一个新元素。因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</p>
</li>
<li><p>第一种情况，元素5需要插入在拥有6、7元素的3结点位置。将6、7结点拆分，让6与4结成3结点，将5成为它的中间孩子，将7成为它的右孩子<img src="https://baozou.gitbooks.io/-data-structure/content/assets/208import.png" alt></p>
</li>
<li><p>向左图中插入元素11。需要插入在拥有9、10元素的3结点位置。9和10结点不能再增加结点。双亲结点12、14是一个3结点，也不能再插入元素。12、14结点的双亲，结点8是个2结点。将9、10拆分，12、14也拆分，让根结点8升级为3结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/209import.png" alt></p>
</li>
<li><p>插入元素2，1、3，4、6，8、12都是3结点，不能再插入元素，当前树结构是三层不能满足当前结点的增加。于是将1、3拆分，4、6拆分，连根结点8、12也拆分<img src="https://baozou.gitbooks.io/-data-structure/content/assets/210import.png" alt>如果2-3树插入的传播效应导致了根结点的拆分，则树的高度就会增加</p>
</li>
</ol>
<h3 id="2-3树的删除实现"><a href="#2-3树的删除实现" class="headerlink" title="2-3树的删除实现"></a>2-3树的删除实现</h3><p>1.删除元素位于一个3结点的叶子结点上，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/211import.png" alt></p>
<p>2.删除的元素位于一个2结点上，分四种情形</p>
<ul>
<li>此结点的双亲也是2结点，且拥有一个3结点的右孩子。删除结点1，只需要左旋<img src="https://baozou.gitbooks.io/-data-structure/content/assets/213import.png" alt></li>
<li>此结点的双亲是2结点，它的右孩子也是2结点。删除结点4，直接左旋会造成没有右孩子，办法是让结点7变成3结点，让比7稍大的元素8下来，让比元素8稍大的元素9补充结点8的位置（中间图），再用左旋的方式变成右图结果<img src="https://baozou.gitbooks.io/-data-structure/content/assets/215import.png" alt></li>
<li>此结点双亲是一个3结点，将双亲拆分，并将12与13合并成为左孩子<img src="https://baozou.gitbooks.io/-data-structure/content/assets/216import.png" alt></li>
<li>当前树是一个满二叉树的情况，删除任何一个叶子都会使得整棵树不能满足2-3树的定义。删除叶子结点8时（任何一个结点都一样），要将2-3的层数减少，办法是将8的双亲和其左子树6合并为一3个结点，再将14与9合并为3结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/217import.png" alt></li>
</ul>
<p>3.删除的元素位于非叶子的分支结点。通常是将树按中序遍历后得到此元素的前驱或后继元素，让它们来补位</p>
<ul>
<li>删除的分支结点是2结点。删除结点4，前驱是1后继是6，由于6、7是3结点，用6来补位<img src="https://baozou.gitbooks.io/-data-structure/content/assets/218import.png" alt></li>
<li>删除的分支结点是3结点的某一元素，删除结点12、14的12，将是3结点的左孩子的10上升到删除位置<img src="https://baozou.gitbooks.io/-data-structure/content/assets/219import.png" alt></li>
</ul>
<h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><p>2-3-4树是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素</p>
<p>构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树过程，图1是在分别插入7、1、2时的结果图，因为3个元素满足2-3-4树的单个4结点定义，因此此时不需要拆分，接着插入元素5，因为已经超过了4结点的定义，因此拆分为图2的形状。之后的图是在元素不断插入时最后形成的</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/220import.png" alt></p>
<p>2-3-4树删除结点的演变过程，删除顺序是1、6、3、4、5、2、9</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/221import.png" alt></p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><strong>B树（B-tree）是一种平衡的多路查找树</strong>，2-3树和2-3-4树是B树的特例。<strong>结点最大的孩子数目称为B树的阶（order）</strong>，2-3树是3阶B树，2-3-4树是4阶B树</p>
<script type="math/tex; mode=display">m$$阶的B树具有如下属性：

* 如果根结点不是叶结点，则其至少有两棵子树
* 每一个非根的分支结点都有$$k-1$$个元素和$$k$$个孩子，其中。每一个叶子结点$$n$$都有$$k-1$$个元素，其中$$[\frac{m}{2}]\le k \le m</script><ul>
<li>所有叶子结点都位于同一层次</li>
<li>所有分支结点包含下列信息数据<script type="math/tex">(n,A_0,K_1,A_1,K_2,A_2,\cdots,K_n,A_n)</script>，其中：<script type="math/tex">K_i(i=1,2,\cdots,n)</script>为关键字，且<script type="math/tex">K_i<K_{i+1}(i=1,2,\cdots,n-1)</script>；<script type="math/tex">A_i(i=0,2,\cdots,n)</script>为指向子树根结点的指针，且指针<script type="math/tex">A_{i-1}</script>所指子树中所有结点的关键字均小于<script type="math/tex">K_i(i=1,2,\cdots,n)</script>，<script type="math/tex">A_n</script>所指子树中所有结点的关键字均大于<script type="math/tex">K_n</script>，<script type="math/tex">n([\frac{m}{2}]-1\le n \le m-1)</script>为关键字的个数（或<script type="math/tex">n+1</script>为子树的个数）</li>
</ul>
<p>2-3-4树时插入9个数后的图转成B树如图。左侧灰色方块表示当前结点的元素个数</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/225import.png" alt></p>
<p>在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程</p>
<p>比如查找数字7，首先从外存（比如硬盘中）读取得到根结点3、5、8三个元素，发现7不在当中，但在5和8之间，因此就通过<script type="math/tex">A_2</script>再读取外存的6、7结点，查找到所要的元素</p>
<script type="math/tex; mode=display">n$$个关键字的$$m$$阶B树，最坏情况的查找次数：

第一层至少有1个结点，第二层至少有2个结点，由于除根结点外每个分支结点至少有$$|\frac{m}{2}|$$棵子树，则第三层至少有2×$$|\frac{m}{2}|$$个结点，……，这样第k+1层至少有2×$$(|\frac{m}{2}|)^{k-1}$$个结点，k+1层的结点就是叶子结点。若m阶B树有n个关键字，当找到了叶子结点，等于查找不成功的结点为n+1，因此n+1≥2×\($$|\frac{m}{2}|$$\)$$^{k-1}$$，即：</script><p>k \le \log _{|\frac{m}{2}|}(\frac{n+1}{2})+1</p>
<script type="math/tex; mode=display">


在含有n个关键字的B树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过$$\log _{|\frac{m}{2}|}(\frac{n+1}{2})+1</script><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树结构中，往返于每个结点必须得在硬盘的页面之间进行多次访问，假设每个结点都属于硬盘的不同页面，为了中序遍历所有的元素，页面2→页面1→页面3→页面1→页面4→页面1→页面5。而且每次经过结点遍历时，都会对结点中的元素进行一次遍历</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/229import.png" alt></p>
<p>在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</p>
<p>下图是一棵B+树的示意，灰色关键字是根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/230import.png" alt></p>
<p>一棵m阶的B+树和m阶的B树的差异在于：</p>
<ul>
<li>有n棵子树的结点中包含有n个关键字</li>
<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字</li>
</ul>
<p>如果是要随机查找，就从根结点出发，与B树的查找方式相同，不过即使在分支结点找到了待查找的关键字，也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。</p>
<p>如果从最小关键字进行从小到大的顺序查找，可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字</p>
<p>B+树的插入、删除过程都与B树类似，不过插入和删除的元素都在叶子结点上进行</p>
<h1 id="8-8-散列表查找（哈希表）概述"><a href="#8-8-散列表查找（哈希表）概述" class="headerlink" title="8.8 散列表查找（哈希表）概述"></a>8.8 散列表查找（哈希表）概述</h1><h2 id="散列表查找定义"><a href="#散列表查找定义" class="headerlink" title="散列表查找定义"></a>散列表查找定义</h2><p>通过某个函数f，使得</p>
<script type="math/tex; mode=display">
\text{存储位置}=f(\text{关键字})</script><p>可以通过查找关键字不需要比较就可获得需要的记录的存储位置</p>
<p><strong>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）</strong>。</p>
<p>查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上</p>
<p><strong>对应关系</strong><script type="math/tex">f</script><strong>称为散列函数，又称为哈希（Hash）函数</strong>。<strong>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。关键字对应的记录存储位置称为散列地址</strong></p>
<h2 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h2><ol>
<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。不管什么记录，都需要用同一个散列函数计算出地址再存储<img src="https://baozou.gitbooks.io/-data-structure/content/assets/231import.png" alt></li>
<li>查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。由于存取用的是同一个散列函数，因此结果相同</li>
</ol>
<p><strong>散列技术既是一种存储方法，也是一种查找方法</strong></p>
<p>散列技术的记录之间不存在逻辑关系，只与关键字有关联。散列主要是面向查找的存储结构</p>
<p><strong>散列技术最适合的求解问题是查找与给定值相等的记录</strong></p>
<p>散列技术不适合：</p>
<ol>
<li>同样关键字对应很多记录的情况</li>
<li>范围查找</li>
</ol>
<p>在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中时常会碰到<strong>两个关键字key1≠key2，但是却有f(key1)=f(key2)，这种现象称为冲突（colli-sion），并把key1和key2称为这个散列函数的同义词（synonym）</strong></p>
<h1 id="8-9-散列函数的构造方法"><a href="#8-9-散列函数的构造方法" class="headerlink" title="8.9 散列函数的构造方法"></a>8.9 散列函数的构造方法</h1><p>两个原则：</p>
<ul>
<li><strong>计算简单</strong>。散列函数的计算时间不应该超过其他查找技术与关键字比较的时间</li>
<li>散列地址分布均匀。尽量让散列地址均匀地分布在存储空间中，保证存储空间的有效利用，减少为处理冲突而耗费的时间</li>
</ul>
<h2 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h2><p>对0～100岁的人口数字统计表，对年龄这个关键字就可以直接用年龄的数字作为地址。此时f(key)=key</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/239import.png" alt></p>
<p>统计80后出生年份的人口数，对出生年份这个关键字可以用年份减去1980来作为地址。此时f(key)=key-1980</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/240import.png" alt></p>
<p>可以取关键字的某个线性函数值为散列地址，(a、b为常数)即</p>
<script type="math/tex; mode=display">
f(key)=a\times key+b(a,b\text{为常数})</script><p>这样的散列函数优点是简单、均匀，不产生冲突，但问题是需要事先知道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用</p>
<h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><p>如果关键字是位数较多的数字，比如11位手机号前三位是接入号，一般对应不同运营商公司的子品牌；中间四位是HLR识别号，表示用户号的归属地；后四位是真正的用户号</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/241import.png" alt></p>
<p>如果用手机号作为关键字，极有可能前7位都是相同的。那么选择后面的四位成为散列地址就是不错的选择<br>如果这样的抽取工作还是容易出现冲突问题，还可以对抽取出来的数字再进行反转（如1234改成4321）、右环位移（如1234改成4123）、左环位移、甚至前两数与后两数叠加（如1234改成12+34=46）等方法。总的目的就是为了提供一个散列函数，能够合理地将关键字分配到散列表的各位置<br>抽取方法是使用关键字的一部分来计算散列存储位置的方法，数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，可以考虑用这个方法</p>
<h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>关键字1234的平方是1522756，抽取中间的3位227用做散列地址。关键字是4321的平方就是18671041，抽取中间的3位671或710用做散列地址<br>平方取中法适合于不知道关键字的分布，而位数又不是很大的情况</p>
<h2 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h2><p><strong>折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址</strong></p>
<p>关键字9876543210，散列表表长为三位，分为四组，987|654|321|0，叠加求和987+654+321+0=1962，得到散列地址为962<br>有时还不能保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。比如将987和321反转，再与654和0相加，变成789+654+123+0=1566，此时散列地址为566</p>
<p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况</p>
<h2 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h2><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：</p>
<script type="math/tex; mode=display">
f(key)=key\ mod\ p(p\le m)</script><p>这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。本方法的关键在于选择合适的p，p如果选得不好，可能会容易产生同义词<br>对于有12个记录的关键字构造散列表时，就用了f(key)=key mod 12的方法</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/243import.png" alt></p>
<p>极端：让p为12，所有的关键字都得到了0这个地址数</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/244import.png" alt></p>
<p>若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数</p>
<h2 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h2><p>选择一个随机数，取关键字的随机函数值为它的散列地址。即</p>
<script type="math/tex; mode=display">
f(key)=random(key)</script><p>random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数比较合适</p>
<p>应该视不同的情况采用不同的散列函数。考虑因素：</p>
<ol>
<li>计算散列地址所需的时间</li>
<li>关键字的长度</li>
<li>散列表的大小</li>
<li>关键字的分布情况</li>
<li>记录查找的频率</li>
</ol>
<p>综合这些因素，才能决策选择哪种散列函数更合适</p>
<h1 id="8-10-处理散列冲突的方法"><a href="#8-10-处理散列冲突的方法" class="headerlink" title="8.10 处理散列冲突的方法"></a>8.10 处理散列冲突的方法</h1><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p><strong>开放定址法是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</strong></p>
<p>公式：</p>
<script type="math/tex; mode=display">
f_i(key)=(f(key)+d_i)\ MOD\ m\
(d_i=1,2,3,......,m-1)</script><p>这种<strong>解决冲突的开放定址法称为线性探测法</strong></p>
<p><strong>本来都不是同义词却需要争夺一个地址的情况，这种现象为堆积，</strong>堆积的出现需要不断处理冲突，无论存入还是查找效率都会大大降低</p>
<p><strong>增加平方运算的目的是为了不让关键字都聚集在某一块区域。这种方法为二次探测法</strong></p>
<script type="math/tex; mode=display">
f_i(key)=(f(key)+d_i)\ MOD\ m\ (d_i=1^2,-1^2,2^2,-2^2,\cdots,q^2,-q^2,q\le \frac{m}{2})</script><p>还有一种方法是<strong>在冲突时，对于位移量</strong><script type="math/tex">d_i</script><strong>采用随机函数计算得到，称之为随机探测法</strong></p>
<p>这里的随机是伪随机数。如果设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，在查找时，用同样的随机种子，每次得到的数列是相同的，相同的<script type="math/tex">d_i</script>可以得到相同的散列地址</p>
<script type="math/tex; mode=display">
f_i(key)=(f(key)+d_i)\ MOD\ m\ (d_i\text{是一个随机数列})</script><p>开放定址法只要在散列表未填满时，总能找到不发生冲突的地址，是常用的解决冲突的办法</p>
<h2 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h2><p>事先准备多个散列函数。</p>
<script type="math/tex; mode=display">
f
_i(key)=RH_i(key)(i=1,2,...,k)</script><p><script type="math/tex">RH_i</script>是不同的散列函数,每当发生散列地址冲突时，就换一个散列函数计算，这种方法能够使得关键字不产生聚集，也增加了计算的时间</p>
<h2 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h2><p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针</p>
<p>对关键字集合{12,67,56,16,25,37,22,29,15,47,48,34}，用12为除数,不存在冲突换址的问题，无论有多少个冲突，都只在当前位置给单链表增加结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/250import.png" alt></p>
<p>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。也带来了查找时需要遍历单链表的性能损耗</p>
<h2 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h2><p>关键字{37,48,34}与之前的关键字位置有冲突，将它们存储到溢出表</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/245import.png" alt></p>
<p>查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高</p>
<h1 id="8-11-散列表查找实现"><a href="#8-11-散列表查找实现" class="headerlink" title="8.11 散列表查找实现"></a>8.11 散列表查找实现</h1><h2 id="散列表查找算法实现"><a href="#散列表查找算法实现" class="headerlink" title="散列表查找算法实现"></a>散列表查找算法实现</h2><p>HashTable是散列表结构。结构当中的elem为一个动态数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="comment">/* 定义散列表长为数组的长度 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* 数据元素存储基址，动态分配数组 */</span></span><br><span class="line"><span class="keyword">int</span> *elem;</span><br><span class="line"><span class="comment">/* 当前数据元素个数 */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"><span class="comment">/* 散列表表长，全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>对散列表初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">m = HASHSIZE;</span><br><span class="line">H-&gt;count = m;</span><br><span class="line">H-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">H-&gt;elem[i] = NULLKEY;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了插入时计算地址，需要定义散列函数，散列函数可以根据不同情况更改算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 除留余数法 */</span></span><br><span class="line"><span class="keyword">return</span> key % m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化完成后，对散列表进行插入操作。假设插入的关键字集合是前面的{12,67,56,16,25,37,22,29,15,47,48,34}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入关键字进散列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 求散列地址 */</span></span><br><span class="line"><span class="keyword">int</span> addr = Hash(key);</span><br><span class="line"><span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line"><span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY)</span><br><span class="line"><span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">addr = (addr + <span class="number">1</span>) % m;</span><br><span class="line"><span class="comment">/* 直到有空位后插入关键字 */</span></span><br><span class="line">H-&gt;elem[addr] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。此时应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其他解决冲突的办法</p>
<p>散列表存在后，需要时可以通过散列表查找要的记录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H, <span class="keyword">int</span> key, <span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 求散列地址 */</span></span><br><span class="line">*addr = Hash(key);</span><br><span class="line"><span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line"><span class="keyword">while</span> (H.elem[*addr] != key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">*addr = (*addr + <span class="number">1</span>) % m;</span><br><span class="line"><span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果循环回到原点 */</span></span><br><span class="line"><span class="comment">/* 则说明关键字不存在 */</span></span><br><span class="line"><span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h2><p>散列查找的平均查找长度取决因素：</p>
<p>1．散列函数是否均匀</p>
<p>散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此可以不考虑它对平均查找长度的影响</p>
<p>2．处理冲突的方法</p>
<p>相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能</p>
<p>3．散列表的装填因子</p>
<p>所谓的装填因子<script type="math/tex">\alpha</script>=填入表中的记录个数/散列表长度。<script type="math/tex">\alpha</script>标志着散列表的装满的程度。当填入表中的记录越多，<script type="math/tex">\alpha</script>就越大，产生冲突的可能性就越大。如果散列表长度是12，而填入表中的记录个数为11，装填因子<script type="math/tex">\alpha</script>=11/12=0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数</p>
<p>不管记录个数<script type="math/tex">n</script>有多大，总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时散列查找的时间复杂度是<script type="math/tex">O(1)</script>。通常都是将散列表的空间设置得比查找集合大，虽然是浪费了一定的空间，但换来的是查找效率的大大提升</p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第二章  算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第二章  算法/" itemprop="url">大话数据结构 第二章  算法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:47:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:01:04Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第二章  算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第二章  算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第二章  算法/" class="leancloud_visitors" data-flag-title="大话数据结构 第二章  算法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="2-1-算法的特性"><a href="#2-1-算法的特性" class="headerlink" title="2.1 算法的特性"></a>2.1 算法的特性</h1><ol>
<li><strong>输入输出</strong>：算法具有零个或多个输入，至少有一个或多个输出。输出的形式可以是打印输出，也可以是返回一个或多个值等</li>
<li><strong>有穷性</strong>：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</li>
<li><strong>确定性</strong>：算法的每一步骤都具有确定的含义，不会出现二义性。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义</li>
<li><strong>可行性</strong>：算法的每一步都必须是可行的，都能够通过执行有限次数完成。</li>
</ol>
<h1 id="2-2-算法设计的要求"><a href="#2-2-算法设计的要求" class="headerlink" title="2.2 算法设计的要求"></a>2.2 算法设计的要求</h1><ul>
<li><strong>正确性</strong>：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</li>
</ul>
<p>算法的“正确”大体分为四个层次：</p>
<ol>
<li>算法程序没有语法错误。</li>
<li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li>
<li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li>
<li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li>
</ol>
<p>层次1要求最低，层次4是最困难的，几乎不可能逐一验证所有的输入都得到正确的结果。因此算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，</p>
<p>代价非常昂贵。一般情况下把层次3作为一个算法是否正确的标准</p>
<ul>
<li><strong>可读性</strong>：算法设计的另一目的是为了便于阅读、理解和交流。</li>
<li><strong>健壮性</strong>：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果</li>
<li><strong>时间效率高</strong>：时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低</li>
<li><strong>存储量低 </strong>：存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间</li>
</ul>
<p>好的算法，应该具有<strong>正确性</strong>、<strong>可读性</strong>、<strong>健壮性</strong>、<strong>高效率</strong>和<strong>低存储量</strong>的特征</p>
<h1 id="2-3-算法效率的度量方法"><a href="#2-3-算法效率的度量方法" class="headerlink" title="2.3 算法效率的度量方法"></a>2.3 算法效率的度量方法</h1><h2 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h2><p><strong>事后统计方法</strong>：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</p>
<p><strong>缺陷</strong>：</p>
<ol>
<li>必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。</li>
<li>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣</li>
<li>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现</li>
</ol>
<p>故不予采纳<strong>事后统计方法</strong></p>
<h2 id="事前分析估算方法"><a href="#事前分析估算方法" class="headerlink" title="事前分析估算方法"></a>事前分析估算方法</h2><p><strong>事前分析估算方法</strong>：在计算机程序编制前，依据统计方法对算法进行估算。</p>
<p>一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p>
<ol>
<li>算法采用的策略、方法。</li>
<li>编译产生的代码质量。</li>
<li>问题的输入规模。</li>
<li>机器执行指令的速度。</li>
</ol>
<p>第1条是算法好坏的根本，第2条要由软件来支持，第4条要看硬件性能。抛开与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/9import.png" alt></p>
<h1 id="2-4-函数的渐近增长"><a href="#2-4-函数的渐近增长" class="headerlink" title="2.4 函数的渐近增长"></a>2.4 函数的渐近增长</h1><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/import.png" alt></p>
<p><strong>函数的渐近增长</strong>：给定两个函数<script type="math/tex">f(n)</script>和<script type="math/tex">g(n)</script>，如果存在一个整数<script type="math/tex">N</script>，使得对于所有的<script type="math/tex">n > N</script>，<script type="math/tex">f(n)</script>总是比<script type="math/tex">g(n)</script>大，那么说<script type="math/tex">f(n)</script>的增长渐近快于<script type="math/tex">g(n)</script></p>
<p>判断一个算法的效率时，函数中的常数和其他次要项常可以忽略，而更应该关注主项（最高阶项）的阶数</p>
<h1 id="2-5-算法时间复杂度"><a href="#2-5-算法时间复杂度" class="headerlink" title="2.5 算法时间复杂度"></a>2.5 算法时间复杂度</h1><h2 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h2><p><strong>算法的时间复杂度</strong>，也就是算法的时间量度，记作：<script type="math/tex">T(n)=O(f(n))</script>。表示随问题规模<script type="math/tex">n</script>的增大，算法执行时间的增长率和<script type="math/tex">f(n)</script>的增长率相同，称作算法的<strong>渐近时间复杂度</strong>，简称为<strong>时间复杂度</strong>。其中<script type="math/tex">f(n)</script>是问题规模<script type="math/tex">n</script>的某个函数。用大写<script type="math/tex">O( )</script>来体现算法时间复杂度的记法，称之为大<script type="math/tex">O</script>记法。一般情况下，随着<script type="math/tex">n</script>的增大，<script type="math/tex">T(n)</script>增长最慢的算法为<strong>最优算法</strong></p>
<h2 id="推导大O阶方法"><a href="#推导大O阶方法" class="headerlink" title="推导大O阶方法"></a>推导大O阶方法</h2><p>推导大<script type="math/tex">O</script>阶：</p>
<ol>
<li>用常数<script type="math/tex">1</script>取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是<script type="math/tex">1</script>，则去除与这个项相乘的常数。</li>
</ol>
<p>得到的结果就是大<script type="math/tex">O</script>阶</p>
<h2 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h2><p>执行时间恒定的算法，称之为具有<script type="math/tex">O(1)</script>的时间复杂度，又叫<strong>常数阶</strong>。</p>
<blockquote>
<p>不管这个常数是多少，都记作<script type="math/tex">O(1)</script>，而不能是<script type="math/tex">O(3)</script>、<script type="math/tex">O(12)</script>等其他任何数字</p>
</blockquote>
<p>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着<script type="math/tex">n</script>的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是<script type="math/tex">O(1)</script></p>
<h2 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h2><p><strong>线性阶</strong>的循环结构会复杂很多。要确定某个算法的阶次，需要确定某个特定语句或某个语句集运行的次数。</p>
<p>要分析算法的复杂度，关键就是要分析<strong>循环结构</strong>的运行情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>循环的时间复杂度为<script type="math/tex">O(n)</script>，因为循环体中的代码须要执行<script type="math/tex">n</script>次</p>
</blockquote>
<h2 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">count = count * <span class="number">2</span>; <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由<script type="math/tex">2^x=n</script>得到<script type="math/tex">x=log_2n</script>。所以这个循环的时间复杂度为<script type="math/tex">O(logn)</script></p>
</blockquote>
<h2 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>的时间复杂度为<script type="math/tex">O(n^2)</script></p>
</blockquote>
<p>循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123; <span class="comment">/* 注意j = i 而不是0 */</span></span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的执行次数为：</p>
<script type="math/tex; mode=display">
n+(n-1)+(n-2)+\cdot\cdot\cdot+1=\frac{n(n+1)}{2}=\frac{n^2}{2}+\frac{n}{2}</script><p>推导大<script type="math/tex">O</script>阶的方法:</p>
<ol>
<li>没有加法常数不予考虑；</li>
<li>只保留最高阶项，因此保留<script type="math/tex">\frac{n^2}{2}</script>；</li>
<li>去除这个项相乘的常数，也就是去除<script type="math/tex">\frac{1}{2}</script>，最终这段代码的时间复杂度为<script type="math/tex">O(n^2)</script></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n++; <span class="comment">/* 执行次数为1 */</span></span><br><span class="line">function(n); <span class="comment">/* 执行次数为n */</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">/* 执行次数为n2 */</span></span><br><span class="line">&#123;</span><br><span class="line">function (i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">/* 执行次数为n(n + 1)/2 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行次数<script type="math/tex">f(n)=1+n+n^2+\frac{n(n+1)}{2}=\frac{3}{2}\cdot n^2+\frac{3}{2}\cdot n+1</script>,时间复杂度也是<script type="math/tex">O(n^2)</script></p>
<h1 id="2-6-常见的时间复杂度"><a href="#2-6-常见的时间复杂度" class="headerlink" title="2.6 常见的时间复杂度"></a>2.6 常见的时间复杂度</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">执行次数</th>
<th style="text-align:center">函数阶</th>
<th style="text-align:center">非正式术语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><script type="math/tex">12</script></td>
<td style="text-align:center"><script type="math/tex">O(1)</script></td>
<td style="text-align:center">常数阶</td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">2n+3</script></td>
<td style="text-align:center"><script type="math/tex">O(n)</script></td>
<td style="text-align:center">线性阶</td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">3n^2+2n+1</script></td>
<td style="text-align:center"><script type="math/tex">O(n^2)</script></td>
<td style="text-align:center">平方阶</td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">5log_2n+20</script></td>
<td style="text-align:center"><script type="math/tex">O(logn)</script></td>
<td style="text-align:center">对数阶</td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">2n+3nlog_2n+19</script></td>
<td style="text-align:center"><script type="math/tex">O(nlogn)</script></td>
<td style="text-align:center"><script type="math/tex">nlogn</script>阶</td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">6n^3+2n^2+3n+4</script></td>
<td style="text-align:center"><script type="math/tex">O(n^3)</script></td>
<td style="text-align:center">立方阶</td>
</tr>
<tr>
<td style="text-align:center"><script type="math/tex">2^n</script></td>
<td style="text-align:center"><script type="math/tex">O(2^n)</script></td>
<td style="text-align:center">指数阶</td>
</tr>
</tbody>
</table>
</div>
<p>常用的时间复杂度所耗费的时间从小到大依次是：</p>
<script type="math/tex; mode=display">
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script><h1 id="2-7-最坏情况与平均情况"><a href="#2-7-最坏情况与平均情况" class="headerlink" title="2.7 最坏情况与平均情况"></a>2.7 最坏情况与平均情况</h1><p>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。通常，除非特别指定，运行时间都是最坏情况的运行时间</p>
<p>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</p>
<p>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为<strong>平均时间复杂度</strong>。另一种方法是计算最坏情况下的时间复杂度，这种方法称为<strong>最坏时间复杂度</strong>。一般在没有特殊说明的情况下，都是指最坏时间复杂度</p>
<h1 id="2-8-算法空间复杂度"><a href="#2-8-算法空间复杂度" class="headerlink" title="2.8 算法空间复杂度"></a>2.8 算法空间复杂度</h1><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：<script type="math/tex">S(n)=O(f(n))</script>，<script type="math/tex">n</script>为问题的规模，<script type="math/tex">f(n)</script>为语句关于<script type="math/tex">n</script>所占存储空间的函数。</p>
<p>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。</p>
<p>若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为<strong>原地工作</strong>，空间复杂度为<script type="math/tex">O(1)</script></p>
<h1 id="2-9-总结回顾"><a href="#2-9-总结回顾" class="headerlink" title="2.9 总结回顾"></a>2.9 总结回顾</h1><p>算法的定义：算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<p>算法的特性：有穷性、确定性、可行性、输入、输出</p>
<p>算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求</p>
<p>算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法</p>
<p>函数的渐近增长：给定两个函数<script type="math/tex">f(n)</script>和<script type="math/tex">g(n)</script>，如果存在一个整数<script type="math/tex">N</script>，使得对于所有的<script type="math/tex">n>N</script>，<script type="math/tex">f(n)</script>总是比<script type="math/tex">g(n)</script>大，那么说<script type="math/tex">f(n)</script>的增长渐近快于<script type="math/tex">g(n)</script></p>
<p>推导大<script type="math/tex">O</script>阶：</p>
<ol>
<li>用常数<script type="math/tex">1</script>取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是<script type="math/tex">1</script>，则去除与这个项相乘的常数。</li>
</ol>
<p>得到的结果就是大<script type="math/tex">O</script>阶</p>
<p>常见的时间复杂度所耗时间的大小排列：</p>
<script type="math/tex; mode=display">
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script>
          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第三章  线性表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第三章  线性表/" itemprop="url">大话数据结构 第三章  线性表</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:47:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:10:07Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第三章  线性表/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第三章  线性表/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第三章  线性表/" class="leancloud_visitors" data-flag-title="大话数据结构 第三章  线性表">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="3-1-线性表的定义"><a href="#3-1-线性表的定义" class="headerlink" title="3.1 线性表的定义"></a>3.1 线性表的定义</h1><p><strong>线性表（List）</strong>：零个或多个数据元素的有限序列。</p>
<p>首先它是一个序列。元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个<strong>前驱</strong>和<strong>后继</strong></p>
<p>若将线性表记为<script type="math/tex">(a_1,\cdots,a_{i-1},a_i,a_{i+1},\cdots,a_n)</script>，则表中<script type="math/tex">a_{i-1}</script>领先于<script type="math/tex">a_i</script>，<script type="math/tex">a_{i+1}</script>领先于<script type="math/tex">a_i</script>，称<script type="math/tex">a_{i-1}</script>是<script type="math/tex">a_i</script>的直接前驱元素，<script type="math/tex">a_{i+1}</script>是<script type="math/tex">a_i</script>的直接后继元素。当<script type="math/tex">i=1,2,\cdots,n-1</script>时，<script type="math/tex">a_i</script>有且仅有一个直接后继，当<script type="math/tex">i=2,3,\cdots,n</script>时，<script type="math/tex">a_i</script>有且仅有一个直接前驱</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/10import.png" alt></p>
<p>线性表元素的个数<script type="math/tex">n(n\ge 0)</script>定义为线性表的长度，当<script type="math/tex">n=0</script>时，称为<strong>空表</strong>。<script type="math/tex">i</script>为数据元素<script type="math/tex">a_i</script>在线性表中的<strong>位序</strong></p>
<p>在较复杂的线性表中，一个数据元素可以由若干个数据项组成</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/11import.png" alt></p>
<h1 id="3-2-线性表的抽象数据类型"><a href="#3-2-线性表的抽象数据类型" class="headerlink" title="3.2 线性表的抽象数据类型"></a>3.2 线性表的抽象数据类型</h1><p>对于一个线性表来说，<strong>插入数据</strong>和<strong>删除数据</strong>都是必须的操作</p>
<p>线性表的抽象数据类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。 其中，除</span><br><span class="line">第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且</span><br><span class="line">只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">InitList(*L): 初始化操作，建立一个空的线性表L。</span><br><span class="line"></span><br><span class="line">ListEmpty(L): 若线性表为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line">ClearList(*L): 将线性表清空。</span><br><span class="line"></span><br><span class="line">GetElem(L, i, *e): 将线性表L中的第i个位置元素值返回给e。</span><br><span class="line"></span><br><span class="line">LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；</span><br><span class="line">否则，返回<span class="number">0</span>表示失败</span><br><span class="line"></span><br><span class="line">ListInsert(*L,i,e): 在线性表L中的第i个位置插入新元素e</span><br><span class="line"></span><br><span class="line">ListDelete(*L,i,*e): 删除线性表L中的第i个位置元素，并用e返回其值</span><br><span class="line"></span><br><span class="line">ListLength(L): 返回线性表L的元素个数</span><br><span class="line"></span><br><span class="line">EndADT</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将所有的在线性表Lb中但不在La中的数据元素插入到La中 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionL</span><span class="params">(List *La, List Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> La_len, Lb_len, i; <span class="comment">/* 声明与La和Lb相同的数据元素e */</span></span><br><span class="line">ElemType e;</span><br><span class="line"></span><br><span class="line">La_len = ListLength(*La); <span class="comment">/* 求线性表的长度 */</span></span><br><span class="line">Lb_len = ListLength(Lb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lb_len; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">GetElem(Lb, i, &amp;e); <span class="comment">/* 取Lb中第i个数据元素赋给e */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!LocateElem(*La, e)) <span class="comment">/* La中不存在和e相同数据元素 */</span></span><br><span class="line">ListInsert(La, ++La_len, e); <span class="comment">/* 插入 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-3-线性表的顺序存储结构"><a href="#3-3-线性表的顺序存储结构" class="headerlink" title="3.3 线性表的顺序存储结构"></a>3.3 线性表的顺序存储结构</h1><h2 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h2><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/12import.png" alt></p>
<h2 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h2><p>线性表的顺序存储的结构代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MAXSIZE]; <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line"><span class="keyword">int</span> length; <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line"></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>
<p>顺序存储结构需要三个属性：</p>
<ul>
<li>存储空间的起始位置：数组<strong>data</strong>，它的存储位置就是存储空间的存储位置</li>
<li>线性表的最大存储容量：数组长度<strong>MaxSize</strong></li>
<li>线性表的当前长度：<strong>length</strong></li>
</ul>
<h2 id="数组长度与线性表长度区别"><a href="#数组长度与线性表长度区别" class="headerlink" title="数组长度与线性表长度区别"></a>数组长度与线性表长度区别</h2><ul>
<li>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的</li>
<li>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</li>
<li>在任意时刻，线性表的长度应该小于等于数组的长度</li>
</ul>
<h2 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/13import.png" alt></p>
<p>存储器中的每个存储单元都有自己的编号，这个编号称为地址</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/14import.png" alt></p>
<p>每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是<script type="math/tex">c</script>个存储单元，那么线性表中第<script type="math/tex">i+1</script>个数据元素的存储位置和第<script type="math/tex">i</script>个数据元素的存储位置满足下列关系：</p>
<script type="math/tex; mode=display">
LOC(a_{i+1})=LOC(a_i)+c</script><blockquote>
<p>LOC表示获得存储位置的函数</p>
</blockquote>
<p>第<script type="math/tex">i</script>个数据元素<script type="math/tex">a_i</script>的存储位置可以由<script type="math/tex">a_1</script>推算得出：</p>
<script type="math/tex; mode=display">
LOC(a_i)=LOC(a_1)+(i-1)*c</script><p>对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，存取时间性能为<script type="math/tex">O(1)</script>。通常把具有这一特点的存储结构称为<strong>随机存取结构</strong></p>
<h1 id="3-4-顺序存储结构的插入与删除"><a href="#3-4-顺序存储结构的插入与删除" class="headerlink" title="3.4 顺序存储结构的插入与删除"></a>3.4 顺序存储结构的插入与删除</h1><h2 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h2><p>实现<strong>GetElem</strong>操作，即将线性表<strong>L</strong>中的第<strong>i</strong>个位置元素值返回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="comment">/* Status是函数的类型，其值是函数结果状态代 码，如OK等 */</span></span><br><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：用e返回L中第i个数据元素的值 */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e = L.data[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值类型<strong>Status</strong>是一个整型，返回<strong>OK</strong>代表<strong>1</strong>，<strong>ERROR</strong>代表<strong>0</strong></p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/15import.png" alt></p>
<p>插入算法的思路：</p>
<ul>
<li>如果插入位置不合理，抛出异常；</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；</li>
<li>从最后一个元素开始向前遍历到第<strong>i</strong>个位置，分别将它们都向后移动一个位置；</li>
<li>将要插入元素填入位置<strong>i</strong>处；</li>
<li>表长加<strong>1</strong></li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个位置之前插入新的数据元 素e，L的长度加1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == MAXSIZE) <span class="comment">/* 顺序线性表已经满 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;L-&gt;length + <span class="number">1</span>) <span class="comment">/* 当i不在范围内时 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt;= L-&gt;length) <span class="comment">/* 若插入数据位置不在表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k = L-&gt;length - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--) <span class="comment">/*将要插入位置后数据元素向后移动一位 */</span></span><br><span class="line">L-&gt;data[k + <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">L-&gt;data[i - <span class="number">1</span>] = e; <span class="comment">/* 将新元素插入 */</span></span><br><span class="line">L-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/16import.png" alt></p>
<p>删除算法的思路：</p>
<ul>
<li>如果删除位置不合理，抛出异常；</li>
<li>取出删除元素；</li>
<li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；</li>
<li>表长减<strong>1</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个数据元素，并用e返回 其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>) <span class="comment">/* 线性表为空 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length) <span class="comment">/* 删除位置不正确 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e = L-&gt;data[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt; L-&gt;length) <span class="comment">/* 如果删除不是最后位置 */</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = i; k &lt; L-&gt;length; k++) <span class="comment">/* 将删除位置后继元素前移 */</span></span><br><span class="line">L-&gt;data[k - <span class="number">1</span>] = L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;length--;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果元素要插入到最后一个位置，或者删除最后一个元素，时间复杂度为<script type="math/tex">O(1)</script></li>
<li>如果元素要插入到第一个位置或者删除第一个元素，意味着要移动所有的元素向后或者向前，时间复杂度为<script type="math/tex">O(n)</script></li>
<li>平均的情况，由于元素插入到第<script type="math/tex">i</script>个位置，或删除第<script type="math/tex">i</script>个元素，需要移动<script type="math/tex">n-i</script>个元素。根据概率原理，每个位置插入或删除元素的可能性是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等，为<script type="math/tex">\frac{n-1}{2}</script>,平均时间复杂度还是<script type="math/tex">O(n)</script></li>
</ul>
<p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是<script type="math/tex">O(1)</script>；而插入或删除时，时间复杂度都是<script type="math/tex">O(n)</script></p>
<h2 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/17import.png" alt></p>
<h1 id="3-5-线性表的链式存储结构"><a href="#3-5-线性表的链式存储结构" class="headerlink" title="3.5 线性表的链式存储结构"></a>3.5 线性表的链式存储结构</h1><h2 id="顺序存储结构不足的解决办法"><a href="#顺序存储结构不足的解决办法" class="headerlink" title="顺序存储结构不足的解决办法"></a>顺序存储结构不足的解决办法</h2><p>线性表的顺序存储结构最大的缺点就是插入和删除时需要移动大量元素，显然需要耗费时间</p>
<h2 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h2><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这些数据元素可以存在内存未被占用的任意位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/5import.png" alt></p>
<p>链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p>
<p>对数据元素<script type="math/tex">a_i</script>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。存储数据元素信息的域称为<strong>数据域</strong>，存储直接后继位置的域称为<strong>指针域</strong>。指针域中存储的信息称做<strong>指针</strong>或<strong>链</strong>。这两部分信息组成数据元素<script type="math/tex">a_i</script>的存储映像，称为<strong>结点（Node）</strong>。n个结点（<script type="math/tex">a_i</script>的存储映像）链结成一个链表，即为线性表（<script type="math/tex">a1,a2,\cdots,a_n</script>）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做<strong>单链表</strong>。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/18import.png" alt></p>
<p>链表中第一个结点的存储位置叫做<strong>头指针,</strong>线性链表的最后一个结点指针为<strong>“空”</strong>（通常用<strong>NULL</strong>或<strong>“^”</strong>符号表示)</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/19import.png" alt></p>
<p>为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为<strong>头结点</strong>。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/20import.png" alt></p>
<h2 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/21import.png" alt></p>
<h2 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h2><p>若线性表为空表，则头结点的指针域为<strong>“空”</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/22import.png" alt></p>
<p>改用更方便的存储示意图来表示单链表</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/23import.png" alt></p>
<p>带有头结点的单链表</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/24import.png" alt></p>
<p>空链表</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/25import.png" alt></p>
<p>单链表中，在C语言中可用结构指针来描述:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性表的单链表存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span> <span class="comment">/* 定义LinkList */</span></span><br></pre></td></tr></table></figure>
<p>结点由存放数据元素的数据域和存放后继结点地址的指针域组成。假设<script type="math/tex">p</script>是指向线性表第<strong>i</strong>个元素的指针，则该结点<script type="math/tex">a_i</script>的数据域可以用<script type="math/tex">p-\gt data</script>来表示，<script type="math/tex">p-\gt data</script>的值是一个数据元素，结点<script type="math/tex">a_i</script>的指针域可以用<script type="math/tex">p-\gt next</script>来表示，<script type="math/tex">p-\gt next</script>的值是一个指针，指向第<script type="math/tex">i+1</script>个元素，即指向<script type="math/tex">a_{i+1}</script>的指针。</p>
<p>如果<script type="math/tex">p-\gt data=a_i</script>，那么<script type="math/tex">p-\gt next-\gt data=a_{i+1}</script></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/26import.png" alt></p>
<h1 id="3-6-单链表的读取"><a href="#3-6-单链表的读取" class="headerlink" title="3.6 单链表的读取"></a>3.6 单链表的读取</h1><p>获得链表第<script type="math/tex">i</script>个数据的算法思路：</p>
<ol>
<li>声明一个指针<script type="math/tex">p</script>指向链表第一个结点，初始化<script type="math/tex">j</script>从<script type="math/tex">1</script>开始；</li>
<li>当<script type="math/tex">j<i</script>时，就遍历链表，让<script type="math/tex">p</script>的指针向后移动，不断指向下一结点，<script type="math/tex">j</script>累加<script type="math/tex">1</script>；</li>
<li>若到链表末尾<script type="math/tex">p</script>为空，则说明第<script type="math/tex">i</script>个结点不存在；</li>
<li>否则查找成功，返回结点<script type="math/tex">p</script>的数据</li>
</ol>
<p>实现代码算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：用e返回L中第i个数据元素的值 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p; <span class="comment">/* 声明一指针p */</span></span><br><span class="line">p = L-&gt;next; <span class="comment">/* 让p指向链表L的第个结点 */</span></span><br><span class="line">j = <span class="number">1</span>; <span class="comment">/* j为计数器 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">/* p不为空且计数器j还没有等于i时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next; <span class="comment">/* 让p指向下一个结点 */</span></span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i)</span><br><span class="line"><span class="keyword">return</span> ERROR; <span class="comment">/* 第i个结点不存在 */</span></span><br><span class="line">*e = p-&gt;data; <span class="comment">/* 取第i个结点的数据 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最坏情况的时间复杂度是<script type="math/tex">O(n)</script></p>
</blockquote>
<h1 id="3-7-单链表的插入与删除"><a href="#3-7-单链表的插入与删除" class="headerlink" title="3.7 单链表的插入与删除"></a>3.7 单链表的插入与删除</h1><h2 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/27import.png" alt></p>
<p>让<script type="math/tex">p</script>的后继结点改成<script type="math/tex">s</script>的后继结点，再把结点<script type="math/tex">s</script>变成<script type="math/tex">p</script>的后继结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next; p-&gt;next = s;</span><br></pre></td></tr></table></figure>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/28import.png" alt></p>
<p>插入结点<script type="math/tex">s</script>后:</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/29import.png" alt></p>
<p>对于单链表的表头和表尾的特殊情况，操作是相同的</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/30import.png" alt></p>
<p>单链表第<script type="math/tex">i</script>个数据插入结点的算法思路：</p>
<ol>
<li>声明一指针<script type="math/tex">p</script>指向链表头结点，初始化<script type="math/tex">j</script>从1开始；</li>
<li>当<script type="math/tex">j<i</script>时，就遍历链表，让<script type="math/tex">p</script>的指针向后移动，不断指向下一结点，<script type="math/tex">j</script>累加1；</li>
<li>若到链表末尾<script type="math/tex">p</script>为空，则说明第<script type="math/tex">i</script>个结点不存在；</li>
<li>否则查找成功，在系统中生成一个空结点<script type="math/tex">s</script>；</li>
<li>将数据元素<script type="math/tex">e</script>赋值给<script type="math/tex">s->data</script>；</li>
<li>单链表的插入标准语句<script type="math/tex">s-\gt next=p-\gt next;p->next=s</script>；</li>
<li>返回成功</li>
</ol>
<p>实现代码算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)， */</span></span><br><span class="line"><span class="comment">/* 操作结果：在L中第i个结点位置之前插入新的数据元素e，L的长度加1 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p, s;</span><br><span class="line">p = *L;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; i) <span class="comment">/* 寻找第i-1个结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p || j &gt; i) <span class="comment">/* 第i个结点不存在 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/* 生成新结点（C标准函数） */</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next; <span class="comment">/* 将p的后继结点赋值给s的后继 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p-&gt;next = s; <span class="comment">/* 将s赋值给p的后继 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C</strong>语言的<strong>mal-loc</strong>标准函数，作用是生成一个新的结点，类型与<strong>Node</strong>一样，实质就是在内存中找了一小块空地，准备用来存放数据<strong>e</strong>的<strong>s</strong>结点</p>
<h2 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/31import.png" alt></p>
<p>单链表第i个数据删除结点的算法思路：</p>
<ol>
<li>声明一指针<script type="math/tex">p</script>指向链表头结点，初始化<script type="math/tex">j</script>从1开始；</li>
<li>当<script type="math/tex">j<i</script>时，就遍历链表，让<script type="math/tex">p</script>的指针向后移动，不断指向下一个结点，<script type="math/tex">j</script>累加1；</li>
<li>若到链表末尾<script type="math/tex">p</script>为空，则说明第<script type="math/tex">i</script>个结点不存在；</li>
<li>否则查找成功，将欲删除的结点<script type="math/tex">p-\gt next</script>赋值给<script type="math/tex">q</script>；</li>
<li>单链表的删除标准语句<script type="math/tex">p-\gt next=q-\gt next</script>；</li>
<li>将<script type="math/tex">q</script>结点中的数据赋值给<script type="math/tex">e</script>，作为返回；</li>
<li>释放<script type="math/tex">q</script>结点；</li>
<li>返回成功</li>
</ol>
<p>实现代码算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：删除L的第i个结点，并用e返回其值，L的长度减1 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkList *L, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = *L;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 遍历寻找第i-1个结点 */</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 第i个结点不存在 */</span></span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="comment">/* 将q的后继赋值给p的后继 */</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="comment">/* 将q结点中的数据给e */</span></span><br><span class="line">*e = q-&gt;data;</span><br><span class="line"><span class="comment">/* 让系统回收此结点，释放内存 */</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$C$语言的标准函数<script type="math/tex">free</script>。它的作用就是让系统回收一个<script type="math/tex">Node</script>结点，释放内存</p>
<p>单链表插入和删除算法，都是由两部分组成：</p>
<ul>
<li>第一部分就是遍历查找第<script type="math/tex">i</script>个结点；</li>
<li>第二部分就是插入和删除结点</li>
</ul>
<p>时间复杂度都是<script type="math/tex">O(n)</script>。如果不知道第<script type="math/tex">i</script>个结点的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。如果希望从第<script type="math/tex">i</script>个位置，插入10个结点，对于顺序存储结构意味着，每一次插入都需要移动<script type="math/tex">n-i</script>个结点，每次都是<script type="math/tex">O(n)</script>。单链表只需要在第一次时找到第<script type="math/tex">i</script>个位置的指针，此时为<script type="math/tex">O(n)</script>，接下来只是简单地通过赋值移动指针而已，时间复杂度都是<script type="math/tex">O(1)</script>。</p>
<p><strong>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong></p>
<h1 id="3-8-单链表的整表创建"><a href="#3-8-单链表的整表创建" class="headerlink" title="3.8 单链表的整表创建"></a>3.8 单链表的整表创建</h1><p>顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表不像顺序存储结构这么集中，可以很散，是一种动态结构。对于每个链表来说，所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成</p>
<p>创建单链表的过程是一个动态生成链表的过程。即从<strong>“空表”</strong>的初始状态起，依次建立各元素结点，并逐个插入链表</p>
<p>单链表整表创建的算法思路：</p>
<ol>
<li>声明一指针<script type="math/tex">p</script>和计数器变量<script type="math/tex">i</script>；</li>
<li>初始化一空链表<script type="math/tex">L</script>；</li>
<li>让<script type="math/tex">L</script>的头结点的指针指向<script type="math/tex">NULL</script>，即建立一个带头结点的单链表；</li>
<li><p>循环：</p>
</li>
<li><p>生成一新结点赋值给<script type="math/tex">p</script>；</p>
</li>
<li><p>随机生成一数字赋值给<script type="math/tex">p</script>的数据域<script type="math/tex">p-\gt data</script>；</p>
</li>
<li><p>将<script type="math/tex">p</script>插入到头结点与前一新结点之间。</p>
</li>
</ol>
<p>实现代码算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListHead</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">/* 初始化随机数种子 */</span></span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">/* 先建立一个带头结点的单链表 */</span></span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 生成新结点 */</span></span><br><span class="line">p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">/* 随机生成100以内的数字 */</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">p-&gt;next = (*L)-&gt;next;</span><br><span class="line"><span class="comment">/* 插入到表头 */</span></span><br><span class="line">(*L)-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用的是插队的办法，始终让新结点在第一的位置</p>
</blockquote>
<p>这种算法简称为<strong>头插法</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/32import.png" alt></p>
<p><strong>尾插法</strong></p>
<p>实现代码算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateListTail</span><span class="params">(LinkList *L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p,r;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">/* 初始化随机数种子 */</span></span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="comment">/* 为整个线性表 */</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">/* r为指向尾部的结点 */</span></span><br><span class="line">r = *L;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 生成新结点 */</span></span><br><span class="line">p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">/* 随机生成100以内的数字 */</span></span><br><span class="line">p-&gt;data = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 将表尾终端结点的指针指向新结点 */</span></span><br><span class="line">r-&gt;next = p;</span><br><span class="line"><span class="comment">/* 将当前的新结点定义为表尾终端结点 */</span></span><br><span class="line">r = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示当前链表结束 */</span></span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$L$指整个单链表，<script type="math/tex">r</script>是指向尾结点的变量，<script type="math/tex">r</script>会随着循环不断地变化结点，<script type="math/tex">L</script>则是随着循环增长为一个多结点的链表</p>
<p>$r-&gt;next=p;$的意思是将刚才的表尾终端结点<script type="math/tex">r</script>的指针指向新结点<script type="math/tex">p</script></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/343import.png" alt></p>
<p>$r=p;$</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/34import.png" alt></p>
<p>本来<script type="math/tex">r</script>是在<script type="math/tex">a_{i-1}</script>元素的结点，可现在它已经不是最后的结点了，现在最后的结点是<script type="math/tex">a_i</script>，应该将<script type="math/tex">p</script>结点这个最后的结点赋值给<script type="math/tex">r</script>。此时<script type="math/tex">r</script>又是最终的尾结点了。</p>
<p>循环结束后，那么应该尾节点的指针域置空，因此有了<script type="math/tex">r-\gt next=NULL;</script>，以便以后遍历时可以确认其是尾部</p>
<h1 id="3-9-单链表的整表删除"><a href="#3-9-单链表的整表删除" class="headerlink" title="3.9 单链表的整表删除"></a>3.9 单链表的整表删除</h1><p>单链表整表删除的算法思路如下：</p>
<ol>
<li>声明一指针<script type="math/tex">p</script>和<script type="math/tex">q</script>；</li>
<li>将第一个结点赋值给<script type="math/tex">p</script>；</li>
<li><p>循环：</p>
</li>
<li><p>将下一结点赋值给<script type="math/tex">q</script>；</p>
</li>
<li><p>释放<script type="math/tex">p</script>；</p>
</li>
<li><p>将<script type="math/tex">q</script>赋值给<script type="math/tex">p</script></p>
</li>
</ol>
<p>实现代码算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：顺序线性表L已存在，操作结果：将L重置为空表 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p, q;</span><br><span class="line"><span class="comment">/* p指向第一个结点 */</span></span><br><span class="line">p = (*L)-&gt;next;</span><br><span class="line"><span class="comment">/* 没到表尾 */</span></span><br><span class="line"><span class="keyword">while</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 头结点指针域为空 */</span></span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$p$指向一个结点，它除了有<strong>数据域</strong>，还有<strong>指针域</strong>。在做<script type="math/tex">free(p);</script>时，其实是在对整个结点进行删除和内存释放的工作</p>
<h1 id="3-10-单链表结构与顺序存储结构优缺点"><a href="#3-10-单链表结构与顺序存储结构优缺点" class="headerlink" title="3.10 单链表结构与顺序存储结构优缺点"></a>3.10 单链表结构与顺序存储结构优缺点</h1><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/35import.png" alt></p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多</li>
</ul>
<h1 id="3-11-静态链表"><a href="#3-11-静态链表" class="headerlink" title="3.11 静态链表"></a>3.11 静态链表</h1><p>让数组的元素都是由两个数据域组成，<script type="math/tex">data</script>和<script type="math/tex">cur</script>。数组的每个下标都对应一个<script type="math/tex">data</script>和一个<script type="math/tex">cur</script>。数据域<script type="math/tex">data</script>，用来存放数据元素，就是通常要处理的数据；而<script type="math/tex">cur</script>相当于单链表中的<script type="math/tex">next</script>指针，存放该元素的后继在数组中的下标，把<script type="math/tex">cur</script>叫做<strong>游标</strong></p>
<p>用数组描述的链表叫做<strong>静态链表(</strong>游标实现法)。为了方便插入数据，通常会把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性表的静态链表存储结构 */</span></span><br><span class="line"><span class="comment">/* 假设链表的最大长度是1000 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="comment">/* 游标（Cursor），为0时表示无指向 */</span></span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line">&#125; Component,StaticLinkList[MAXSIZE]; <span class="comment">/* 对于不提供结构struct的程序设计语言，可以使用一对并行数组data和cur来处理。 */</span></span><br></pre></td></tr></table></figure>
<p>对数组第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用的数组元素称为<strong>备用链表</strong>。而数组第一个元素，即下标为<strong>0</strong>的元素的<strong>cur</strong>就存放备用链表的第一个结点的下标；而数组的最后一个元素的<strong>cur</strong>则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为<strong>0</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/36import.png" alt></p>
<p>图示相当于初始化的数组状态</p>
<p>见下面代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将一维数组space中各分量链成一备用链表， */</span></span><br><span class="line"><span class="comment">/* space[0].cur为头指针，"0"表示空指针 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">space[i].cur = i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line">space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设已经将数据存入静态链表，比如分别存放着“甲”、“乙”、“丁”、“戊”、“己”、“庚”等数据</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/37import.png" alt></p>
<p><strong>“甲”</strong>这里就存有下一元素<strong>“乙”</strong>的游标<script type="math/tex">2</script>，<strong>“乙”</strong>则存有下一元素<strong>“丁”</strong>的下标<script type="math/tex">3</script>。而<strong>“庚”</strong>是最后一个有值元素，所以它的<strong>cur</strong>设置为<script type="math/tex">0</script>。而最后一个元素的<strong>cur</strong>则因<strong>“甲”</strong>是第一有值元素而存有它的下标为<script type="math/tex">1</script>。而第一个元素则因空闲空间的第一个元素下标为<script type="math/tex">7</script>，所以它的<strong>cur</strong>存有<script type="math/tex">7</script></p>
<h2 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h2><p>静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若备用空间链表非空，则返回分配的结点下标,否则返回0 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SLL</span><span class="params">(StaticLinkList space)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 当前数组第一个元素的cur存的值，就是要返回的第一个备用空闲的下标 */</span></span><br><span class="line"><span class="keyword">int</span> i = space[<span class="number">0</span>].cur;</span><br><span class="line"><span class="comment">/* 由于要拿出一个分量来使用了，所以就得把它的下一个分量用来做备用 */</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作用就是返回一个下标值，即数组头元素的<strong>cur</strong>存的第一个空闲的下标</p>
</blockquote>
<p>从上面的图示例子来看，其实就是返回<script type="math/tex">7</script>，然后把分量<script type="math/tex">7</script>的<strong>cur</strong>值赋值给头元素，即把<script type="math/tex">8</script>给<strong>space[0].cur</strong>，之后就可以继续分配新的空闲分量，实现类似<strong>malloc()</strong>函数的作用</p>
<p>在<strong>“乙”</strong>和<strong>“丁”</strong>之间，插入一个值为<strong>“丙”</strong>的元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span> <span class="comment">/* 在L中第i个元素之前插入新的数据元素e */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, k, l;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>; <span class="comment">/* 注意k首先是最后一个元素的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">j = Malloc_SSL(L); <span class="comment">/* 获得空闲分量的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line">L[j].data = e; <span class="comment">/* 将数据赋值给此分量的data */</span></span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++) <span class="comment">/* 找到第i个元素之前的位置 */</span></span><br><span class="line">k = L[k].cur;</span><br><span class="line">L[j].cur = L[k].cur; <span class="comment">/* 把第i个元素之前的cur赋值给新元素的cur */</span></span><br><span class="line">L[k].cur = j; <span class="comment">/* 把新元素的下标赋值给第i个元素之前元素的cur */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当执行插入语句时，目的是要在<strong>“乙”</strong>和<strong>“丁”</strong>之间插入<strong>“丙”</strong>。调用代码时，输入<script type="math/tex">i</script>值为<script type="math/tex">3</script></li>
<li>第<script type="math/tex">4</script>行让<strong>k=MAXSIZE-1=999</strong></li>
<li>第<script type="math/tex">7</script>行，<strong>j=Malloc_SSL(L)=7</strong>。此时下标为<script type="math/tex">0</script>的<strong>cur</strong>也因为<script type="math/tex">7</script>要被占用而更改备用链表的值为<script type="math/tex">8</script></li>
<li>第<strong>11～12</strong>行，<strong>for</strong>循环<strong>l</strong>由<script type="math/tex">1</script>到<script type="math/tex">2</script>，执行两次。代码<strong>k=L[k].cur;</strong>使得<strong>k=999</strong>,得到<strong>k=L[999].cur=1</strong>，再得到<strong>k=L[1].cur=2</strong></li>
<li>第<script type="math/tex">13</script>行，<strong>L[j].cur=L[k].cur;</strong>因<script type="math/tex">j=7</script>，而<script type="math/tex">k=2</script>得到<strong>L[7].cur=L[2].cur=3</strong>。</li>
<li>第<script type="math/tex">14</script>行，<strong>L[k].cur=j;</strong>意思就是<strong>L[2].cur=7。</strong>让<strong>“乙”</strong>的<strong>cur</strong>改为指向<strong>“丙”</strong>的下标<script type="math/tex">7</script></li>
</ul>
<p>实现了在数组中，不移动元素，却插入了数据的操作</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/38import.png" alt></p>
<h2 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h2><p>删除<strong>甲</strong>元素时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除在L中第i个数据元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">k = L[k].cur;</span><br><span class="line">j = L[k].cur;</span><br><span class="line">L[k].cur = L[j].cur;</span><br><span class="line">Free_SSL(L, j);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for</strong>循环因为<strong>i=1</strong>而不操作，<strong>j=L[999].cur=1，L[k].cur=L[j].cur</strong>也就是<strong>L[999].cur = L[1].cur = 2</strong>，即“乙”现在才是第一个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将下标为k的空闲结点回收到备用链表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur; <span class="comment">/* 把第一个元素的cur值赋给要删除的分量cur */</span></span><br><span class="line">space[<span class="number">0</span>].cur = k; <span class="comment">/* 把要删除的分量下标赋值给第一个元素的cur */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来的第一个空位分量，即下标是<script type="math/tex">8</script>的分量，它降级了，把<script type="math/tex">8</script>给<strong>“甲”</strong>所在下标为<script type="math/tex">1</script>的分量的<strong>cur</strong>，也就是<strong>space[1].cur=space[0].cur=8</strong>，而<strong>space[0].cur=k=1</strong>其实就是让这个删除的位置成为第一个优先空位，把它存入第一个元素的<strong>cur</strong>中</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/39import.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line"><span class="keyword">while</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">i=L[i].cur;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h2><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/41import.png" alt></p>
<h1 id="3-12-循环链表"><a href="#3-12-循环链表" class="headerlink" title="3.12 循环链表"></a>3.12 循环链表</h1><p><strong>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）</strong></p>
<p>循环链表带有头结点的空链表：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/40import.png" alt></p>
<p>非空的循环链表<img src="https://baozou.gitbooks.io/-data-structure/content/assets/43import.png" alt></p>
<p>循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<strong>p-&gt;next</strong>是否为空，现在则是<strong>p-&gt;next</strong>不等于头结点，则循环未结束</p>
<p>单链表有了头结点时，可以用<script type="math/tex">O(1)</script>的时间访问第一个结点，访问到最后一个结点却需要<script type="math/tex">O(n)</script>时间，因为需要将单链表全部扫描一遍</p>
<p>改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/42import.png" alt></p>
<blockquote>
<p>终端结点用尾指针<strong>rear</strong>指示，查找终端结点是<script type="math/tex">O(1)</script>，开始结点是<strong>rear-&gt;next-&gt;next</strong>，时间复杂也为<script type="math/tex">O(1)</script></p>
</blockquote>
<p>将两个循环链表合并成一个表,尾指针分别是<strong>rearA</strong>和<strong>rearB</strong>:</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/45import.png" alt></p>
<p>合并：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/46import.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P=rearA-&gt;next;<span class="comment">//保存A表的头节点，即1</span></span><br><span class="line"></span><br><span class="line">rearA-&gt;next=rearB-&gt;next-&gt;next;<span class="comment">//将本是指向B表的第一个节点（不是头节点）赋值给rearA-&gt;next,即2</span></span><br><span class="line"></span><br><span class="line">rearB-&gt;next=p;<span class="comment">//将原A表的头节点赋值给rearB-&gt;next,即3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放p</span></span><br></pre></td></tr></table></figure>
<h1 id="3-13-双向链表"><a href="#3-13-双向链表" class="headerlink" title="3.13 双向链表"></a>3.13 双向链表</h1><p><strong>双向链表（double linkedlist）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</strong>双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性表的双向链表存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span> <span class="comment">/* 直接前驱指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span> <span class="comment">/* 直接后继指针 */</span></span><br><span class="line">&#125; DulNode, *DuLinkList;</span><br></pre></td></tr></table></figure>
<p>双向链表的循环带头结点的空链表：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/58import.png" alt></p>
<p>非空的循环的带头结点的双向链表：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/48import.png" alt></p>
<p>假设存储元素<script type="math/tex">e</script>的结点为<script type="math/tex">s</script>，要实现将结点<script type="math/tex">s</script>插入到结点<script type="math/tex">p</script>和<strong>p-&gt;next</strong>之间需要下面几步:</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/50import.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把p赋值给s的前驱，如图中1 */</span></span><br><span class="line">s-&gt;prior = p;</span><br><span class="line"><span class="comment">/* 把p-&gt;next赋值给s的后继，如图中2 */</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line"><span class="comment">/* 把s赋值给p-&gt;next的前驱，如图中3 */</span></span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line"><span class="comment">/* 把s赋值给p的后继，如图中4 */</span></span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
<p>顺序是先搞定<script type="math/tex">s</script>的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继</p>
<p>删除结点<script type="math/tex">p</script></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中1 */</span></span><br><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line"><span class="comment">/* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中2 */</span></span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line"><span class="comment">/* 释放结点 */</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>
<h1 id="3-14-总结回顾"><a href="#3-14-总结回顾" class="headerlink" title="3.14 总结回顾"></a>3.14 总结回顾</h1><p><strong>线性表是零个或多个具有相同类型的数据元素的有限序列</strong></p>
<p>两大结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">顺序存储结构</th>
<th style="text-align:center">链式存储结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">用一段地址连续的存储单元依次存储线性表的数据元素</td>
<td style="text-align:center">用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续的，也可以是不连续的,这些数据元素可以存在内存未被占用的任意位置</td>
</tr>
<tr>
<td style="text-align:center">插入和删除操作不方便</td>
<td style="text-align:center">不受固定的存储空间限制，可以比较快捷的插入和删除</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/55import.png" alt></p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第四章  栈与队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/大话数据结构-第四章  栈与队列/" itemprop="url">大话数据结构 第四章  栈与队列</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T20:47:00Z">
                2019-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-07T05:14:48Z">
                2019-03-07
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第四章  栈与队列/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第四章  栈与队列/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第四章  栈与队列/" class="leancloud_visitors" data-flag-title="大话数据结构 第四章  栈与队列">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          
            <h1 id="4-1-栈的定义"><a href="#4-1-栈的定义" class="headerlink" title="4.1 栈的定义"></a>4.1 栈的定义</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p><strong>栈（stack）是限定仅在表尾进行插入和删除操作的线性表</strong></p>
<p>允许插入和删除的一端称为<strong>栈顶（top）</strong>，另一端称为<strong>栈底（bottom）</strong>，不含任何数据元素的栈称为<strong>空栈</strong>栈又称为<strong>后进先出（LastIn First Out）</strong>的线性表，简称<strong>LIFO结构</strong></p>
<p>栈的插入操作，叫作<strong>进栈</strong>，也称<strong>压栈、入栈</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/56import.png" alt></p>
<p>栈的删除操作，叫作<strong>出栈</strong>，也有的叫作<strong>弹栈</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/57import.png" alt></p>
<h1 id="4-2-栈的抽象数据类型"><a href="#4-2-栈的抽象数据类型" class="headerlink" title="4.2 栈的抽象数据类型"></a>4.2 栈的抽象数据类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈（<span class="built_in">stack</span>）</span><br><span class="line">Data</span><br><span class="line">同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">Initstack(*S);初始化操作，建立一个空栈S。</span><br><span class="line">DestroyStack(*S);若栈存在，则销毁它。</span><br><span class="line">ClearStack(*S);将栈清空。</span><br><span class="line">StackEmpty(S);若栈为空，返回<span class="literal">true</span>;否则返回<span class="literal">false</span>。</span><br><span class="line">GetTop(S,*e);若栈存在且非空，用e返回S的栈顶元素。</span><br><span class="line">Push(*S,e);若栈S存在，插入新元素e到栈S中并成为栈顶元素。又称：进栈，压栈，入栈。</span><br><span class="line">Pop(*S,*e);删除栈S中栈顶元素，并用e返回其值。又称：出栈，弹栈。</span><br><span class="line">StackLength(S);返回栈S的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h1 id="4-3-栈的顺序存储结构及实现"><a href="#4-3-栈的顺序存储结构及实现" class="headerlink" title="4.3 栈的顺序存储结构及实现"></a>4.3 栈的顺序存储结构及实现</h1><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><p>下标为<script type="math/tex">0</script>的一端作为栈底，因为首元素都存在栈底，变化最小，若存储栈的长度为<strong>StackSize</strong>，则栈顶位置<strong>top</strong>必须小于<strong>StackSize</strong>。当栈存在一个元素时，<strong>top</strong>等于<script type="math/tex">0</script>，通常把空栈的判定条件定为<strong>top</strong>等于<script type="math/tex">-1</script></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType; <span class="comment">/* SElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p>栈普通情况、空栈和栈满的情况示意图(<strong>StackSize</strong>是<script type="math/tex">5</script>)</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/59import.png" alt></p>
<h2 id="栈的顺序存储结构——进栈操作"><a href="#栈的顺序存储结构——进栈操作" class="headerlink" title="栈的顺序存储结构——进栈操作"></a>栈的顺序存储结构——进栈操作</h2><p>栈的插入，即进栈操作</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/60import.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;top == MAXSIZE <span class="number">-1</span>) <span class="comment">/* 栈满 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">S-&gt;top++; <span class="comment">/* 栈顶指针增加一 */</span></span><br><span class="line">S-&gt;data[S-&gt;top]=e; <span class="comment">/* 将新插入元素赋值给栈顶空间 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的顺序存储结构——出栈"><a href="#栈的顺序存储结构——出栈" class="headerlink" title="栈的顺序存储结构——出栈"></a>栈的顺序存储结构——出栈</h2><p>操作出栈操作<strong>pop：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *S, SElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e = S-&gt;data[S-&gt;top]; <span class="comment">/* 将要删除的栈顶元素赋值给e */</span></span><br><span class="line">S-&gt;top--; <span class="comment">/* 栈顶指针减一 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者时间复杂度均是<script type="math/tex">O(1)</script></p>
<h1 id="4-4-两栈共享空间"><a href="#4-4-两栈共享空间" class="headerlink" title="4.4 两栈共享空间"></a>4.4 两栈共享空间</h1><p>用一个数组来存储两个栈，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为<script type="math/tex">0</script>处，另一个栈为数组的末端，即下标为数组长度<script type="math/tex">n-1</script>处。两个栈如果增加元素，就是两端点向中间延伸</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/61import.png" alt></p>
<p>两栈共享空间的结构的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两栈共享空间结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top1; <span class="comment">/* 栈1栈顶指针 */</span></span><br><span class="line"><span class="keyword">int</span> top2; <span class="comment">/* 栈2栈顶指针 */</span></span><br><span class="line">&#125; SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的<strong>push</strong>方法，除了要插入元素值参数外，还需要有一个判断是栈<script type="math/tex">1</script>还是栈<script type="math/tex">2</script>的栈号参数<strong>stackNumber</strong></p>
<p>插入元素的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack *S, SElemType e, <span class="keyword">int</span> stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 栈已满，不能再push新元素了 */</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top1 + <span class="number">1</span> == S-&gt;top2)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="comment">/* 栈1有元素进栈 */</span></span><br><span class="line"><span class="keyword">if</span> (stackNumber == <span class="number">1</span>)</span><br><span class="line"><span class="comment">/* 若栈1则先top1+1后给数组元素赋值 */</span></span><br><span class="line">S-&gt;data[++S-&gt;top1] = e;</span><br><span class="line"><span class="comment">/* 栈2有元素进栈 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">2</span>)</span><br><span class="line"><span class="comment">/* 若栈2则先top2-1后给数组元素赋值 */</span></span><br><span class="line">S-&gt;data[--S-&gt;top2] = e;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于两栈共享空间的<strong>pop</strong>方法，参数就只是判断栈<script type="math/tex">1</script>栈<script type="math/tex">2</script>的参数<strong>stackNumber</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack *S,SElemType *e,<span class="keyword">int</span> stackNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stackNumber==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈1已经是空栈，溢出 */</span></span><br><span class="line">*e=S-&gt;data[S-&gt;top1--]; <span class="comment">/* 将栈1的栈顶元素出栈 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top2==MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈2已经是空栈，溢出 */</span></span><br><span class="line">*e=S-&gt;data[S-&gt;top2++]; <span class="comment">/* 将栈2的栈顶元素出栈 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-5-栈的链式存储结构及实现"><a href="#4-5-栈的链式存储结构及实现" class="headerlink" title="4.5 栈的链式存储结构及实现"></a>4.5 栈的链式存储结构及实现</h1><h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><p><strong>栈的链式存储结构，简称为链栈</strong></p>
<p>由于单链表有头指针，而栈顶指针也是必须的，所以比较好的办法是把栈顶放在单链表的头部。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/62import.png" alt></p>
<p>对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是否溢出的问题。但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是<strong>top=NULL</strong>的时候</p>
<p>链栈的结构代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链栈结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LinkStackPtr top;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>
<h2 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h2><p>对于链栈的进栈<strong>push</strong>操作，假设元素值为<strong>e</strong>的新结点是<strong>s，top</strong>为栈顶指针</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/63import.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S,SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=S-&gt;top; <span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继，见图中1 */</span></span><br><span class="line">S-&gt;top=s; <span class="comment">/* 将新的结点s赋值给栈顶指针，见图中2 */</span></span><br><span class="line">S-&gt;count++;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h2><p>假设变量<script type="math/tex">p</script>用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放<script type="math/tex">p</script>即可</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/64import.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkStackPtr p;</span><br><span class="line"><span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=S-&gt;top-&gt;data;</span><br><span class="line">p=S-&gt;top; <span class="comment">/* 将栈顶结点赋值给p，见图中③ */</span></span><br><span class="line">S-&gt;top=S-&gt;top-&gt;next; <span class="comment">/* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">/* 释放结点p */</span></span><br><span class="line">S-&gt;count--;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链栈的进栈<strong>push</strong>和出栈<strong>pop</strong>没有任何循环操作，时间复杂度均为<script type="math/tex">O(1)</script>。</p>
<p>顺序栈与链栈：</p>
<ul>
<li>时间复杂度上均为<script type="math/tex">O(1)</script>。</li>
<li>对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制</li>
<li>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，如果它的变化在可控范围内，建议使用顺序栈</li>
</ul>
<h1 id="4-6-栈的作用"><a href="#4-6-栈的作用" class="headerlink" title="4.6 栈的作用"></a>4.6 栈的作用</h1><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质</p>
<h1 id="4-7-栈的应用——递归"><a href="#4-7-栈的应用——递归" class="headerlink" title="4.7 栈的应用——递归"></a>4.7 栈的应用——递归</h1><h2 id="斐波那契数列实现"><a href="#斐波那契数列实现" class="headerlink" title="斐波那契数列实现"></a>斐波那契数列实现</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">月数</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">兔子对数</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">13</td>
<td style="text-align:center">21</td>
<td style="text-align:center">34</td>
<td style="text-align:center">55</td>
<td style="text-align:center">89</td>
<td style="text-align:center">144</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/66import.png" alt></p>
<blockquote>
<p>编号①的一对兔子经过六个月就变成8对兔子</p>
</blockquote>
<p>数学函数来定义就是：</p>
<script type="math/tex; mode=display">
F(n)=\left\{\begin{matrix}
0,& n = 0 & \\
1& n = 1 & \\
F(n-1)+F(n-2)& n \gt 1 &
\end{matrix}\right.</script><p>打印出前40位的斐波那契数列数。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* 斐波那契的递归函数 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( i &lt; <span class="number">2</span> )</span><br><span class="line"><span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Fbi(i - <span class="number">1</span>) + Fbi(i - <span class="number">2</span>); <span class="comment">/* 这里Fbi就是函数自己，等于在调用自己 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"迭代显示斐波那契数列：\n"</span>);</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[i<span class="number">-1</span>] + a[i<span class="number">-2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"递归显示斐波那契数列：\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, Fbi(i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Fbi(i)</strong>函数当<strong>i=5</strong>的执行过程</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/68import.png" alt></p>
<h2 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h2><p><strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">迭代</th>
<th style="text-align:center">递归</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">循环结构</td>
<td style="text-align:center">选择结构</td>
</tr>
<tr>
<td style="text-align:center">不需要反复调用函数和占用额外的内存</td>
<td style="text-align:center">使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存</td>
</tr>
</tbody>
</table>
</div>
<p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态</p>
<h1 id="4-8-栈的应用——四则运算表达式求"><a href="#4-8-栈的应用——四则运算表达式求" class="headerlink" title="4.8 栈的应用——四则运算表达式求"></a>4.8 栈的应用——四则运算表达式求</h1><h2 id="后缀（逆波兰）表示法定义"><a href="#后缀（逆波兰）表示法定义" class="headerlink" title="后缀（逆波兰）表示法定义"></a>后缀（逆波兰）表示法定义</h2><p>“9+(3-1)×3+10÷2”用后缀表示法表示：“9 3 1-3*+102/+”</p>
<p>叫后缀的原因在于所有的符号都是在要运算数字的后面出现</p>
<h2 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h2><p>后缀表达式：9 3 1-3*+10 2/+</p>
<p>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果</p>
<ol>
<li>初始化一个空栈。此栈用来对要运算的数字进出使用，如左图</li>
<li>后缀表达式中前三个都是数字，所以9、3、1进栈，如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/70import.png" alt></li>
<li>接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈，如左图</li>
<li>接着是数字3进栈，如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/71import.png" alt></li>
<li>后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈，如左图</li>
<li>下面是“+”，所以栈中6和9出栈，9与6相加，得到15，将15进栈，如图右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/72import.png" alt></li>
<li>接着是10与2两数字进栈，如左图所示</li>
<li>接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈，如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/73import.png" alt></li>
<li>最后一个是符号“+”，所以15与5出栈并相加，得到20，将20进栈，如图左图</li>
<li>结果是20出栈，栈变为空，如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/74import.png" alt></li>
</ol>
<h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><p>平时所用的标准四则运算表达式，即“9+(3-1)×3+10÷2”叫做中缀表达式</p>
<p>规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止</p>
<ol>
<li>初始化一空栈，用来对符号进出栈使用，如左图</li>
<li>第一个字符是数字9，输出9，后面是符号“+”，进栈。如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/75import.png" alt></li>
<li>第三个字符是“(”，依然是符号，因其只是左括号，还未配对，故进栈。如左图</li>
<li>第四个字符是数字3，输出，总表达式为93，接着是“-”，进栈。如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/76import.png" alt></li>
<li>接下来是数字1，输出，总表达式为 9 3 1，后面是符号“)”，此时，需要去匹配此前的“(”，所以栈顶依次出栈，并输出，直到“(”出栈为止。此时左括号上方只有“-”，因此输出“-”。总的输出表达式为 9 3 1 -。如左图</li>
<li>紧接着是符号“×”，因为此时的栈顶符号为“+”号，优先级低于“×”，因此不输出，“*”进栈。接着是数字3，输出，总的表达式为 9 3 1 - 3。如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/77import.png" alt></li>
<li>之后是符号“+”，此时当前栈顶元素“”比这个“+”的优先级高，因此栈中元素出栈并输出（没有比“+”号更低的优先级，所以全部出栈），总输出表达式为9 3 1 - 3 * +。然后将当前这个符号“+”进栈。前6张图的栈底的“+”是指中缀表达式中开头的9后面那个“+”，而下图中的栈底（也是栈顶）的“+”是指“9+(3-1)×3+”中的最后一个“+”。</li>
<li>紧接着数字10，输出，总表达式变为9 3 1 - 3 * + 10。后是符号“÷”，所以“/”进栈。如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/78import.png" alt></li>
<li>最后一个数字2，输出，总的表达式为9 31- 3 * + 10 2。如左图</li>
<li>因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为9 3 1 - 3 * +10 2 / +。如右图<img src="https://baozou.gitbooks.io/-data-structure/content/assets/79import.png" alt></li>
</ol>
<h1 id="4-9-队列的定义"><a href="#4-9-队列的定义" class="headerlink" title="4.9 队列的定义"></a>4.9 队列的定义</h1><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</strong></p>
<p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。假设队列是<script type="math/tex">q=(a_1,a_2,\cdots,a_n)</script>，那么<script type="math/tex">a_1</script>就是队头元素，而<script type="math/tex">a_n</script>是队尾元素。删除时，总是从<script type="math/tex">a_1</script>开始，而插入时，列在最后</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/80import.png" alt></p>
<h1 id="4-10-队列的抽象数据类型"><a href="#4-10-队列的抽象数据类型" class="headerlink" title="4.10 队列的抽象数据类型"></a>4.10 队列的抽象数据类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line">Data</span><br><span class="line">同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">InitQueue(*Q): 初始化操作，建立一个空队列Q。</span><br><span class="line">DestroyQueue(*Q): 若队列Q存在，则销毁它。</span><br><span class="line">ClearQueue(*Q): 将队列Q清空。</span><br><span class="line">QueueEmpty(Q): 若队列Q为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line">GetHead(Q, *e): 若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line">EnQueue(*Q, e): 若队列Q存在，插入新元素e到队列Q中并成为队尾元素。    </span><br><span class="line">DeQueue(*Q, *e): 删除队列Q中队头元素，并用e返回其值。</span><br><span class="line">QueueLength(Q): 返回队列Q的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<h1 id="4-11-循环队列"><a href="#4-11-循环队列" class="headerlink" title="4.11 循环队列"></a>4.11 循环队列</h1><h2 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h2><p>假设一个队列有<script type="math/tex">n</script>个元素，则顺序存储的队列需建立一个大于<script type="math/tex">n</script>的数组，并把队列的所有元素存储在数组的前<script type="math/tex">n</script>个单元，数组下标为<script type="math/tex">0</script>的一端即是队头。入队列操作就是在队尾追加一个元素，不需要移动任何元素，时间复杂度为<script type="math/tex">O(1)</script></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/81import.png" alt></p>
<p>队列元素的出列是在队头，即下标为<script type="math/tex">0</script>的位置，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为<script type="math/tex">0</script>的位置不为空，此时时间复杂度为<script type="math/tex">O(n)</script></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/82import.png" alt></p>
<p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，引入两个指针，<strong>front</strong>指针指向队头元素，<strong>rear</strong>指针指向队尾元素的<strong>下一个位置</strong>，当front等于rear时，此队列不是还剩一个元素，而是空队列。</p>
<p>假设是长度为<script type="math/tex">5</script>的数组，初始状态，空队列如左图，front与rear指针均指向下标为<script type="math/tex">0</script>的位置。然后入队<script type="math/tex">a_1a_2,a_3,a_4</script>，front指针依然指向下标为<script type="math/tex">0</script>位置，而rear指针指向下标为<script type="math/tex">4</script>的位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/83import.png" alt></p>
<p>出队<script type="math/tex">a_1,a_2</script>，front指针指向下标为<script type="math/tex">2</script>的位置，rear不变，如左图，再入队<script type="math/tex">a_5</script>，front指针不变，rear指针移动到数组之外</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/84import.png" alt></p>
<p>如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，下标为<script type="math/tex">0</script>和<script type="math/tex">1</script>的地方还是空闲的,这种现象叫做<strong>假溢出</strong></p>
<h2 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h2><p><strong>队列的这种头尾相接的顺序存储结构称为循环队列</strong></p>
<p>rear可以改为指向下标为<script type="math/tex">0</script>的位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/85import.png" alt></p>
<p>接着入队<script type="math/tex">a_6</script>，将它放置于下标为<script type="math/tex">0</script>处，rear指针指向下标为<script type="math/tex">1</script>处，如左图。再入队<script type="math/tex">a_7</script>，则rear指针就与front指针重合，同时指向下标为<script type="math/tex">2</script>的位置，如右图</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/86import.png" alt></p>
<p>如何判断此时的队列究竟是空还是满呢？</p>
<ul>
<li>办法一：设置一个标志变量<strong>flag</strong>，当front==rear，且flag=<script type="math/tex">0</script>时为队列空，当front==rear，且flag=<script type="math/tex">1</script>时为队列满。</li>
<li>办法二：当队列空时，条件就是front=rear，当队列满时，保留一个元素空间，如下图。也就是说，队列满时，数组中还有一个空闲单元，就认为此队列已经满了，即不允许上图右图情况出现</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/87import.png" alt></p>
<p>由于rear可能比front大，也可能比front小，若队列的最大尺寸为QueueSize，队列满的条件是</p>
<script type="math/tex; mode=display">
(rear+1)\%QueueSize==front</script><p>（取模“%”的目的就是为了整合rear与front大小为一个问题）。</p>
<ul>
<li>比如<script type="math/tex">QueueSize = 5,front=0,rear=4,(4+) \% 5=0</script>，所以此时队列满。比如<script type="math/tex">front=2</script>而<script type="math/tex">rear=1</script>。<script type="math/tex">(1+1)\%5=2</script>，此时队列也是满的。</li>
<li><script type="math/tex">front=2</script>而<script type="math/tex">rear=0,(0+1)\%5=1,1\neq2</script>，此时队列并没有满。</li>
<li>当<script type="math/tex">rear>front</script>时，队列的长度为<script type="math/tex">rear-front</script>。当<script type="math/tex">rear<front</script>时，队列长度分为两段，一段是<script type="math/tex">QueueSize-front</script>，另一段是<script type="math/tex">0+rear</script>，加在一起，队列长度为<script type="math/tex">rear-front+QueueSize</script>。因此通用的计算队列长度公式为：</li>
</ul>
<script type="math/tex; mode=display">
(rear-front+QueueSize)\%QueueSize</script><p>循环队列的顺序存储结构代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front; <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="keyword">int</span> rear; <span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>循环队列的初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环队列求队列长度代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环队列的入队列操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front) <span class="comment">/* 队列满的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e; <span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环队列的出队列操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="comment">/* 队列空的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front]; <span class="comment">/* 将队头元素赋值给e */</span></span><br><span class="line">Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE; <span class="comment">/* front指针向后移一位置， */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-12-队列的链式存储结构及实现"><a href="#4-12-队列的链式存储结构及实现" class="headerlink" title="4.12 队列的链式存储结构及实现"></a>4.12 队列的链式存储结构及实现</h1><p><strong>队列的链式存储结构就是线性表的单链表，只不过它只能尾进头出，简称为链队列</strong>。</p>
<p>将队头指针指向链队列的头结点，队尾指针指向终端结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/88import.png" alt></p>
<p>空队列时，front和rear都指向头结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/89import.png" alt></p>
<p>链队列的结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> /* 队列的链表结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>
<h2 id="队列的链式存储结构——入队操作"><a href="#队列的链式存储结构——入队操作" class="headerlink" title="队列的链式存储结构——入队操作"></a>队列的链式存储结构——入队操作</h2><p>入队操作时就是在链表尾部插入结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/90import.png" alt></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q,QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr s=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!s) <span class="comment">/* 存储分配失败 */</span></span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next=s; <span class="comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中1 */</span></span><br><span class="line">Q-&gt;rear=s; <span class="comment">/* 把当前的s设置为队尾结点，rear指向s，见图中2 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列的链式存储结构——出队操作"><a href="#队列的链式存储结构——出队操作" class="headerlink" title="队列的链式存储结构——出队操作"></a>队列的链式存储结构——出队操作</h2><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/91import.png" alt></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p=Q-&gt;front-&gt;next; <span class="comment">/* 将欲删除的队头结点暂存给p，见图中1 */</span></span><br><span class="line">*e=p-&gt;data; <span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中2 */</span></span><br><span class="line"><span class="keyword">if</span>(Q-&gt;rear==p) <span class="comment">/* 若队头就是队尾，则删除后将rear指向头结点，见图中3 */</span></span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环队列与链队列：</p>
<ul>
<li>时间上，基本操作都为<script type="math/tex">O(1)</script>，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。</li>
<li>空间上，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。</li>
<li>在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度时，则用链队列</li>
</ul>
<h1 id="4-13-总结回顾"><a href="#4-13-总结回顾" class="headerlink" title="4.13 总结回顾"></a>4.13 总结回顾</h1><p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p>
<p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。</p>
<ul>
<li>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</li>
<li>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是<script type="math/tex">O(n)</script>的时间复杂度变成了<script type="math/tex">O(1)</script>。</li>
<li>都可以通过链式存储结构来实现，实现原则上与线性表基本相同</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/92import.png" alt></p>

          
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/07/莫烦Python爬虫笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/莫烦Python爬虫笔记/" itemprop="url">莫烦Python爬虫笔记</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T16:31:00Z">
                2019-03-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-03-06T01:16:34Z">
                2019-03-06
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/爬虫/" itemprop="url" rel="index">
                    <span itemprop="name">爬虫</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/爬虫/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/07/莫烦Python爬虫笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/07/莫烦Python爬虫笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/07/莫烦Python爬虫笔记/" class="leancloud_visitors" data-flag-title="莫烦Python爬虫笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        
          <h1 id="爬虫简介"><a href="#爬虫简介" class="headerlink" title="爬虫简介"></a>爬虫简介</h1><h2 id="1-1-了解网页结构"><a href="#1-1-了解网页结构" class="headerlink" title="1.1  了解网页结构"></a>1.1  了解网页结构</h2><h3 id="网页基本组成部分"><a href="#网页基本组成部分" class="headerlink" title="网页基本组成部分"></a>网页基本组成部分</h3><p>在 HTML 中, 基本上所有的实体内容, 都会有个 tag 来框住它. 而这个被tag 住的内容, 就可以被展示成不同的形式, 或有不同的功能</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/03/07/莫烦Python爬虫笔记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    <div>
     
  </div>


    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>



  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">


            
              <img class="site-author-image" itemprop="image" src="/img/avatar.png" alt="暴走">
            


              <p class="site-author-name" itemprop="name">暴走</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>
<script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
<div class="aplayer" data-id="D89A1236EF4D99ED641FFD846F1A23AF" data-server="kugou " data-type="song" data-autoplay="false" data-mode="single"></div>
<br>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/baozouai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:baozouai@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>
    
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">暴走</span>

  
</div>



  <span class="post-meta-divider">|</span>






<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共136.2k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>
    
    
    
    
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  
  <script type="text/javascript" color="255,0,0" opacity="0.5" zindex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  




  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>


  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"notes-iissnan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("S5fCBBMaimjEzLztiJKSBnbL-gzGzoHsz", "m3rlGieJoVqNqhc9YbnO52cM");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.0.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.0.0"></script>


  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":80,"height":80},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
