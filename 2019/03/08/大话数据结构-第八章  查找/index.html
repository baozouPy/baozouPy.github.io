<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<script src="/js/src/photoswipe.min.js?v=6.0.0"></script>
<script src="/js/src/photoswipe-ui-default.min.js?v=6.0.0"></script>


<head><meta name="generator" content="Hexo 3.9.0">

  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/c6c3b5e3.js","daovoice")
  daovoice('init', {
      app_id: "c6c3b5e3"
    });
  daovoice('update');
  </script>






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  



  
  
    
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">




  <link rel="icon" type="image/png" sizes="16x16" href="/favicon16.ico?v=6.0.0">






  <meta name="keywords" content="数据结构,算法,">





  <link rel="alternate" href="/atom.xml" title="暴走的技术博客" type="application/atom+xml">






<meta name="description" content="8.1 查找概论查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合">
<meta name="keywords" content="数据结构,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="大话数据结构 第八章  查找">
<meta property="og:url" content="https://www.baozouai.com/2019/03/08/大话数据结构-第八章  查找/index.html">
<meta property="og:site_name" content="暴走的技术博客">
<meta property="og:description" content="8.1 查找概论查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/400import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/200import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/180import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/161import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/162import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/163import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/164import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/165import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/166import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/167import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/168import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/169import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/170import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/174import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/175import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/176import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/178import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/179import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/182import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/183import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/181import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/191import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/193import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/194import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/195import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/196import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/197import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/198import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/199import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/201import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/202import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/203import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/205import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/204import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/206import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/207import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/208import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/209import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/210import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/211import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/213import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/215import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/216import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/217import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/218import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/219import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/220import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/221import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/225import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/229import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/230import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/231import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/239import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/240import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/241import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/243import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/244import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/250import.png">
<meta property="og:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/245import.png">
<meta property="og:updated_time" content="2019-04-04T12:20:35.190Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大话数据结构 第八章  查找">
<meta name="twitter:description" content="8.1 查找概论查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合">
<meta name="twitter:image" content="https://baozou.gitbooks.io/-data-structure/content/assets/400import.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.baozouai.com/2019/03/08/大话数据结构-第八章  查找/">





  <title>大话数据结构 第八章  查找 | 暴走的技术博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a46909e912a122ce69d3b5e9a8dc661";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>
<!--动态标题-->
<script type="text/javascript" src="/js/src/dytitle.js"></script>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>




  
  
  
    
  



  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/baozouai" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">暴走的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">The people who are crazy enough to change the world are the ones who do！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br>
            
            书单
          </a>
        </li>
      
        
        <li class="menu-item menu-item-movies">
          <a href="/movies" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-film"></i> <br>
            
            电影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>
    
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

      
  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.baozouai.com/2019/03/08/大话数据结构-第八章  查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="暴走">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/img/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="暴走的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">大话数据结构 第八章  查找</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:55:00+08:00">
                2019-03-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-04-04T20:20:35+08:00">
                2019-04-04
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/大话数据结构-第八章  查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/大话数据结构-第八章  查找/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/03/08/大话数据结构-第八章  查找/" class="leancloud_visitors" data-flag-title="大话数据结构 第八章  查找">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  37
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      

      
        <h1 id="8-1-查找概论"><a href="#8-1-查找概论" class="headerlink" title="8.1 查找概论"></a>8.1 查找概论</h1><p><strong>查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合</strong><br><a id="more"></a><br><strong>关键字（Key）是数据元素中某个数据项的值，又称为键值</strong>，可以标识一个数据元素，也可以标识一个记录的某个数据项（字段），称为关键码，如①和②</p>
<p><strong>若关键字可以唯一地标识一个记录，称此关键字为主关键字（Primary Key）</strong>。意味着对不同的记录其主关键字均不相同。主关键字所在的数据项称为主关键码，如③和④</p>
<p><strong>可以识别多个数据元素（或记录）的关键字，称为次关键字（SecondaryKey）</strong>，如⑤。可以理解为是不以唯一标识一个数据元素（或记录）的关键字，对应的数据项就是次关键码</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/400import.png" alt></p>
<p><strong>查找（Searching）是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）</strong></p>
<p>若表中存在这样的一个记录，则称查找是成功的，此时查找的结果给出整个记录的信息，或指示该记录在查找表中的位置。比如查找主关键码“<strong>代码</strong>”的主关键字为“sh601398”的记录时，得到第2条唯一记录。查找次关键码“涨跌额”为“<strong>-0.11</strong>”的记录时，得到两条记录</p>
<p>若表中不存在关键字等于给定值的记录，称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针</p>
<p>查找表按照操作方式来分有两大种：</p>
<ul>
<li><strong>静态查找表（Static Search Table）</strong>：只作查找操作的查找表</li>
</ul>
<p>主要操作：</p>
<ol>
<li>查询某个“特定的”数据元素是否在查找表中</li>
<li><p>检索某个“特定的”数据元素和各种属性</p>
</li>
<li><p><strong>动态查找表（Dynamic Search Table）</strong>：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</p>
</li>
</ol>
<p>主要操作：</p>
<ol>
<li>查找时插入数据元素</li>
<li>查找时删除数据元素</li>
</ol>
<p>面向查找操作的数据结构称为查找结构</p>
<h1 id="8-2-顺序表查找"><a href="#8-2-顺序表查找" class="headerlink" title="8.2 顺序表查找"></a>8.2 顺序表查找</h1><p><strong>顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术</strong></p>
<p>查找过程是：</p>
<ol>
<li>从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较</li>
<li>若某个记录的关键字和给定值相等，则查找成功，找到所查的记录</li>
<li>如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</li>
</ol>
<h2 id="顺序表查找算法"><a href="#顺序表查找算法" class="headerlink" title="顺序表查找算法"></a>顺序表查找算法</h2><p>顺序查找的算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 顺序查找，a为数组，n为要查找的数组长度，   key为要查找的关键字 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)          </span><br><span class="line">        <span class="keyword">if</span> (a[i] == key)            </span><br><span class="line">            <span class="keyword">return</span> i;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表查找优化"><a href="#顺序表查找优化" class="headerlink" title="顺序表查找优化"></a>顺序表查找优化</h2><p>设置一个哨兵，可以解决不需要每次让i与n作比较</p>
<p>改进后的顺序查找算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 有哨兵顺序查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sequential_Search2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="comment">/* 设置a[0]为关键字值，我们称之为“哨兵” */</span>    </span><br><span class="line">    a[<span class="number">0</span>] = key;        </span><br><span class="line">    <span class="comment">/* 循环从数组尾部开始 */</span>    </span><br><span class="line">    i = n;             </span><br><span class="line">    <span class="keyword">while</span> (a[i] != key)        </span><br><span class="line">        i--;    </span><br><span class="line">    <span class="comment">/* 返回0则说明查找失败 */</span>    </span><br><span class="line">    <span class="keyword">return</span> i;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码是从尾部开始查找，由于a[0]=key，如果在a[i]中有key则返回i值，查找成功。否则一定在最终的a[0]处等于key，此时返回的是0，即说明a[1]～a[n]中没有关键字key，查找失败</p>
<p>时间复杂度为<script type="math/tex">O(n)</script></p>
<p>顺序查找技术n很大时，查找效率极为低下，不过优点是算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。</p>
<p>由于查找概率的不同，将容易查找到的记录放在前面，不常用的记录放置在后面，效率可以大幅提高</p>
<h1 id="8-3-有序表查找"><a href="#8-3-有序表查找" class="headerlink" title="8.3 有序表查找"></a>8.3 有序表查找</h1><p><strong>折半查找（Binary Search）技术，又称为二分查找。前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。</strong></p>
<p><strong>折半查找的基本思想：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</strong></p>
<p>有序表数组{0,1,16,24,35,47,59,62,73,88,99}，除0下标外共10个数字。对它进行查找是否存在62这个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> low, high, mid;    </span><br><span class="line">    <span class="comment">/* 定义最低下标为记录首位 */</span>    </span><br><span class="line">    low = <span class="number">1</span>;                           </span><br><span class="line">    <span class="comment">/* 定义最高下标为记录末位 */</span>    </span><br><span class="line">    high = n;                          </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)    </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">/* 折半 */</span>        </span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;            </span><br><span class="line">        <span class="comment">/* 若查找值比中值小 */</span>        </span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid])                     </span><br><span class="line">            <span class="comment">/* 最高下标调整到中位下标小一位 */</span>           </span><br><span class="line">            high = mid - <span class="number">1</span>;                </span><br><span class="line">        <span class="comment">/* 若查找值比中值大 */</span>        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])                 </span><br><span class="line">            <span class="comment">/* 最低下标调整到中位下标大一位 */</span>            </span><br><span class="line">            low = mid + <span class="number">1</span>;                 </span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            <span class="comment">/* 若相等则说明mid即为查找到的位置 */</span>            </span><br><span class="line">            <span class="keyword">return</span> mid;                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>将这个数组的查找过程绘制成一棵二叉树，如果查找的关键字不是中间记录47的话，折半查找等于是把静态有序查找表分成了两棵子树，即查找结果只需要找其中的一半数据记录即可，等于工作量少了一半，然后继续折半查找</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/200import.png" alt></p>
<p>折半算法的时间复杂度为<script type="math/tex">O(\log n)</script></p>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>折半查找代码改进为：</p>
<script type="math/tex; mode=display">
mid =low +\frac{key-a[low]}{a[high]-a[low]}(high - low)</script><p>假设a[11]={0,1,16,24,35,47,59,62,73,88,99}，low=1，high=10，则a[low]=1，a[high]=99，如果要找的是key=16时，按原来折半的做法，需要四次才可以得到结果，如果用新办法，<script type="math/tex">\frac{key-a[low]}{a[high]-a[low]}</script>=(16-1)/(99-1)≈0.153，即mid≈1+0.153×(10-1)=2.377取整得到mid=2，只需要二次就查找到结果</p>
<p>折半查找算法的代码中更改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); <span class="comment">/* 插值 */</span></span><br></pre></td></tr></table></figure>
<p>得到了另一种有序表查找算法，插值查找法</p>
<p><strong>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法</strong>，其核心就在于插值的计算公式<script type="math/tex">\frac{key-a[low]}{a[high]-a[low]}</script>。时间复杂度是<script type="math/tex">O(\log n)</script>，对于表长较大，关键字分布又比较均匀的查找表，插值查找算法的平均性能比折半查找要好得多</p>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span>  <span class="comment">/* 斐波那契查找 */</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> low,high,mid,i,k;  </span><br><span class="line">    low=<span class="number">1</span>;  <span class="comment">/* 定义最低下标为记录首位 */</span>  </span><br><span class="line">    high=n; <span class="comment">/* 定义最高下标为记录末位 */</span>  </span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)  <span class="comment">/* 计算n位于斐波那契数列的位置 */</span></span><br><span class="line">        k++;  </span><br><span class="line">    <span class="keyword">for</span> (i=n;i&lt;F[k]<span class="number">-1</span>;i++)  <span class="comment">/* 将不满的数值补全 */</span></span><br><span class="line">        a[i]=a[n];  </span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)  </span><br><span class="line">    &#123;  </span><br><span class="line">        mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;  <span class="comment">/* 计算当前分隔的下标 */</span></span><br><span class="line">        <span class="keyword">if</span> (key&lt;a[mid])  <span class="comment">/* 若查找记录小于当前分隔记录 */</span></span><br><span class="line">        &#123;  </span><br><span class="line">            high=mid<span class="number">-1</span>;       <span class="comment">/* 最高下标调整到分隔下标mid-1处 */</span></span><br><span class="line">            k=k<span class="number">-1</span>;              <span class="comment">/* 斐波那契数列下标减一位 */</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])  <span class="comment">/* 若查找记录大于当前分隔记录 */</span></span><br><span class="line">        &#123;  </span><br><span class="line">            low=mid+<span class="number">1</span>;        <span class="comment">/* 最低下标调整到分隔下标mid+1处 */</span></span><br><span class="line">            k=k<span class="number">-2</span>;              <span class="comment">/* 斐波那契数列下标减两位 */</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (mid&lt;=n)  </span><br><span class="line">                <span class="keyword">return</span> mid;     <span class="comment">/* 若相等则说明mid即为查找到的位置 */</span>  </span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                <span class="keyword">return</span> n;        <span class="comment">/* 若mid&gt;n说明是补全数值，返回n */</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始运行，参数a={0,1,16,24,35,47,59,62,73,88,99}，n=10，要查找的关键字key=59。斐波那契数列F={0,1,1,2,3,5,8,13,21,……}<img src="https://baozou.gitbooks.io/-data-structure/content/assets/180import.png" alt></li>
<li>第6～8行是计算当前的n处于斐波那契数列的位置。现在n=10，F[6]&lt;n&lt;F[7]，所以计算得出k=7</li>
<li>第9～10行，由于k=7，计算时是以F[7]=13为基础，而a中最大的仅是a[10]，后面的a[11]，a[12]均未赋值，这不能构成有序数列，因此将它们都赋值为最大的数组值，所以此时a[11]=a[12]=a[10]=99</li>
<li>第13行，mid=1＋F[7-1]-1=8，第一个要对比的数值从下标为8开始</li>
<li>由于此时key=59而a[8]=73，因此执行第16～17行，得到high=7，k=6<img src="https://baozou.gitbooks.io/-data-structure/content/assets/161import.png" alt></li>
<li>再次循环，mid=1＋F[6-1]-1=5。此时a[5]=47&lt;key，因此执行第21～22行，得到low=6，k=6-2=4。注意此时k下调2个单位<img src="https://baozou.gitbooks.io/-data-structure/content/assets/162import.png" alt></li>
<li>再次循环，mid=6＋F[4-1]-1=7。此时a[7]=62&gt;key，因此执行第16～17行，得到high=6，k=4-1=3<img src="https://baozou.gitbooks.io/-data-structure/content/assets/163import.png" alt></li>
<li>再次循环，mid=6＋F[3-1]-1=6。此时a[6]=59=key，因此执行第26～27行，得到返回值为6。程序运行结束</li>
</ol>
<p>如果key=99，此时查找循环第一次时，mid=8与上例是相同的，第二次循环时，mid=11，如果a[11]没有值就会使得与key的比较失败，为了避免这样的情况出现，第9～10行的代码就起到这样的作用</p>
<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当key=a[mid]时，查找就成功</li>
<li>当key&lt;a[mid]时，新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个</li>
<li>当key&gt;a[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个</li>
</ol>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/164import.png" alt></p>
<p>时间复杂度为<script type="math/tex">O(\log n)</script>，就平均性能来说，斐波那契查找要优于折半查找。如果是最坏情况，比如这里key=1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找</p>
<p>折半查找是进行加法与除法运算</p>
<script type="math/tex; mode=display">
mid=\frac{low+high}{2}</script><p>插值查找进行复杂的四则运算</p>
<script type="math/tex; mode=display">
mid =low +\frac{key-a[low]}{a[high]-a[low]}(high - low)</script><p>斐波那契查找是最简单加减法运算</p>
<script type="math/tex; mode=display">
mid=low+F[k-1]-1</script><p>在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。三种有序表的查找本质上是分隔点的选择不同，各有优劣</p>
<h1 id="8-4-线性索引查找"><a href="#8-4-线性索引查找" class="headerlink" title="8.4 线性索引查找"></a>8.4 线性索引查找</h1><p><strong>索引是把一个关键字与它对应的记录相关联的过程</strong>，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息</p>
<p><strong>线性索引是将索引项集合组织为线性结构，也称为索引表</strong></p>
<h2 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h2><p><strong>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</strong></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/165import.png" alt></p>
<p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong></p>
<h2 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h2><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p>
<ul>
<li>块内无序，即每一块内的记录不要求有序</li>
<li>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……只有块间有序，才有可能在查找时带来效率</li>
</ul>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引</p>
<p>分块索引的索引项结构分三个数据项：</p>
<ul>
<li>最大关键码，存储每一块中的最大关键字，使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大</li>
<li>存储了块中的记录个数，以便于循环时使用</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/166import.png" alt></p>
<p>在分块索引表中查找，分两步进行：</p>
<ol>
<li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，很容易利用折半、插值等算法得到结果。上图的数据集中查找62，由57&lt;62&lt;96得到62在第三个块中</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找</li>
</ol>
<p>分块索引的平均查找长度：</p>
<p>设n个记录的数据集被平均分成m块，每个块中有t条记录，显然n=m×t（m=n/t）。<script type="math/tex">L_b</script>为查找索引表的平均查找长度，因最好与最差的等概率原则，所以<script type="math/tex">L_b</script>的平均长度为<script type="math/tex">\frac{m+1}{2}</script>。<script type="math/tex">L_w</script>为块中查找记录的平均查找长度，同理可知平均查找长度为<script type="math/tex">\frac{t+1}{2}</script>。这样分块索引查找的平均查找长度为：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/167import.png" alt></p>
<p>最佳的情况就是分的块数m与块中的记录数t相同，此时意味着<script type="math/tex">n=m\times t=t^2</script>，即：</p>
<script type="math/tex; mode=display">
ASL_w=\frac{1}{2}\times(\frac{n}{t}+t)+1=t+1=\sqrt n+1</script><p>倒排索引</p>
<p>索引项的通用结构是：</p>
<ul>
<li><strong>次关键码</strong>，如“英文单词”</li>
<li><strong>记录号表</strong>，如“文章编号”</li>
</ul>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/168import.png" alt></p>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（in-verted index）。倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引</p>
<h1 id="8-5-二叉排序树"><a href="#8-5-二叉排序树" class="headerlink" title="8.5 二叉排序树"></a>8.5 二叉排序树</h1><p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/169import.png" alt></p>
<p>对集合{62,88,58,47,35,73,51,99,37,93}做查找，用二叉树结构排好序的二叉树来创建：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/170import.png" alt></p>
<p>进行中序遍历时，得到一个有序的序列{35,37,47,51,58,62,73,88,93,99}，称它为<strong>二叉排序树</strong></p>
<p><strong>二叉排序树（Binary Sort Tree），又称为二叉查找树</strong>。它或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结构的值</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li>
<li>左、右子树也分别为二叉排序树</li>
</ul>
<h2 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h2><p>二叉树的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span>  </span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> /* 结点结构 */  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> data;   <span class="comment">/* 结点数据 */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>    <span class="comment">/* 左右孩子指针 */</span>  </span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>二叉排序树的查找实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 递归查找二叉排序树T中是否存在key, */</span>  </span><br><span class="line"><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span>  </span><br><span class="line"><span class="comment">/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */</span>  </span><br><span class="line"><span class="comment">/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */</span>  </span><br><span class="line"><span class="function">Status <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree *p)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="comment">/*  查找不成功 */</span>  </span><br><span class="line">    &#123;   </span><br><span class="line">        *p = f;    </span><br><span class="line">        <span class="keyword">return</span> FALSE;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key==T-&gt;data) <span class="comment">/*  查找成功 */</span>  </span><br><span class="line">    &#123;   </span><br><span class="line">        *p = T;    </span><br><span class="line">        <span class="keyword">return</span> TRUE;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data)   </span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p);  <span class="comment">/*  在左子树中继续查找 */</span>  </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p);  <span class="comment">/*  在右子树中继续查找 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数调用时的语句为SearchBST(T,93,NULL,p)，参数T是一个二叉链表，数据如图，key代表要查找的关键字，打算查找93，二叉树f指向T的双亲，当T指向根结点时，f的初值为NULL，它在递归时有用，最后的参数p是为了查找成功后可以得到查找到的结点位置</li>
<li>第7～11行，判断当前二叉树是否到叶子结点，下图当前T指向根结点62的位置，T不为空，第9～10行不执行<img src="https://baozou.gitbooks.io/-data-structure/content/assets/174import.png" alt></li>
<li>第12～16行是查找到相匹配的关键字时执行语句，显然93≠62，第14～15行不执行</li>
<li>第17～18行是当要查找关键字小于当前结点值时执行语句，由于93&gt;62，第18行不执行</li>
<li>第19～20行是当要查找关键字大于当前结点值时执行语句，由于93&gt;62，所以递归调用SearchBST(T-&gt;rchild,key,T,p)。此时T指向了62的右孩子88<img src="https://baozou.gitbooks.io/-data-structure/content/assets/175import.png" alt></li>
<li>此时第二层SearchBST，因93比88大，执行第20行，再次递归调用SearchBST(T-&gt;rchild,key,T,p)。此时T指向了88的右孩子99<img src="https://baozou.gitbooks.io/-data-structure/content/assets/176import.png" alt></li>
<li>第三层的SearchBST，因93比99小，所以执行第18行，递归调用SearchBST(T-&gt;lchild,key,T,p)。此时T指向了99的左孩子93<img src="https://baozou.gitbooks.io/-data-structure/content/assets/178import.png" alt></li>
<li>第四层SearchBST，因key等于T-&gt;data，所以执行第14～15行，此时指针p指向93所在的结点，并返回True到第三层、第二层、第一层，最终函数返回True</li>
</ol>
<h2 id="二叉排序树插入操作"><a href="#二叉排序树插入操作" class="headerlink" title="二叉排序树插入操作"></a>二叉排序树插入操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  当二叉排序树T中不存在关键字等于key的数据元素时， */</span>  </span><br><span class="line"><span class="comment">/*  插入key并返回TRUE，否则返回FALSE */</span>  </span><br><span class="line"><span class="function">Status <span class="title">InsertBST</span><span class="params">(BiTree *T, <span class="keyword">int</span> key)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    BiTree p,s;  </span><br><span class="line">    <span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) <span class="comment">/* 查找不成功 */</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));  </span><br><span class="line">        s-&gt;data = key;    </span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;    </span><br><span class="line">        <span class="keyword">if</span> (!p)   </span><br><span class="line">            *T = s;         <span class="comment">/*  插入s为新的根结点 */</span>  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key&lt;p-&gt;data)   </span><br><span class="line">            p-&gt;lchild = s;   <span class="comment">/*  插入s为左孩子 */</span>  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">            p-&gt;rchild = s;  <span class="comment">/*  插入s为右孩子 */</span>  </span><br><span class="line">        <span class="keyword">return</span> TRUE;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>   </span><br><span class="line">        <span class="keyword">return</span> FALSE;  <span class="comment">/*  树中已有关键字相同的结点，不再插入 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数是“InsertBST(&amp;T,93);”，那么结果就是FALSE，如果是“InsertBST(&amp;T,95);”，那么一定就是在93的结点增加一个右孩子95，并且返回True</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/179import.png" alt></p>
<p>实现二叉排序树的构建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span> &#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"></span><br><span class="line">    InsertBST(&amp;T, a[i]);</span><br></pre></td></tr></table></figure>
<h2 id="二叉排序树删除操作"><a href="#二叉排序树删除操作" class="headerlink" title="二叉排序树删除操作"></a>二叉排序树删除操作</h2><p>如果需要查找并删除如37、51、73、93这些在二叉排序树中是叶子的结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/182import.png" alt></p>
<p>删除的结点只有左子树或只有右子树的情况，就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/183import.png" alt></p>
<blockquote>
<p>先删除35和99结点，再删除58结点</p>
</blockquote>
<p>要删除的结点既有左子树又有右子树的情况：</p>
<p>找到需要删除的结点p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除此结点s，若要删除47，即对二叉排序树进行中序遍历，得到的序列{29,35,36,37,47,48,49,50,51,56,58,62,73,88,93,99}，37和48正好是47的前驱和后继</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/181import.png" alt></p>
<p>删除结点三种情况的分析：</p>
<ul>
<li>叶子结点</li>
<li>仅有左或右子树的结点</li>
<li>左右子树都有的结点</li>
</ul>
<p>递归方式对二叉排序树T查找key，查找到时删除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span>  </span><br><span class="line"><span class="comment">/* 并返回TRUE；否则返回FALSE。 */</span>  </span><br><span class="line"><span class="function">Status <span class="title">DeleteBST</span><span class="params">(BiTree *T,<span class="keyword">int</span> key)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span>   </span><br><span class="line">        <span class="keyword">return</span> FALSE;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (key==(*T)-&gt;data) <span class="comment">/* 找到关键字等于key的数据元素 */</span>   </span><br><span class="line">            <span class="keyword">return</span> Delete(T);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key&lt;(*T)-&gt;data)  </span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */</span>  </span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(BiTree *p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    BiTree q,s;  </span><br><span class="line">    <span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        q=*p; *p=(*p)-&gt;lchild; <span class="built_in">free</span>(q);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">/* 只需重接它的右子树 */</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        q=*p; *p=(*p)-&gt;rchild; <span class="built_in">free</span>(q);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        q=*p; s=(*p)-&gt;lchild;  </span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            q=s;  s=s-&gt;rchild;  </span><br><span class="line">        &#125;  </span><br><span class="line">        (*p)-&gt;data=s-&gt;data; <span class="comment">/*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span>  </span><br><span class="line">        <span class="keyword">if</span>(q!=*p)  </span><br><span class="line">            q-&gt;rchild=s-&gt;lchild; <span class="comment">/*  重接q的右子树 */</span>   </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            q-&gt;lchild=s-&gt;lchild; <span class="comment">/*  重接q的左子树 */</span>  </span><br><span class="line">        <span class="built_in">free</span>(s);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> TRUE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>程序开始执行，代码第5～8行目的是为了删除没有右子树只有左子树的结点。此时只需将此结点的左孩子替换它自己，然后释放此结点内存，就等于删除了。</li>
<li>代码第9～12行处理只有右子树没有左子树的结点删除问题</li>
<li>第13～26行处理复杂的左右子树均存在的问题</li>
<li>第15行，将要删除的结点p赋值给临时的变量q，再将p的左孩子p-&gt;lchild赋值给临时的变量s。此时q指向47结点，s指向35结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/191import.png" alt></li>
<li>第16～19行，循环找到左子树的右结点，直到右侧尽头。让q指向35，而s指向了37这个再没有右子树的结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/193import.png" alt></li>
<li>第20行，此时让要删除的结点p的位置的数据被赋值为s-&gt;data，即让p-&gt;data=37<img src="https://baozou.gitbooks.io/-data-structure/content/assets/194import.png" alt></li>
<li>第21～24行，如果p和q指向不同，则将s-&gt;lchild赋值给q-&gt;rchild，否则就是将s-&gt;lchild赋值给q-&gt;lchild。显然这个例子p不等于q，将s-&gt;lchild指向的36赋值给q-&gt;rchild，也就是让q-&gt;rchild指向36结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/195import.png" alt></li>
<li>第25行，free(s)，将37结点删除<img src="https://baozou.gitbooks.io/-data-structure/content/assets/196import.png" alt></li>
</ol>
<h2 id="二叉排序树总结"><a href="#二叉排序树总结" class="headerlink" title="二叉排序树总结"></a>二叉排序树总结</h2><p>二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可</p>
<p>对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。最少为1次，即根结点就是要找的结点，最多不超过树的深度</p>
<h1 id="8-6-平衡二叉树（AVL树）"><a href="#8-6-平衡二叉树（AVL树）" class="headerlink" title="8.6 平衡二叉树（AVL树）"></a>8.6 平衡二叉树（AVL树）</h1><p><strong>平衡二叉树（Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</strong></p>
<p>高度平衡的二叉排序树：</p>
<ul>
<li>要么它是一棵空树</li>
<li>要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1</li>
</ul>
<p><strong>二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）</strong>，平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的</p>
<p>当新插入结点37时，距离它最近的平衡因子绝对值超过1的结点是58（即它的左子树高度3减去右子树高度1），所以从58开始以下的子树为最小不平衡子树</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/197import.png" alt></p>
<h2 id="平衡二叉树实现原理"><a href="#平衡二叉树实现原理" class="headerlink" title="平衡二叉树实现原理"></a>平衡二叉树实现原理</h2><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树</p>
<p>对数组a[10]={3,2,1,4,5,6,7,10,9,8}构建平衡二叉树：</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/198import.png" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/199import.png" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/201import.png" alt></p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/202import.png" alt></p>
<p>当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋，如上例中结点1、5、6、7的插入等。插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作，如上例中结点9、8的插入时</p>
<h2 id="平衡二叉树实现算法"><a href="#平衡二叉树实现算法" class="headerlink" title="平衡二叉树实现算法"></a>平衡二叉树实现算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>    /* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;    <span class="comment">/* 结点数据 */</span></span><br><span class="line">    <span class="keyword">int</span> bf; <span class="comment">/*  结点的平衡因子 */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>    <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>对于右旋操作，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对以p为根的二叉排序树作右旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BiTree L;</span><br><span class="line">    L=(*P)-&gt;lchild; <span class="comment">/*  L指向P的左子树根结点 */</span> </span><br><span class="line">    (*P)-&gt;lchild=L-&gt;rchild; <span class="comment">/*  L的右子树挂接为P的左子树 */</span> </span><br><span class="line">    L-&gt;rchild=(*P);</span><br><span class="line">    *P=L; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数代码的意思是当传入一个二叉排序树P，将它的左孩子结点定义为L，将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P成为根结点。这样就完成了一次右旋操作，如图。图中三角形代表子树，N代表新增结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/203import.png" alt></p>
<p>左旋操作代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对以P为根的二叉排序树作左旋处理， */</span></span><br><span class="line"><span class="comment">/* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(BiTree *P)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BiTree R;</span><br><span class="line">    R=(*P)-&gt;rchild; <span class="comment">/*  R指向P的右子树根结点 */</span> </span><br><span class="line">    (*P)-&gt;rchild=R-&gt;lchild; <span class="comment">/* R的左子树挂接为P的右子树 */</span> </span><br><span class="line">    R-&gt;lchild=(*P);</span><br><span class="line">    *P=R; <span class="comment">/*  P指向新的根结点 */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左平衡旋转处理的函数代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LH +1 <span class="comment">/*  左高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EH 0  <span class="comment">/*  等高 */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RH -1 <span class="comment">/*  右高 */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  对以指针T所指结点为根的二叉树作左平衡旋转处理 */</span></span><br><span class="line"><span class="comment">/*  本算法结束时，指针T指向新的根结点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BiTree L,Lr;</span><br><span class="line">    L=(*T)-&gt;lchild; <span class="comment">/*  L指向T的左子树根结点 */</span> </span><br><span class="line">    <span class="keyword">switch</span>(L-&gt;bf)</span><br><span class="line">    &#123; <span class="comment">/*  检查T的左子树的平衡度，并作相应平衡处理 */</span> </span><br><span class="line">         <span class="keyword">case</span> LH: <span class="comment">/*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */</span> </span><br><span class="line">            (*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">            R_Rotate(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> RH: <span class="comment">/*  新结点插入在T的左孩子的右子树上，要作双旋处理 */</span> </span><br><span class="line">            Lr=L-&gt;rchild; <span class="comment">/*  Lr指向T的左孩子的右子树根 */</span> </span><br><span class="line">            <span class="keyword">switch</span>(Lr-&gt;bf)</span><br><span class="line">            &#123; <span class="comment">/*  修改T及其左孩子的平衡因子 */</span> </span><br><span class="line">                <span class="keyword">case</span> LH: (*T)-&gt;bf=RH;</span><br><span class="line">                         L-&gt;bf=EH;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EH: (*T)-&gt;bf=L-&gt;bf=EH;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RH: (*T)-&gt;bf=EH;</span><br><span class="line">                         L-&gt;bf=LH;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Lr-&gt;bf=EH;</span><br><span class="line">            L_Rotate(&amp;(*T)-&gt;lchild); <span class="comment">/*  对T的左子树作左旋平衡处理 */</span> </span><br><span class="line">            R_Rotate(T); <span class="comment">/*  对T作右旋平衡处理 */</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>函数被调用，传入一个需调整平衡性的子树T。由于LeftBalance函数被调用时，已经确认当前子树是不平衡状态，且左子树的高度大于右子树的高度。此时T的根结点平衡因子BF的值是大于1</li>
<li>当L的平衡因子为LH，即为1时，表明它与根结点的BF值符号相同，第14行，将它们的BF值都改为0，第15行，进行右旋操作<img src="https://baozou.gitbooks.io/-data-structure/content/assets/205import.png" alt></li>
<li>当L的平衡因子为RH，即为-1时，表明它与根结点的BF值符号相反，此时需要做双旋处理。第19～28行，针对L的右孩子Lr的BF作判断，修改根结点T和L的BF值</li>
<li>第31行，对根结点的左子树进行左旋，如第二图所示</li>
<li>第32行，对根结点进行右旋，如第三图所示，完成平衡操作<img src="https://baozou.gitbooks.io/-data-structure/content/assets/204import.png" alt></li>
</ol>
<p>主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */</span> </span><br><span class="line"><span class="comment">/*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */</span> </span><br><span class="line"><span class="comment">/*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */</span></span><br><span class="line"><span class="function">Status <span class="title">InsertAVL</span><span class="params">(BiTree *T,<span class="keyword">int</span> e,Status *taller)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!*T)</span><br><span class="line">    &#123; <span class="comment">/*  插入新结点，树“长高”，置taller为TRUE */</span> </span><br><span class="line">         *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">         (*T)-&gt;data=e; </span><br><span class="line">         (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="literal">NULL</span>; </span><br><span class="line">         (*T)-&gt;bf=EH;</span><br><span class="line">         *taller=TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e==(*T)-&gt;data)</span><br><span class="line">        &#123; <span class="comment">/*  树中已存在和e有相同关键字的结点则不再插入 */</span> </span><br><span class="line">            *taller=FALSE; </span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e&lt;(*T)-&gt;data)</span><br><span class="line">        &#123; <span class="comment">/*  应继续在T的左子树中进行搜索 */</span> </span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span>(taller) <span class="comment">/*   已插入到T的左子树中且左子树“长高” */</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，需要作左平衡处理 */</span> </span><br><span class="line">                            LeftBalance(T); </span><br><span class="line">                            *taller=FALSE; </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因左子树增高而使树增高 */</span> </span><br><span class="line">                            (*T)-&gt;bf=LH; </span><br><span class="line">                            *taller=TRUE; </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，现左、右子树等高 */</span>  </span><br><span class="line">                            (*T)-&gt;bf=EH; </span><br><span class="line">                            *taller=FALSE; </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">/*  应继续在T的右子树中进行搜索 */</span> </span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) <span class="comment">/*  未插入 */</span> </span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            <span class="keyword">if</span>(*taller) <span class="comment">/*  已插入到T的右子树且右子树“长高” */</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>((*T)-&gt;bf) <span class="comment">/*  检查T的平衡度 */</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH: <span class="comment">/*  原本左子树比右子树高，现左、右子树等高 */</span> </span><br><span class="line">                            (*T)-&gt;bf=EH; </span><br><span class="line">                            *taller=FALSE; </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH: <span class="comment">/*  原本左、右子树等高，现因右子树增高而使树增高  */</span></span><br><span class="line">                            (*T)-&gt;bf=RH; </span><br><span class="line">                            *taller=TRUE; </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH: <span class="comment">/*  原本右子树比左子树高，需要作右平衡处理 */</span> </span><br><span class="line">                            RightBalance(T); </span><br><span class="line">                            *taller=FALSE; </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第6～13行是指当前T为空时，则申请内存新增一个结点</li>
<li>第16～20行表示当存在相同结点，则不需要插入</li>
<li>第21～43行，当新结点e小于T的根结点值时，则在T的左子树查找</li>
<li>第23～24行，递归调用本函数，直到找到则返回false，否则说明插入结点成功，执行下面语句</li>
<li>第25～42行，当taller为TRUE时，说明插入了结点，此时需要判断T的平衡因子，如果是1，说明左子树高于右子树，需要调用LeftBalance函数进行左平衡旋转处理。如果为0或-1，则说明新插入结点没有让整棵二叉排序树失去平衡性，只需要修改相关的BF值即可</li>
<li>第44～66行，说明新结点e大于T的根结点的值，在T的右子树查找</li>
</ol>
<p>只需要在构建平衡二叉树的时候执行如下列代码即可在内存中生成一棵下图的平衡二叉树：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    BiTree T=<span class="literal">NULL</span>;</span><br><span class="line">    Status taller;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找时间复杂度为<script type="math/tex">O(\log n)</script>，插入和删除也为<script type="math/tex">O(\log n)</script></p>
<h1 id="8-7-多路查找树（B树）"><a href="#8-7-多路查找树（B树）" class="headerlink" title="8.7 多路查找树（B树）"></a>8.7 多路查找树（B树）</h1><p><strong>多路查找树（muitl-way search tree），其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</strong>。由于是查找树，所有元素之间存在某种特定的排序关系</p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p><strong>2-3树是每一个结点都具有两个孩子（2结点）或三个孩子（3结点）的一棵多路查找树</strong></p>
<p>一个2结点包含一个元素和两个孩子（或没有孩子），左子树包含的元素小于该元素，右子树包含的元素大于该元素。这个2结点要么没有孩子，要有就有两个，不能只有一个孩子</p>
<p>一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。并且2-3树中所有的叶子都在同一层次上</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/206import.png" alt></p>
<h3 id="2-3树的插入实现"><a href="#2-3树的插入实现" class="headerlink" title="2-3树的插入实现"></a>2-3树的插入实现</h3><p>2-3树的插入操作一定是发生在叶子结点上。插入一个元素的过程有可能会对该树的其余结构产生连锁反应。</p>
<p>2-3树插入可分为三种情况：</p>
<ol>
<li>对于空树，插入一个2结点即可</li>
<li>插入结点到一个2结点的叶子上。由于其本身就只有一个元素，只需要将其升级为3结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/207import.png" alt></li>
<li><p>往3结点中插入一个新元素。因为3结点本身已经是2-3树的结点最大容量（已经有两个元素），需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层</p>
</li>
<li><p>第一种情况，元素5需要插入在拥有6、7元素的3结点位置。将6、7结点拆分，让6与4结成3结点，将5成为它的中间孩子，将7成为它的右孩子<img src="https://baozou.gitbooks.io/-data-structure/content/assets/208import.png" alt></p>
</li>
<li><p>向左图中插入元素11。需要插入在拥有9、10元素的3结点位置。9和10结点不能再增加结点。双亲结点12、14是一个3结点，也不能再插入元素。12、14结点的双亲，结点8是个2结点。将9、10拆分，12、14也拆分，让根结点8升级为3结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/209import.png" alt></p>
</li>
<li><p>插入元素2，1、3，4、6，8、12都是3结点，不能再插入元素，当前树结构是三层不能满足当前结点的增加。于是将1、3拆分，4、6拆分，连根结点8、12也拆分<img src="https://baozou.gitbooks.io/-data-structure/content/assets/210import.png" alt>如果2-3树插入的传播效应导致了根结点的拆分，则树的高度就会增加</p>
</li>
</ol>
<h3 id="2-3树的删除实现"><a href="#2-3树的删除实现" class="headerlink" title="2-3树的删除实现"></a>2-3树的删除实现</h3><p>1.删除元素位于一个3结点的叶子结点上，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/211import.png" alt></p>
<p>2.删除的元素位于一个2结点上，分四种情形</p>
<ul>
<li>此结点的双亲也是2结点，且拥有一个3结点的右孩子。删除结点1，只需要左旋<img src="https://baozou.gitbooks.io/-data-structure/content/assets/213import.png" alt></li>
<li>此结点的双亲是2结点，它的右孩子也是2结点。删除结点4，直接左旋会造成没有右孩子，办法是让结点7变成3结点，让比7稍大的元素8下来，让比元素8稍大的元素9补充结点8的位置（中间图），再用左旋的方式变成右图结果<img src="https://baozou.gitbooks.io/-data-structure/content/assets/215import.png" alt></li>
<li>此结点双亲是一个3结点，将双亲拆分，并将12与13合并成为左孩子<img src="https://baozou.gitbooks.io/-data-structure/content/assets/216import.png" alt></li>
<li>当前树是一个满二叉树的情况，删除任何一个叶子都会使得整棵树不能满足2-3树的定义。删除叶子结点8时（任何一个结点都一样），要将2-3的层数减少，办法是将8的双亲和其左子树6合并为一3个结点，再将14与9合并为3结点<img src="https://baozou.gitbooks.io/-data-structure/content/assets/217import.png" alt></li>
</ul>
<p>3.删除的元素位于非叶子的分支结点。通常是将树按中序遍历后得到此元素的前驱或后继元素，让它们来补位</p>
<ul>
<li>删除的分支结点是2结点。删除结点4，前驱是1后继是6，由于6、7是3结点，用6来补位<img src="https://baozou.gitbooks.io/-data-structure/content/assets/218import.png" alt></li>
<li>删除的分支结点是3结点的某一元素，删除结点12、14的12，将是3结点的左孩子的10上升到删除位置<img src="https://baozou.gitbooks.io/-data-structure/content/assets/219import.png" alt></li>
</ul>
<h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><p>2-3-4树是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素</p>
<p>构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树过程，图1是在分别插入7、1、2时的结果图，因为3个元素满足2-3-4树的单个4结点定义，因此此时不需要拆分，接着插入元素5，因为已经超过了4结点的定义，因此拆分为图2的形状。之后的图是在元素不断插入时最后形成的</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/220import.png" alt></p>
<p>2-3-4树删除结点的演变过程，删除顺序是1、6、3、4、5、2、9</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/221import.png" alt></p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><strong>B树（B-tree）是一种平衡的多路查找树</strong>，2-3树和2-3-4树是B树的特例。<strong>结点最大的孩子数目称为B树的阶（order）</strong>，2-3树是3阶B树，2-3-4树是4阶B树</p>
<script type="math/tex; mode=display">m$$阶的B树具有如下属性：

* 如果根结点不是叶结点，则其至少有两棵子树
* 每一个非根的分支结点都有$$k-1$$个元素和$$k$$个孩子，其中。每一个叶子结点$$n$$都有$$k-1$$个元素，其中$$[\frac{m}{2}]\le k \le m</script><ul>
<li>所有叶子结点都位于同一层次</li>
<li>所有分支结点包含下列信息数据<script type="math/tex">(n,A_0,K_1,A_1,K_2,A_2,\cdots,K_n,A_n)</script>，其中：<script type="math/tex">K_i(i=1,2,\cdots,n)</script>为关键字，且<script type="math/tex">K_i<K_{i+1}(i=1,2,\cdots,n-1)</script>；<script type="math/tex">A_i(i=0,2,\cdots,n)</script>为指向子树根结点的指针，且指针<script type="math/tex">A_{i-1}</script>所指子树中所有结点的关键字均小于<script type="math/tex">K_i(i=1,2,\cdots,n)</script>，<script type="math/tex">A_n</script>所指子树中所有结点的关键字均大于<script type="math/tex">K_n</script>，<script type="math/tex">n([\frac{m}{2}]-1\le n \le m-1)</script>为关键字的个数（或<script type="math/tex">n+1</script>为子树的个数）</li>
</ul>
<p>2-3-4树时插入9个数后的图转成B树如图。左侧灰色方块表示当前结点的元素个数</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/225import.png" alt></p>
<p>在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程</p>
<p>比如查找数字7，首先从外存（比如硬盘中）读取得到根结点3、5、8三个元素，发现7不在当中，但在5和8之间，因此就通过<script type="math/tex">A_2</script>再读取外存的6、7结点，查找到所要的元素</p>
<script type="math/tex; mode=display">n$$个关键字的$$m$$阶B树，最坏情况的查找次数：

第一层至少有1个结点，第二层至少有2个结点，由于除根结点外每个分支结点至少有$$|\frac{m}{2}|$$棵子树，则第三层至少有2×$$|\frac{m}{2}|$$个结点，……，这样第k+1层至少有2×$$(|\frac{m}{2}|)^{k-1}$$个结点，k+1层的结点就是叶子结点。若m阶B树有n个关键字，当找到了叶子结点，等于查找不成功的结点为n+1，因此n+1≥2×\($$|\frac{m}{2}|$$\)$$^{k-1}$$，即：</script><p>k \le \log _{|\frac{m}{2}|}(\frac{n+1}{2})+1</p>
<script type="math/tex; mode=display">


在含有n个关键字的B树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过$$\log _{|\frac{m}{2}|}(\frac{n+1}{2})+1</script><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树结构中，往返于每个结点必须得在硬盘的页面之间进行多次访问，假设每个结点都属于硬盘的不同页面，为了中序遍历所有的元素，页面2→页面1→页面3→页面1→页面4→页面1→页面5。而且每次经过结点遍历时，都会对结点中的元素进行一次遍历</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/229import.png" alt></p>
<p>在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针</p>
<p>下图是一棵B+树的示意，灰色关键字是根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/230import.png" alt></p>
<p>一棵m阶的B+树和m阶的B树的差异在于：</p>
<ul>
<li>有n棵子树的结点中包含有n个关键字</li>
<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字</li>
</ul>
<p>如果是要随机查找，就从根结点出发，与B树的查找方式相同，不过即使在分支结点找到了待查找的关键字，也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。</p>
<p>如果从最小关键字进行从小到大的顺序查找，可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字</p>
<p>B+树的插入、删除过程都与B树类似，不过插入和删除的元素都在叶子结点上进行</p>
<h1 id="8-8-散列表查找（哈希表）概述"><a href="#8-8-散列表查找（哈希表）概述" class="headerlink" title="8.8 散列表查找（哈希表）概述"></a>8.8 散列表查找（哈希表）概述</h1><h2 id="散列表查找定义"><a href="#散列表查找定义" class="headerlink" title="散列表查找定义"></a>散列表查找定义</h2><p>通过某个函数f，使得</p>
<script type="math/tex; mode=display">
\text{存储位置}=f(\text{关键字})</script><p>可以通过查找关键字不需要比较就可获得需要的记录的存储位置</p>
<p><strong>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）</strong>。</p>
<p>查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上</p>
<p><strong>对应关系</strong><script type="math/tex">f</script><strong>称为散列函数，又称为哈希（Hash）函数</strong>。<strong>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。关键字对应的记录存储位置称为散列地址</strong></p>
<h2 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h2><ol>
<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。不管什么记录，都需要用同一个散列函数计算出地址再存储<img src="https://baozou.gitbooks.io/-data-structure/content/assets/231import.png" alt></li>
<li>查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。由于存取用的是同一个散列函数，因此结果相同</li>
</ol>
<p><strong>散列技术既是一种存储方法，也是一种查找方法</strong></p>
<p>散列技术的记录之间不存在逻辑关系，只与关键字有关联。散列主要是面向查找的存储结构</p>
<p><strong>散列技术最适合的求解问题是查找与给定值相等的记录</strong></p>
<p>散列技术不适合：</p>
<ol>
<li>同样关键字对应很多记录的情况</li>
<li>范围查找</li>
</ol>
<p>在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中时常会碰到<strong>两个关键字key1≠key2，但是却有f(key1)=f(key2)，这种现象称为冲突（colli-sion），并把key1和key2称为这个散列函数的同义词（synonym）</strong></p>
<h1 id="8-9-散列函数的构造方法"><a href="#8-9-散列函数的构造方法" class="headerlink" title="8.9 散列函数的构造方法"></a>8.9 散列函数的构造方法</h1><p>两个原则：</p>
<ul>
<li><strong>计算简单</strong>。散列函数的计算时间不应该超过其他查找技术与关键字比较的时间</li>
<li>散列地址分布均匀。尽量让散列地址均匀地分布在存储空间中，保证存储空间的有效利用，减少为处理冲突而耗费的时间</li>
</ul>
<h2 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h2><p>对0～100岁的人口数字统计表，对年龄这个关键字就可以直接用年龄的数字作为地址。此时f(key)=key</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/239import.png" alt></p>
<p>统计80后出生年份的人口数，对出生年份这个关键字可以用年份减去1980来作为地址。此时f(key)=key-1980</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/240import.png" alt></p>
<p>可以取关键字的某个线性函数值为散列地址，(a、b为常数)即</p>
<script type="math/tex; mode=display">
f(key)=a\times key+b(a,b\text{为常数})</script><p>这样的散列函数优点是简单、均匀，不产生冲突，但问题是需要事先知道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用</p>
<h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><p>如果关键字是位数较多的数字，比如11位手机号前三位是接入号，一般对应不同运营商公司的子品牌；中间四位是HLR识别号，表示用户号的归属地；后四位是真正的用户号</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/241import.png" alt></p>
<p>如果用手机号作为关键字，极有可能前7位都是相同的。那么选择后面的四位成为散列地址就是不错的选择<br>如果这样的抽取工作还是容易出现冲突问题，还可以对抽取出来的数字再进行反转（如1234改成4321）、右环位移（如1234改成4123）、左环位移、甚至前两数与后两数叠加（如1234改成12+34=46）等方法。总的目的就是为了提供一个散列函数，能够合理地将关键字分配到散列表的各位置<br>抽取方法是使用关键字的一部分来计算散列存储位置的方法，数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，可以考虑用这个方法</p>
<h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>关键字1234的平方是1522756，抽取中间的3位227用做散列地址。关键字是4321的平方就是18671041，抽取中间的3位671或710用做散列地址<br>平方取中法适合于不知道关键字的分布，而位数又不是很大的情况</p>
<h2 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h2><p><strong>折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址</strong></p>
<p>关键字9876543210，散列表表长为三位，分为四组，987|654|321|0，叠加求和987+654+321+0=1962，得到散列地址为962<br>有时还不能保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。比如将987和321反转，再与654和0相加，变成789+654+123+0=1566，此时散列地址为566</p>
<p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况</p>
<h2 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h2><p>此方法为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：</p>
<script type="math/tex; mode=display">
f(key)=key\ mod\ p(p\le m)</script><p>这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。本方法的关键在于选择合适的p，p如果选得不好，可能会容易产生同义词<br>对于有12个记录的关键字构造散列表时，就用了f(key)=key mod 12的方法</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/243import.png" alt></p>
<p>极端：让p为12，所有的关键字都得到了0这个地址数</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/244import.png" alt></p>
<p>若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数</p>
<h2 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h2><p>选择一个随机数，取关键字的随机函数值为它的散列地址。即</p>
<script type="math/tex; mode=display">
f(key)=random(key)</script><p>random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数比较合适</p>
<p>应该视不同的情况采用不同的散列函数。考虑因素：</p>
<ol>
<li>计算散列地址所需的时间</li>
<li>关键字的长度</li>
<li>散列表的大小</li>
<li>关键字的分布情况</li>
<li>记录查找的频率</li>
</ol>
<p>综合这些因素，才能决策选择哪种散列函数更合适</p>
<h1 id="8-10-处理散列冲突的方法"><a href="#8-10-处理散列冲突的方法" class="headerlink" title="8.10 处理散列冲突的方法"></a>8.10 处理散列冲突的方法</h1><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p><strong>开放定址法是一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</strong></p>
<p>公式：</p>
<script type="math/tex; mode=display">
f_i(key)=(f(key)+d_i)\ MOD\ m\
(d_i=1,2,3,......,m-1)</script><p>这种<strong>解决冲突的开放定址法称为线性探测法</strong></p>
<p><strong>本来都不是同义词却需要争夺一个地址的情况，这种现象为堆积，</strong>堆积的出现需要不断处理冲突，无论存入还是查找效率都会大大降低</p>
<p><strong>增加平方运算的目的是为了不让关键字都聚集在某一块区域。这种方法为二次探测法</strong></p>
<script type="math/tex; mode=display">
f_i(key)=(f(key)+d_i)\ MOD\ m\ (d_i=1^2,-1^2,2^2,-2^2,\cdots,q^2,-q^2,q\le \frac{m}{2})</script><p>还有一种方法是<strong>在冲突时，对于位移量</strong><script type="math/tex">d_i</script><strong>采用随机函数计算得到，称之为随机探测法</strong></p>
<p>这里的随机是伪随机数。如果设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，在查找时，用同样的随机种子，每次得到的数列是相同的，相同的<script type="math/tex">d_i</script>可以得到相同的散列地址</p>
<script type="math/tex; mode=display">
f_i(key)=(f(key)+d_i)\ MOD\ m\ (d_i\text{是一个随机数列})</script><p>开放定址法只要在散列表未填满时，总能找到不发生冲突的地址，是常用的解决冲突的办法</p>
<h2 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h2><p>事先准备多个散列函数。</p>
<script type="math/tex; mode=display">
f
_i(key)=RH_i(key)(i=1,2,...,k)</script><p><script type="math/tex">RH_i</script>是不同的散列函数,每当发生散列地址冲突时，就换一个散列函数计算，这种方法能够使得关键字不产生聚集，也增加了计算的时间</p>
<h2 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h2><p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针</p>
<p>对关键字集合{12,67,56,16,25,37,22,29,15,47,48,34}，用12为除数,不存在冲突换址的问题，无论有多少个冲突，都只在当前位置给单链表增加结点</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/250import.png" alt></p>
<p>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。也带来了查找时需要遍历单链表的性能损耗</p>
<h2 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h2><p>关键字{37,48,34}与之前的关键字位置有冲突，将它们存储到溢出表</p>
<p><img src="https://baozou.gitbooks.io/-data-structure/content/assets/245import.png" alt></p>
<p>查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高</p>
<h1 id="8-11-散列表查找实现"><a href="#8-11-散列表查找实现" class="headerlink" title="8.11 散列表查找实现"></a>8.11 散列表查找实现</h1><h2 id="散列表查找算法实现"><a href="#散列表查找算法实现" class="headerlink" title="散列表查找算法实现"></a>散列表查找算法实现</h2><p>HashTable是散列表结构。结构当中的elem为一个动态数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="comment">/* 定义散列表长为数组的长度 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASHSIZE 12    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数据元素存储基址，动态分配数组 */</span></span><br><span class="line">    <span class="keyword">int</span> *elem;         </span><br><span class="line">    <span class="comment">/* 当前数据元素个数 */</span></span><br><span class="line">    <span class="keyword">int</span> count;         </span><br><span class="line">&#125; HashTable;</span><br><span class="line"><span class="comment">/* 散列表表长，全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>对散列表初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line"><span class="function">Status <span class="title">InitHashTable</span><span class="params">(HashTable *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        H-&gt;elem[i] = NULLKEY;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了插入时计算地址，需要定义散列函数，散列函数可以根据不同情况更改算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 除留余数法 */</span></span><br><span class="line">    <span class="keyword">return</span> key % m; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化完成后，对散列表进行插入操作。假设插入的关键字集合是前面的{12,67,56,16,25,37,22,29,15,47,48,34}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入关键字进散列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertHash</span><span class="params">(HashTable *H, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    <span class="keyword">int</span> addr = Hash(key);               </span><br><span class="line">    <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY)    </span><br><span class="line">        <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;          </span><br><span class="line">    <span class="comment">/* 直到有空位后插入关键字 */</span></span><br><span class="line">    H-&gt;elem[addr] = key;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。此时应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其他解决冲突的办法</p>
<p>散列表存在后，需要时可以通过散列表查找要的记录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line"><span class="function">Status <span class="title">SearchHash</span><span class="params">(HashTable H, <span class="keyword">int</span> key, <span class="keyword">int</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 求散列地址 */</span></span><br><span class="line">    *addr = Hash(key);              </span><br><span class="line">    <span class="comment">/* 如果不为空，则冲突 */</span></span><br><span class="line">    <span class="keyword">while</span> (H.elem[*addr] != key)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 开放定址法的线性探测 */</span></span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;    </span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key))</span><br><span class="line">        &#123;                           </span><br><span class="line">            <span class="comment">/* 如果循环回到原点 */</span></span><br><span class="line">            <span class="comment">/* 则说明关键字不存在 */</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h2><p>散列查找的平均查找长度取决因素：</p>
<p>1．散列函数是否均匀</p>
<p>散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此可以不考虑它对平均查找长度的影响</p>
<p>2．处理冲突的方法</p>
<p>相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能</p>
<p>3．散列表的装填因子</p>
<p>所谓的装填因子<script type="math/tex">\alpha</script>=填入表中的记录个数/散列表长度。<script type="math/tex">\alpha</script>标志着散列表的装满的程度。当填入表中的记录越多，<script type="math/tex">\alpha</script>就越大，产生冲突的可能性就越大。如果散列表长度是12，而填入表中的记录个数为11，装填因子<script type="math/tex">\alpha​</script>=11/12=0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数</p>
<p>不管记录个数<script type="math/tex">n</script>有多大，总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时散列查找的时间复杂度是<script type="math/tex">O(1)</script>。通常都是将散列表的空间设置得比查找集合大，虽然是浪费了一定的空间，但换来的是查找效率的大大提升</p>

      
    </div>
    
    
    

    

    <div>
     
       <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
     
  </div>


    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>有钱能使鬼写作 л̵ʱªʱªʱª (ᕑᗢᓫา∗)˒</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="暴走 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpeg" alt="暴走 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"><i class="fa fa-tag"></i>

 数据结构</a>
          
            <a href="/tags/算法/" rel="tag"><i class="fa fa-tag"></i>

 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/08/大话数据结构-第七章  图/" rel="next" title="大话数据结构 第七章  图">
                <i class="fa fa-chevron-left"></i> 大话数据结构 第七章  图
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/08/大话数据结构-第九章-排序/" rel="prev" title="大话数据结构 第九章 排序">
                大话数据结构 第九章 排序 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2019/03/08/大话数据结构-第八章  查找/" data-title="大话数据结构 第八章  查找" data-url="https://www.baozouai.com/2019/03/08/大话数据结构-第八章  查找/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>



  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">


            
              <img class="site-author-image" itemprop="image" src="/img/avatar.png" alt="暴走">
            


              <p class="site-author-name" itemprop="name">暴走</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>
<script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>
<div class="aplayer" data-id="D89A1236EF4D99ED641FFD846F1A23AF" data-server="kugou " data-type="song" data-autoplay="false" data-mode="single"></div>
<br>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/baozouai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:baozouai@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#8-1-查找概论"><span class="nav-number">1.</span> <span class="nav-text">8.1 查找概论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-2-顺序表查找"><span class="nav-number">2.</span> <span class="nav-text">8.2 顺序表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序表查找算法"><span class="nav-number">2.1.</span> <span class="nav-text">顺序表查找算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序表查找优化"><span class="nav-number">2.2.</span> <span class="nav-text">顺序表查找优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-3-有序表查找"><span class="nav-number">3.</span> <span class="nav-text">8.3 有序表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#插值查找"><span class="nav-number">3.1.</span> <span class="nav-text">插值查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#斐波那契查找"><span class="nav-number">3.2.</span> <span class="nav-text">斐波那契查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-4-线性索引查找"><span class="nav-number">4.</span> <span class="nav-text">8.4 线性索引查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#稠密索引"><span class="nav-number">4.1.</span> <span class="nav-text">稠密索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分块索引"><span class="nav-number">4.2.</span> <span class="nav-text">分块索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-5-二叉排序树"><span class="nav-number">5.</span> <span class="nav-text">8.5 二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树查找操作"><span class="nav-number">5.1.</span> <span class="nav-text">二叉排序树查找操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树插入操作"><span class="nav-number">5.2.</span> <span class="nav-text">二叉排序树插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树删除操作"><span class="nav-number">5.3.</span> <span class="nav-text">二叉排序树删除操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树总结"><span class="nav-number">5.4.</span> <span class="nav-text">二叉排序树总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-6-平衡二叉树（AVL树）"><span class="nav-number">6.</span> <span class="nav-text">8.6 平衡二叉树（AVL树）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#平衡二叉树实现原理"><span class="nav-number">6.1.</span> <span class="nav-text">平衡二叉树实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平衡二叉树实现算法"><span class="nav-number">6.2.</span> <span class="nav-text">平衡二叉树实现算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-7-多路查找树（B树）"><span class="nav-number">7.</span> <span class="nav-text">8.7 多路查找树（B树）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3树"><span class="nav-number">7.1.</span> <span class="nav-text">2-3树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树的插入实现"><span class="nav-number">7.1.1.</span> <span class="nav-text">2-3树的插入实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3树的删除实现"><span class="nav-number">7.1.2.</span> <span class="nav-text">2-3树的删除实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-4树"><span class="nav-number">7.2.</span> <span class="nav-text">2-3-4树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B树"><span class="nav-number">7.3.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树"><span class="nav-number">7.4.</span> <span class="nav-text">B+树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-8-散列表查找（哈希表）概述"><span class="nav-number">8.</span> <span class="nav-text">8.8 散列表查找（哈希表）概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表查找定义"><span class="nav-number">8.1.</span> <span class="nav-text">散列表查找定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表查找步骤"><span class="nav-number">8.2.</span> <span class="nav-text">散列表查找步骤</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-9-散列函数的构造方法"><span class="nav-number">9.</span> <span class="nav-text">8.9 散列函数的构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#直接定址法"><span class="nav-number">9.1.</span> <span class="nav-text">直接定址法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数字分析法"><span class="nav-number">9.2.</span> <span class="nav-text">数字分析法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平方取中法"><span class="nav-number">9.3.</span> <span class="nav-text">平方取中法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#折叠法"><span class="nav-number">9.4.</span> <span class="nav-text">折叠法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#除留余数法"><span class="nav-number">9.5.</span> <span class="nav-text">除留余数法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机数法"><span class="nav-number">9.6.</span> <span class="nav-text">随机数法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-10-处理散列冲突的方法"><span class="nav-number">10.</span> <span class="nav-text">8.10 处理散列冲突的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#开放定址法"><span class="nav-number">10.1.</span> <span class="nav-text">开放定址法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再散列函数法"><span class="nav-number">10.2.</span> <span class="nav-text">再散列函数法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链地址法"><span class="nav-number">10.3.</span> <span class="nav-text">链地址法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公共溢出区法"><span class="nav-number">10.4.</span> <span class="nav-text">公共溢出区法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-11-散列表查找实现"><span class="nav-number">11.</span> <span class="nav-text">8.11 散列表查找实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表查找算法实现"><span class="nav-number">11.1.</span> <span class="nav-text">散列表查找算法实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散列表查找性能分析"><span class="nav-number">11.2.</span> <span class="nav-text">散列表查找性能分析</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>
    
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">暴走</span>

  
</div>



  <span class="post-meta-divider">|</span>






<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共136.1k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>
    
    
    
    
<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  
  <script type="text/javascript" color="255,0,0" opacity="0.5" zindex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  




  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>


  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/photoswipe.min.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/photoswipe-ui-default.min.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"notes-iissnan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("S5fCBBMaimjEzLztiJKSBnbL-gzGzoHsz", "m3rlGieJoVqNqhc9YbnO52cM");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.0.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.0.0"></script>


  

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":100,"height":100},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>


   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
